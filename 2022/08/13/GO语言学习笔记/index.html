

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="go语言学习笔记资料《Go学习路线图》 go语言圣经  Go语言101 位运算符   运算符 描述 实例    &amp; 按位与运算符”&amp;”是双目运算符。 其功能是参与运算的两数各对应的二进位相与。如果对应的位都为1，那么结果就是1， 如果任意一个位是0 则结果就是0 (A &amp; B) 结果为 12, 二进制为 0000 1100   | 按位或运算符”|”是双目运算符。 其功能是">
<meta property="og:type" content="article">
<meta property="og:title" content="GO语言学习笔记">
<meta property="og:url" content="http://example.com/2022/08/13/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="go语言学习笔记资料《Go学习路线图》 go语言圣经  Go语言101 位运算符   运算符 描述 实例    &amp; 按位与运算符”&amp;”是双目运算符。 其功能是参与运算的两数各对应的二进位相与。如果对应的位都为1，那么结果就是1， 如果任意一个位是0 则结果就是0 (A &amp; B) 结果为 12, 二进制为 0000 1100   | 按位或运算符”|”是双目运算符。 其功能是">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/08/13/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220813225331713.png">
<meta property="article:published_time" content="2022-08-13T15:38:01.000Z">
<meta property="article:modified_time" content="2022-08-15T13:32:00.242Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="GO">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/08/13/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220813225331713.png">
  
  
  
  <title>GO语言学习笔记 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="GO语言学习笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-13 23:38" pubdate>
          August 13, 2022 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          24k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          204 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">GO语言学习笔记</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="go语言学习笔记"><a href="#go语言学习笔记" class="headerlink" title="go语言学习笔记"></a>go语言学习笔记</h1><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7119123646471208968">《Go学习路线图》</a></p>
<p><a target="_blank" rel="noopener" href="https://books.studygolang.com/gopl-zh/">go语言圣经</a> </p>
<p><a target="_blank" rel="noopener" href="https://gfw.go101.org/">Go语言101</a></p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;</td>
<td align="left">按位与运算符”&amp;”是双目运算符。 其功能是参与运算的两数各对应的二进位相与。如果对应的位都为1，那么结果就是1， 如果任意一个位是0 则结果就是0</td>
<td align="left">(A &amp; B) 结果为 12, 二进制为 0000 1100</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">按位或运算符”|”是双目运算符。 其功能是参与运算的两数各对应的二进位相或。如果对应的位中任一个操作数为1 那么结果就是1</td>
<td align="left">(A | B) 结果为 61, 二进制为 0011 1101</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">按位异或运算符”^”是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。</td>
<td align="left">(A ^ B) 结果为 49, 二进制为 0011 0001</td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">左移运算符”&lt;&lt;”是双目运算符。左移n位就是乘以2的n次方。 其功能把”&lt;&lt;”左边的运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td>
<td align="left">A &lt;&lt; 2 结果为 240 ，二进制为 1111 0000</td>
</tr>
<tr>
<td align="left">&gt;&gt;</td>
<td align="left">右移运算符”&gt;&gt;”是双目运算符。右移n位就是除以2的n次方。 其功能是把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数。</td>
<td align="left">A &gt;&gt; 2 结果为 15 ，二进制为 0000 1111</td>
</tr>
</tbody></table>
<h2 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h2><p>这个例子展示了简单的cache，其使用两个包级别的变量来实现，一个mutex互斥量（§9.2）和它所操作的cache：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    mu sync.Mutex <span class="hljs-comment">// guards mapping</span><br>    mapping = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Lookup</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    mu.Lock()<br>    v := mapping[key]<br>    mu.Unlock()<br>    <span class="hljs-keyword">return</span> v<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面这个版本在功能上是一致的，但将两个包级别的变量放在了cache这个struct一组内：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//依次进行了定义、初始化、赋值</span><br><span class="hljs-keyword">var</span> cache = <span class="hljs-keyword">struct</span> &#123;<br>    sync.Mutex<br>    mapping <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span><br>&#125;&#123;<br>    mapping: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>),<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Lookup</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    cache.Lock()<br>    v := cache.mapping[key]<br>    cache.Unlock()<br>    <span class="hljs-keyword">return</span> v<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们给新的变量起了一个更具表达性的名字：cache。因为sync.Mutex字段也被嵌入到了这个struct里，其Lock和Unlock方法也就都被引入到了这个匿名结构中了，这让我们能够以一个简单明了的语法来对其进行加锁解锁操作。</p>
<p>一个应用的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;encoding/json&quot;</span><br>	<span class="hljs-string">&quot;fmt&quot;</span><br>)<br><span class="hljs-comment">//定义手机屏幕</span><br><span class="hljs-keyword">type</span> Screen01 <span class="hljs-keyword">struct</span> &#123;<br>	Size       <span class="hljs-keyword">float64</span> <span class="hljs-comment">//屏幕尺寸</span><br>	ResX, ResY <span class="hljs-keyword">int</span> <span class="hljs-comment">//屏幕分辨率 水平 垂直</span><br>&#125;<br><span class="hljs-comment">//定义电池容量</span><br><span class="hljs-keyword">type</span> Battery <span class="hljs-keyword">struct</span> &#123;<br>	Capacity <span class="hljs-keyword">string</span><br>&#125;<br> <br><span class="hljs-comment">//返回json数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getJsonData</span><span class="hljs-params">()</span> []<span class="hljs-title">byte</span></span> &#123;<br>	<span class="hljs-comment">//tempData 接收匿名结构体（匿名结构体使得数据的结构更加灵活）</span><br>	tempData := <span class="hljs-keyword">struct</span> &#123;<br>		Screen01<br>		Battery<br>		HashTouchId <span class="hljs-keyword">bool</span>  <span class="hljs-comment">// 是否有指纹识别</span><br>	&#125;&#123;<br>		Screen01:    Screen01&#123;Size: <span class="hljs-number">12</span>, ResX: <span class="hljs-number">36</span>, ResY: <span class="hljs-number">36</span>&#125;,<br>		Battery:     Battery&#123;<span class="hljs-string">&quot;6000毫安&quot;</span>&#125;,<br>		HashTouchId: <span class="hljs-literal">true</span>,<br>	&#125;<br>	jsonData, _ := json.Marshal(tempData)  <span class="hljs-comment">//将数据转换为json</span><br>	<span class="hljs-keyword">return</span> jsonData<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	jsonData := getJsonData() <span class="hljs-comment">//获取json数据</span><br>	fmt.Println(jsonData)<br>	fmt.Println(<span class="hljs-string">&quot;=========解析（分离）出的数据是===========&quot;</span>)<br>	<span class="hljs-comment">//自定义匿名结构体，解析（分离）全部数据</span><br>	allData := <span class="hljs-keyword">struct</span> &#123;<br>		Screen01<br>		Battery<br>		HashTouchId <span class="hljs-keyword">bool</span><br>	&#125;&#123;&#125;<br>	json.Unmarshal(jsonData, &amp;allData)<br>	fmt.Println(<span class="hljs-string">&quot;解析（分离）全部结构为：&quot;</span>, allData)<br>	<span class="hljs-comment">//自定义匿名结构体，通过json数据，解析（分离）对应的结构（可以是部分结构）</span><br>	screenBattery := <span class="hljs-keyword">struct</span> &#123;<br>		Screen01<br>		Battery<br>	&#125;&#123;&#125;<br>	json.Unmarshal(jsonData, &amp;screenBattery) <span class="hljs-comment">//注意：此处只能为结构体指针（一般参数为interface&#123;&#125;，都采用地址引用（即地址传递））</span><br>	fmt.Println(<span class="hljs-string">&quot;解析（分离）部分结构:&quot;</span>, screenBattery)<br>	<span class="hljs-comment">//自定义匿名结构体，解析（分离）部分结构</span><br>	batteryTouch := <span class="hljs-keyword">struct</span> &#123;<br>		Battery<br>		isTouch <span class="hljs-keyword">bool</span><br>	&#125;&#123;&#125;<br>	json.Unmarshal(jsonData, &amp;batteryTouch)<br>	fmt.Println(<span class="hljs-string">&quot;解析（分离）部分结构:&quot;</span>, batteryTouch)<br>	<span class="hljs-comment">//自定义匿名结构体，解析（分离）部分不存在的结构</span><br>	temp1 := <span class="hljs-keyword">struct</span> &#123;<br>		Battery<br>		Detail <span class="hljs-keyword">struct</span> &#123;<br>			Name  <span class="hljs-keyword">string</span><br>			Price <span class="hljs-keyword">uint16</span><br>		&#125;<br>	&#125;&#123;&#125;<br>	json.Unmarshal(jsonData, &amp;temp1)<br>	fmt.Println(<span class="hljs-string">&quot;解析（分离）部分不存在的结构&quot;</span>, temp1)<br>	<span class="hljs-comment">//自定义匿名结构体，解析（分离）完全不存在的结构</span><br>	temp2 := <span class="hljs-keyword">struct</span> &#123;<br>		User  <span class="hljs-keyword">string</span><br>		Price <span class="hljs-keyword">uint16</span><br>	&#125;&#123;&#125;<br>	json.Unmarshal(jsonData, &amp;temp2)<br>	fmt.Println(<span class="hljs-string">&quot;解析（分离）完全不存在的结构:&quot;</span>, temp2)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>在Go语言中，我们可以对结构体的字段进行封装，并通过结构体中的方法来操作内部的字段。如果结构体中字段名的首字母是小写字母，那么这样的字段是私有的，相当于private字段。外部包裹能直接访问，如果是在名的首字母是大写字母，那么这样的字段对外暴露的，相当于public字段。能够起的方法也是一样的，如果方法名首字母是大写字母，那么这样的方法对外暴露的。</p>
<p>封装的好处：</p>
<ul>
<li>隐藏实现细节；</li>
<li>可以对数据进行验证，保证数据安全合理。</li>
</ul>
<p>如何体现封装：</p>
<ul>
<li>对结构体中的属性进行封装；</li>
<li>通过方法，包，实现封装。</li>
</ul>
<p>封装的实现步骤：</p>
<ol>
<li>将结构体、字段的首字母小写；</li>
<li>给结构体所在的包提供一个工厂模式的函数，首字母大写，类似一个构造函数；</li>
<li>提供一个首字母大写的Set方法（类似其它语言的public），用于对属性判断并赋值；</li>
<li>提供一个首字母大写的Get方法（类似其它语言的public），用于获取属性的值。</li>
</ol>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> model<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>	Name <span class="hljs-keyword">string</span><br>	age <span class="hljs-keyword">int</span>   <span class="hljs-comment">//其它包不能直接访问..</span><br>	sal <span class="hljs-keyword">float64</span><br>&#125;<br><br><span class="hljs-comment">//写一个工厂模式的函数，相当于构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPerson</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">person</span></span> &#123;<br>	<span class="hljs-keyword">return</span> &amp;person&#123;<br>		Name : name,<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//为了访问age 和 sal 我们编写一对SetXxx的方法和GetXxx的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *person)</span> <span class="hljs-title">SetAge</span><span class="hljs-params">(age <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	<span class="hljs-keyword">if</span> age &gt;<span class="hljs-number">0</span> &amp;&amp; age &lt;<span class="hljs-number">150</span> &#123;<br>		p.age = age<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		fmt.Println(<span class="hljs-string">&quot;年龄范围不正确..&quot;</span>)<br>		<span class="hljs-comment">//给程序员给一个默认值</span><br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *person)</span> <span class="hljs-title">GetAge</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>	<span class="hljs-keyword">return</span> p.age<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *person)</span> <span class="hljs-title">SetSal</span><span class="hljs-params">(sal <span class="hljs-keyword">float64</span>)</span></span> &#123;<br>	<span class="hljs-keyword">if</span> sal &gt;= <span class="hljs-number">3000</span> &amp;&amp; sal &lt;= <span class="hljs-number">30000</span> &#123;<br>		p.sal = sal<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		fmt.Println(<span class="hljs-string">&quot;薪水范围不正确..&quot;</span>)<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *person)</span> <span class="hljs-title">GetSal</span><span class="hljs-params">()</span> <span class="hljs-title">float64</span></span> &#123;<br>	<span class="hljs-keyword">return</span> p.sal<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;mytest/encapsulation/model&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>	p := model.NewPerson(<span class="hljs-string">&quot;smith&quot;</span>)<br>	p.SetAge(<span class="hljs-number">18</span>)<br>	p.SetSal(<span class="hljs-number">5000</span>)<br>	fmt.Println(p)<br>	fmt.Println(p.Name, <span class="hljs-string">&quot; age =&quot;</span>, p.GetAge(), <span class="hljs-string">&quot; sal = &quot;</span>, p.GetSal())<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="slice的结构体"><a href="#slice的结构体" class="headerlink" title="slice的结构体"></a>slice的结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>    array unsafe.Pointer <span class="hljs-comment">// 指针,指向底层数组</span><br>    <span class="hljs-built_in">len</span>   <span class="hljs-keyword">int</span> <span class="hljs-comment">// slice长度，即当前slice可以访问的范围</span><br>    <span class="hljs-built_in">cap</span>   <span class="hljs-keyword">int</span> <span class="hljs-comment">// slice容量，当前slice可访问底层数组的最大范围，如果cap不够，则会执行扩容操作</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="切片和数组的关系"><a href="#切片和数组的关系" class="headerlink" title="切片和数组的关系"></a>切片和数组的关系</h3><ol>
<li>切片的本质是操作数组，只是数组是固定长度的，而切片的长度可变的</li>
<li>切片是引用类型，可以理解为引用数组的一个片段；而数组是值类型，把数组A赋值给数组B，会为数组B开辟新的内存空间，修改数组B的值并不会影响数组A。而切片作为引用类型，指向同一个内存地址，是会互相影响的。</li>
</ol>
<p>切片的长度：元素的个数</p>
<p>切片的容量：在切片引用的底层数组中从切片的第一个元素到数组最后一个元素的长度（元素数量）</p>
<p>所以判断一个切片是否为空，使用len(s) == 0 判断，不能使用 s==nil 判断</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">a1 := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br><br>s5 := a1[:<span class="hljs-number">4</span>] <span class="hljs-comment">//[1 2 3 4]</span><br>s6 := a1[<span class="hljs-number">2</span>:] <span class="hljs-comment">//[3 4 5 6 7 8 9]</span><br>s7 := a1[:]  <span class="hljs-comment">//[1 2 3 4 5 6 7 8 9]</span><br><br>fmt.Printf(<span class="hljs-string">&quot;len(s5):%d cap(s5):%d\\n&quot;</span>, <span class="hljs-built_in">len</span>(s5), <span class="hljs-built_in">cap</span>(s5)) <span class="hljs-comment">//4 9</span><br>fmt.Printf(<span class="hljs-string">&quot;len(s6):%d cap(s6):%d\\n&quot;</span>, <span class="hljs-built_in">len</span>(s6), <span class="hljs-built_in">cap</span>(s6)) <span class="hljs-comment">//7 7</span><br>fmt.Printf(<span class="hljs-string">&quot;len(s7):%d cap(s7):%d\\n&quot;</span>, <span class="hljs-built_in">len</span>(s7), <span class="hljs-built_in">cap</span>(s7)) <span class="hljs-comment">//9 9</span><br></code></pre></td></tr></table></figure>

<p>注意：<strong>slice是引用类型</strong></p>
<p>当底层数组改变时，不管是切片，还是切片再切片，值都会改变。因为他们使用的是一个内存块，引用的一个内存地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//定义数组</span><br>a1 := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br><span class="hljs-comment">//有数组切割成切片s6</span><br>s6 := a1[<span class="hljs-number">2</span>:] <span class="hljs-comment">//[3 4 5 6 7 8 9]</span><br><span class="hljs-comment">//切片再次切片，赋值给s8</span><br>s8 :=s6[<span class="hljs-number">3</span>:] <span class="hljs-comment">//[6 7 8 9]</span><br><span class="hljs-comment">//修改原始数组，把下标为2的值由3改为333</span><br>a1[<span class="hljs-number">2</span>] = <span class="hljs-number">333</span><br><span class="hljs-comment">//打印s6，发现s6中的3也变成了333</span><br>fmt.Println(<span class="hljs-string">&quot;s6:&quot;</span>, s6) <span class="hljs-comment">//[333 4 5 6 7 8 9]</span><br><span class="hljs-comment">//因为s8基于s6切片而成，我们测试一下切片再切片的引用传的</span><br>fmt.Println(<span class="hljs-string">&quot;s8:&quot;</span>, s8) <span class="hljs-comment">//[6 7 8 9]</span><br><span class="hljs-comment">//我们把原始数组下标为5的值由6改为666</span><br>a1[<span class="hljs-number">5</span>] = <span class="hljs-number">666</span><br><span class="hljs-comment">//打印s8切片，得到结果6也变成了666</span><br>fmt.Println(<span class="hljs-string">&quot;s8:&quot;</span>, s8) <span class="hljs-comment">//[666 7 8 9]</span><br></code></pre></td></tr></table></figure>

<h3 id="生成切片"><a href="#生成切片" class="headerlink" title="生成切片"></a>生成切片</h3><p>初始化一个 slice 有两种方式:</p>
<ul>
<li>直接声明: 比如 <code>var s []int</code></li>
<li>使用 make 关键字，比如: <code>s := make([]int, 0)</code></li>
</ul>
<p>区别：</p>
<ul>
<li>直接声明 slice 的方式内部是不申请内存空间的，slice 内部 array 指针指向 null。</li>
<li>使用 make 关键字<strong>会申请包含 0 个元素的内存空间</strong>，底层 array 指针指向申请的内存。</li>
</ul>
<p>使用json.Marshal序列化的结果是有区别的。</p>
<ul>
<li>json.Marshal(直接声明): 返回 null</li>
<li>json.Marshal(make关键字初始化): 返回 []</li>
</ul>
<p><strong>make()函数的第一个参数指定切片的数组类型，第二个参数指定切片的长度，第三个参数指定切片的容量。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>)<br>fmt.Printf(<span class="hljs-string">&quot;s1：%v len(s1)：%d cap(s1)：%d\\n&quot;</span>, s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1))<br></code></pre></td></tr></table></figure>

<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>只有 append 操作可以触发 slice 的扩容</p>
<p>slice 在初始化时只会申请有限的内存空间，而随着 append 元素的增多，当元素超过当前 slice 的 cap ，就会重新申请一段新内存，把原数据 copy 到这个新内存上，然后 slice 把内部的指针指向这段新内存。</p>
<ol>
<li>如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）</li>
<li>如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）</li>
<li>如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li>
<li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）</li>
</ol>
<p>源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">newcap := old.<span class="hljs-built_in">cap</span><br>    doublecap := newcap + newcap <span class="hljs-comment">// 两倍扩容</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &gt; doublecap &#123; <span class="hljs-comment">// 待扩容大小大于原切片的两倍，则按照待扩容大小处理</span><br>        newcap = <span class="hljs-built_in">cap</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> old.<span class="hljs-built_in">len</span> &lt; <span class="hljs-number">1024</span> &#123; <span class="hljs-comment">// 当原切片长度小于1024时，新切片的容量会直接翻倍。</span><br>            newcap = doublecap<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 当原切片的容量大于等于1024时，会反复地增加25%，直到新容量超过所需要的容量。</span><br>            <span class="hljs-comment">// Check 0 &lt; newcap to detect overflow</span><br>            <span class="hljs-comment">// and prevent an infinite loop.</span><br>            <span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="hljs-built_in">cap</span> &#123;<br>                newcap += newcap / <span class="hljs-number">4</span><br>            &#125;<br>            <span class="hljs-comment">// Set newcap to the requested cap when</span><br>            <span class="hljs-comment">// the newcap calculation overflowed.</span><br>            <span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> &#123;<br>                newcap = <span class="hljs-built_in">cap</span><br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>demo</p>
<p>如果在函数内部发生了扩容，这时再修改 slice 中的值是不起作用的，因为修改发生在新的 array 内存中，对老的 array 内存不起作用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	s := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>,<span class="hljs-number">8</span>)<br>	s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>	s[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>	s[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br>	fmt.Println(<span class="hljs-string">&quot;s =&quot;</span>,s, <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//s = [0 1 2] 8</span><br>	s1 := s;<br>	<span class="hljs-comment">// 指向同一数组（s还有容量可以扩容，所以其实s和s1其实是都指向同一数组的，可以理解为浅拷贝）</span><br>	s1 = <span class="hljs-built_in">append</span>(s,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>	s1[<span class="hljs-number">1</span>] = <span class="hljs-number">123</span><br>	fmt.Println(<span class="hljs-string">&quot;s =&quot;</span>,s, <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//s = [0 123 2] 8</span><br>	fmt.Println(<span class="hljs-string">&quot;s1=&quot;</span>,s1, <span class="hljs-built_in">cap</span>(s1)) <span class="hljs-comment">//s1= [0 123 2 3 4] 8</span><br><br>	<span class="hljs-comment">// s没有容量扩容了，新slice和s指向不同数组（可以理解为执行了slice的深拷贝）</span><br>	s2 := <span class="hljs-built_in">append</span>(s1,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)<br>	fmt.Println(<span class="hljs-string">&quot;s2=&quot;</span>,s2, <span class="hljs-built_in">cap</span>(s2)) <span class="hljs-comment">//s2= [0 123 2 3 4 1 2 3 4 5] 16</span><br>	s2[<span class="hljs-number">2</span>] = <span class="hljs-number">123</span><br>	fmt.Println(<span class="hljs-string">&quot;s =&quot;</span>,s, <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//s = [0 123 2] 8</span><br>	fmt.Println(<span class="hljs-string">&quot;s2=&quot;</span>,s2, <span class="hljs-built_in">cap</span>(s2)) <span class="hljs-comment">//s2= [0 123 123 3 4 1 2 3 4 5] 16</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>copy方法是复制了一份，开辟了新的内存空间，不再引用s1的内存地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//定义切片s1</span><br>s1 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><br><span class="hljs-comment">//第一种方式：直接声明变量 用=赋值</span><br><span class="hljs-comment">//s2切片和s1引用同一个内存地址</span><br><span class="hljs-keyword">var</span> s2 = s1<br><br><span class="hljs-comment">//第二种方式：copy</span><br><span class="hljs-keyword">var</span> s3 = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">copy</span>(s3, s1)            <span class="hljs-comment">//使用copy函数将 参数2的元素复制到参数1</span><br><br>s1[<span class="hljs-number">0</span>] = <span class="hljs-number">11</span><br>fmt.Printf(<span class="hljs-string">&quot;s1:%v s2:%v s3:%v&quot;</span>,s1, s2, s3) <span class="hljs-comment">//s1和s2是[11 2 3] s3是[1 2 3]</span><br></code></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除切片中的元素 不能直接删除 可以组合使用分割+append的方式删除切片中的元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s3 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>s3 = <span class="hljs-built_in">append</span>(s3[:<span class="hljs-number">1</span>], s3[<span class="hljs-number">2</span>:]...) <span class="hljs-comment">//第一个不用拆开 原因是一个作为被接受的一方  是把后面的元素追加到第一个</span><br>fmt.Println(s3)<br></code></pre></td></tr></table></figure>

<h2 id="rune"><a href="#rune" class="headerlink" title="rune"></a>rune</h2><p>rune它是int32的别名（-2147483648~2147483647），相比于byte（-128～127），可表示的字符更多。由于rune可表示的范围更大，所以能处理一切字符，当然也包括中文字符。在平时计算中文字符，可用rune。</p>
<p>字符串修改是不能直接修改的，需要转成rune切片后再修改</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s2 := <span class="hljs-string">&quot;小白兔&quot;</span><br>s3 := []<span class="hljs-keyword">rune</span>(s2)        <span class="hljs-comment">//把字符串强制转成rune切片</span><br>s3[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;大&#x27;</span>             <span class="hljs-comment">//注意 这里需要使用单引号的字符，而不是双引号的字符串</span><br>fmt.Println(<span class="hljs-keyword">string</span>(s3)) <span class="hljs-comment">//把rune类型的s3强转成字符串</span><br></code></pre></td></tr></table></figure>

<p><strong>只要是双引号包裹的类型就是string，只要是单引号包裹的类型就是int32，也就是rune。和中英文无关。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">c1 := <span class="hljs-string">&quot;红&quot;</span><br>c2 := <span class="hljs-string">&#x27;红&#x27;</span>                            <br>fmt.Printf(<span class="hljs-string">&quot;c1的类型:%T c2的类型:%T \\n&quot;</span>, c1, c2)  <span class="hljs-comment">//c1的类型:string c2的类型:int32</span><br>c3 := <span class="hljs-string">&quot;H&quot;</span>                            <br>c4 := <span class="hljs-string">&#x27;H&#x27;</span>                            <br>fmt.Printf(<span class="hljs-string">&quot;c3的类型:%T c4的类型:%T \\n&quot;</span>, c3, c4)  <span class="hljs-comment">//c3的类型:string c4的类型:int32</span><br></code></pre></td></tr></table></figure>

<h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p>Interface 是一个定义了方法签名的集合,用来指定对象的行为，如果对象做到了 Interface 中方法集定义的行为，那就可以说实现了 Interface；</p>
<p>这些方法可以在不同的地方被不同的对象实现，这些实现可以具有不同的行为；</p>
<p>interface 的主要工作仅是提供方法名称签名,输入参数,返回类型。最终由具体的对象来实现方法，比如 struct；</p>
<p>interface 初始化值为 nil；</p>
<p><code>golang</code>接口定义不能包含变量，但是允许不带任何方法，这种类型的接口叫 <code>empty interface</code>。</p>
<p>使用 type 关键字来申明，interface 代表类型，大括号里面定义接口的方法签名集合。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">interface</span> &#123;<br>	Bark() <span class="hljs-keyword">string</span><br>	Walk() <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如下，Dog 实现了 Animal 接口，所以可以用 Animal 的实例去接收 Dog的实例，必须是同时实现 Bark() 和Walk() 方法，否则都不能算实现了Animal接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>	name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dog Dog)</span> <span class="hljs-title">Bark</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br>	fmt.Println(dog.name + <span class="hljs-string">&quot;:wan wan wan!&quot;</span>)<br>	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;wan wan wan&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dog Dog)</span> <span class="hljs-title">Walk</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br>	fmt.Println(dog.name + <span class="hljs-string">&quot;:walk to park!&quot;</span>)<br>	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;walk to park&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> animal Animal<br><br>	fmt.Println(<span class="hljs-string">&quot;animal value is:&quot;</span>, animal)	<span class="hljs-comment">//animal value is: &lt;nil&gt;</span><br>	fmt.Printf(<span class="hljs-string">&quot;animal type is: %T\\n&quot;</span>, animal) <span class="hljs-comment">//animal type is: &lt;nil&gt;</span><br><br>	animal = Dog&#123;<span class="hljs-string">&quot;旺财&quot;</span>&#125;<br>	animal.Bark() <span class="hljs-comment">//旺财:wan wan wan!</span><br>	animal.Walk() <span class="hljs-comment">//旺财:walk to park!</span><br><br>	fmt.Println(<span class="hljs-string">&quot;animal value is:&quot;</span>, animal) <span class="hljs-comment">//animal value is: &#123;旺财&#125;</span><br>	fmt.Printf(<span class="hljs-string">&quot;animal type is: %T\\n&quot;</span>, animal) <span class="hljs-comment">//animal type is: main.Dog</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>nil interface</strong></p>
<p>官方定义：Interface values with nil underlying values:</p>
<ul>
<li>只声明没赋值的interface 是nil interface，value和 type 都是 nil</li>
<li>只要赋值了，即使赋了一个值为nil类型，也不再是nil interface</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>	Hello()<br>&#125;<br><br><span class="hljs-keyword">type</span> S []<span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i S)</span> <span class="hljs-title">Hello</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> i I<br>	fmt.Printf(<span class="hljs-string">&quot;1:i Type:%T\\n&quot;</span>, i)<br>	fmt.Printf(<span class="hljs-string">&quot;2:i Value:%v\\n&quot;</span>, i)<br><br>	<span class="hljs-keyword">var</span> s S<br>	<span class="hljs-keyword">if</span> s == <span class="hljs-literal">nil</span> &#123;<br>		fmt.Printf(<span class="hljs-string">&quot;3:s Value%v\\n&quot;</span>, s)<br>		fmt.Printf(<span class="hljs-string">&quot;4:s Type is %T\\n&quot;</span>, s)<br>	&#125;<br><br>	i = s<br>	<span class="hljs-keyword">if</span> i == <span class="hljs-literal">nil</span> &#123;<br>		fmt.Println(<span class="hljs-string">&quot;5:i is nil&quot;</span>)<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		fmt.Printf(<span class="hljs-string">&quot;6:i Type:%T\\n&quot;</span>, i)<br>		fmt.Printf(<span class="hljs-string">&quot;7:i Value:%v\\n&quot;</span>, i)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>output：</p>
<p>其中把值为 nil 的变量 s 赋值i后,i 不再为nil interface</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go">	<span class="hljs-number">1</span>:i Type:&lt;<span class="hljs-literal">nil</span>&gt;<br>	<span class="hljs-number">2</span>:i Value:&lt;<span class="hljs-literal">nil</span>&gt;<br>	<span class="hljs-number">3</span>:s Value[]<br>	<span class="hljs-number">4</span>:s Type is main.S<br>	<span class="hljs-number">6</span>:i Type:main.S<br>	<span class="hljs-number">7</span>:i Value:[]<br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> State <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testnil1</span><span class="hljs-params">(a, b <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span> &#123;<br>	<span class="hljs-keyword">return</span> a == b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testnil2</span><span class="hljs-params">(a *State, b <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span> &#123;<br>	<span class="hljs-keyword">return</span> a == b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testnil3</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span> &#123;<br>	<span class="hljs-keyword">return</span> a == <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testnil4</span><span class="hljs-params">(a *State)</span> <span class="hljs-title">bool</span></span> &#123;<br>	<span class="hljs-keyword">return</span> a == <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testnil5</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span> &#123;<br>	v := reflect.ValueOf(a)<br>	<span class="hljs-keyword">return</span> !v.IsValid() || v.IsNil()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> a *State<br>	fmt.Println(testnil1(a, <span class="hljs-literal">nil</span>)) <span class="hljs-comment">//false</span><br>	fmt.Println(testnil2(a, <span class="hljs-literal">nil</span>)) <span class="hljs-comment">//false</span><br>	fmt.Println(testnil3(a)) <span class="hljs-comment">//false</span><br>	fmt.Println(testnil4(a)) <span class="hljs-comment">//true</span><br>	fmt.Println(testnil5(a)) <span class="hljs-comment">//true</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。</p>
<p>在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">(value, <span class="hljs-keyword">type</span>)<br></code></pre></td></tr></table></figure>

<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>reflect.TypeOf： 直接给到了我们想要的type类型，如float64、int、各种pointer、struct 等等真实的类型</p>
<p>reflect.ValueOf：直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;{1 “Allen.Wu” 25} 这样的结构体struct的值</p>
<p>也就是说明反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是reflect.Type和reflect.Value这两种</p>
<h3 id="获取接口interface信息"><a href="#获取接口interface信息" class="headerlink" title="获取接口interface信息"></a>获取接口interface信息</h3><p>当执行reflect.ValueOf(interface)之后，就得到了一个类型为”relfect.Value”变量，可以通过它本身的Interface()方法获得接口变量的真实内容，然后可以通过类型判断进行转换，转换为原有真实类型。</p>
<h4 id="已知原有类型"><a href="#已知原有类型" class="headerlink" title="已知原有类型"></a>已知原有类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> num <span class="hljs-keyword">float64</span> = <span class="hljs-number">1.2345</span><br><br>	pointer := reflect.ValueOf(&amp;num)<br>	value := reflect.ValueOf(num)<br><br>	<span class="hljs-comment">// 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic</span><br>	<span class="hljs-comment">// Golang 对类型要求非常严格，类型一定要完全符合</span><br>	<span class="hljs-comment">// 如下两个，一个是*float64，一个是float64，如果弄混，则会panic</span><br>	convertPointer := pointer.Interface().(*<span class="hljs-keyword">float64</span>)<br>	convertValue := value.Interface().(<span class="hljs-keyword">float64</span>)<br><br>	fmt.Println(convertPointer)<br>	fmt.Println(convertValue)<br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//0xc42000e238</span><br><span class="hljs-comment">//1.2345</span><br><br></code></pre></td></tr></table></figure>

<h4 id="未知原有类型"><a href="#未知原有类型" class="headerlink" title="未知原有类型"></a>未知原有类型</h4><p>进行遍历探测其Filed</p>
<p>通过运行结果可以得知获取未知类型的interface的具体变量及其类型的步骤为：</p>
<ol>
<li>先获取interface的reflect.Type，然后通过NumField进行遍历</li>
<li>再通过reflect.Type的Field获取其Field</li>
<li>最后通过Field的Interface()得到对应的value</li>
</ol>
<p>通过运行结果可以得知获取未知类型的interface的所属方法（函数）的步骤为：</p>
<ol>
<li>先获取interface的reflect.Type，然后通过NumMethod进行遍历</li>
<li>再分别通过reflect.Type的Method获取对应的真实的方法（函数）</li>
<li>最后对结果取其Name和Type得知具体的方法名</li>
<li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li>
<li>struct 或者 struct 的嵌套都是一样的判断处理方式</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>	Id   <span class="hljs-keyword">int</span><br>	Name <span class="hljs-keyword">string</span><br>	Age  <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u User)</span> <span class="hljs-title">ReflectCallFunc</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;Allen.Wu ReflectCallFunc&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>	user := User&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Allen.Wu&quot;</span>, <span class="hljs-number">25</span>&#125;<br><br>	DoFiledAndMethod(user)<br><br>&#125;<br><br><span class="hljs-comment">// 通过接口来获取任意参数，然后一一揭晓</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoFiledAndMethod</span><span class="hljs-params">(input <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><br>	getType := reflect.TypeOf(input)<br>	fmt.Println(<span class="hljs-string">&quot;get Type is :&quot;</span>, getType.Name())<br><br>	getValue := reflect.ValueOf(input)<br>	fmt.Println(<span class="hljs-string">&quot;get all Fields is:&quot;</span>, getValue)<br><br>	<span class="hljs-comment">// 获取方法字段</span><br>	<span class="hljs-comment">// 1. 先获取interface的reflect.Type，然后通过NumField进行遍历</span><br>	<span class="hljs-comment">// 2. 再通过reflect.Type的Field获取其Field</span><br>	<span class="hljs-comment">// 3. 最后通过Field的Interface()得到对应的value</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; getType.NumField(); i++ &#123;<br>		field := getType.Field(i)<br>		value := getValue.Field(i).Interface()<br>		fmt.Printf(<span class="hljs-string">&quot;%s: %v = %v\n&quot;</span>, field.Name, field.Type, value)<br>	&#125;<br><br>	<span class="hljs-comment">// 获取方法</span><br>	<span class="hljs-comment">// 1. 先获取interface的reflect.Type，然后通过.NumMethod进行遍历</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; getType.NumMethod(); i++ &#123;<br>		m := getType.Method(i)<br>		fmt.Printf(<span class="hljs-string">&quot;%s: %v\n&quot;</span>, m.Name, m.Type)<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//get Type is : User</span><br><span class="hljs-comment">//get all Fields is: &#123;1 Allen.Wu 25&#125;</span><br><span class="hljs-comment">//Id: int = 1</span><br><span class="hljs-comment">//Name: string = Allen.Wu</span><br><span class="hljs-comment">//Age: int = 25</span><br><span class="hljs-comment">//ReflectCallFunc: func(main.User)</span><br><br></code></pre></td></tr></table></figure>

<h3 id="设置变量值"><a href="#设置变量值" class="headerlink" title="设置变量值"></a>设置变量值</h3><p>reflect.Value是通过reflect.ValueOf(X)获得的，只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>	<span class="hljs-keyword">var</span> num <span class="hljs-keyword">float64</span> = <span class="hljs-number">1.2345</span><br>	fmt.Println(<span class="hljs-string">&quot;old value of pointer:&quot;</span>, num)<br><br>	<span class="hljs-comment">// 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值</span><br>	pointer := reflect.ValueOf(&amp;num)<br>	newValue := pointer.Elem()<br><br>	fmt.Println(<span class="hljs-string">&quot;type of pointer:&quot;</span>, newValue.Type())<br>	fmt.Println(<span class="hljs-string">&quot;settability of pointer:&quot;</span>, newValue.CanSet())<br><br>	<span class="hljs-comment">// 重新赋值</span><br>	newValue.SetFloat(<span class="hljs-number">77</span>)<br>	fmt.Println(<span class="hljs-string">&quot;new value of pointer:&quot;</span>, num)<br><br>	<span class="hljs-comment">////////////////////</span><br>	<span class="hljs-comment">// 如果reflect.ValueOf的参数不是指针，会如何？</span><br>	pointer = reflect.ValueOf(num)<br>	<span class="hljs-comment">//newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”</span><br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//old value of pointer: 1.2345</span><br><span class="hljs-comment">//type of pointer: float64</span><br><span class="hljs-comment">//settability of pointer: true</span><br><span class="hljs-comment">//new value of pointer: 77</span><br></code></pre></td></tr></table></figure>

<h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>	Id   <span class="hljs-keyword">int</span><br>	Name <span class="hljs-keyword">string</span><br>	Age  <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u User)</span> <span class="hljs-title">ReflectCallFuncHasArgs</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, age <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;ReflectCallFuncHasArgs name: &quot;</span>, name, <span class="hljs-string">&quot;, age:&quot;</span>, age, <span class="hljs-string">&quot;and origal User.Name:&quot;</span>, u.Name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u User)</span> <span class="hljs-title">ReflectCallFuncNoArgs</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;ReflectCallFuncNoArgs&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 如何通过反射来进行方法的调用？</span><br><span class="hljs-comment">// 本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调动mv.Call</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	user := User&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Allen.Wu&quot;</span>, <span class="hljs-number">25</span>&#125;<br>	<br>	<span class="hljs-comment">// 1. 要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</span><br>	getValue := reflect.ValueOf(user)<br><br>	<span class="hljs-comment">// 一定要指定参数为正确的方法名</span><br>	<span class="hljs-comment">// 2. 先看看带有参数的调用方法</span><br>	methodValue := getValue.MethodByName(<span class="hljs-string">&quot;ReflectCallFuncHasArgs&quot;</span>)<br>	args := []reflect.Value&#123;reflect.ValueOf(<span class="hljs-string">&quot;wudebao&quot;</span>), reflect.ValueOf(<span class="hljs-number">30</span>)&#125;<br>	methodValue.Call(args)<br><br>	<span class="hljs-comment">// 一定要指定参数为正确的方法名</span><br>	<span class="hljs-comment">// 3. 再看看无参数的调用方法</span><br>	methodValue = getValue.MethodByName(<span class="hljs-string">&quot;ReflectCallFuncNoArgs&quot;</span>)<br>	args = <span class="hljs-built_in">make</span>([]reflect.Value, <span class="hljs-number">0</span>)<br>	methodValue.Call(args)<br>&#125;<br><br><br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//ReflectCallFuncHasArgs name:  wudebao , age: 30 and origal User.Name: Allen.Wu</span><br><span class="hljs-comment">//ReflectCallFuncNoArgs</span><br><br></code></pre></td></tr></table></figure>

<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>向 <code>defer</code>关键字传入的函数会在函数返回之前运行。</p>
<p>存入的内容以先进后出的方式输出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	&#123;<br>		<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;defer1 runs&quot;</span>)<br>		fmt.Println(<span class="hljs-string">&quot;block ends&quot;</span>)<br>		<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;defer2 runs&quot;</span>)<br>	&#125;<br><br>	fmt.Println(<span class="hljs-string">&quot;main ends&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">block ends<br>main ends<br>defer2 runs<br>defer1 runs<br></code></pre></td></tr></table></figure>

<p>调用 <code>defer</code>关键字会立刻拷贝函数中引用的外部参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	startedAt := time.Now()<br>	<span class="hljs-keyword">defer</span> fmt.Println(time.Since(startedAt)) <span class="hljs-comment">//0s</span><br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Println(time.Since(startedAt)) &#125;() <span class="hljs-comment">//1s</span><br>	<br>	time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Goroutines和Channels"><a href="#Goroutines和Channels" class="headerlink" title="Goroutines和Channels"></a>Goroutines和Channels</h2><h3 id="并发和协程"><a href="#并发和协程" class="headerlink" title="并发和协程"></a>并发和协程</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34556414/article/details/120150360">并发协程相关知识</a></p>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p><strong>不要让计算通过共享内存来通讯，而应该让它们通过通讯来共享内存。</strong>通道机制就是这种哲学的一个设计结果</p>
<p>我们可以把一个通道看作是在一个程序内部的一个先进先出（FIFO：first in first out）数据队列。 一些协程可以向此通道发送数据，另外一些协程可以从此通道接收数据。</p>
<p>通道可以是双向的，也可以是单向的。</p>
<ul>
<li>字面形式<code>chan T</code>表示一个元素类型为<code>T</code>的双向通道类型。 编译器允许从此类型的值中接收和向此类型的值中发送数据。</li>
<li>字面形式<code>chan&lt;- T</code>表示一个元素类型为<code>T</code>的单向发送通道类型。 编译器不允许从此类型的值中接收数据。</li>
<li>字面形式<code>&lt;-chan T</code>表示一个元素类型为<code>T</code>的单向接收通道类型。 编译器不允许向此类型的值中发送数据。</li>
</ul>
<p>一个容量为0的通道值称为一个非缓冲通道（unbuffered channel），一个容量不为0的通道值称为一个缓冲通道（buffered channel）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)    <span class="hljs-comment">// unbuffered channel</span><br>ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// unbuffered channel</span><br>ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// buffered channel with capacity 3</span><br></code></pre></td></tr></table></figure>

<p>当一个通道值被赋给另一个通道值后，这两个通道值将共享相同的底层部分。 换句话说，这两个通道引用着同一个底层的内部通道对象。 比较这两个通道的结果为<code>true</code>。</p>
<p>通道的操作</p>
<ol>
<li><p>调用内置函数<code>close</code>来关闭一个通道：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">close</span><span class="hljs-params">(ch)</span></span><br></code></pre></td></tr></table></figure>

<p>传给<code>close</code>函数调用的实参必须为一个通道值，并且此通道值不能为单向接收的。</p>
</li>
<li><p>使用下面的语法向通道<code>ch</code>发送一个值<code>v</code>：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">ch &lt;- v<br></code></pre></td></tr></table></figure>

<p><code>v</code>必须能够赋值给通道<code>ch</code>的元素类型。 <code>ch</code>不能为单向接收通道。 <code>&lt;-</code>称为数据发送操作符。</p>
</li>
<li><p>使用下面的语法从通道<code>ch</code>接收一个值：如果一个通道操作不永久阻塞，它总会返回至少一个值，此值的类型为通道<code>ch</code>的元素类型。 <code>ch</code>不能为单向发送通道。 <code>&lt;-</code>称为数据接收操作符，是的它和数据发送操作符的表示形式是一样的。在大多数场合下，一个数据接收操作可以被认为是一个单值表达式。 但是，当一个数据接收操作被用做一个赋值语句中的唯一的源值的时候，它可以返回第二个可选的类型不确定的布尔值返回值从而成为一个多值表达式。 此类型不确定的布尔值表示第一个接收到的值是否是在通道被关闭前发送的。 （从后面的章节，我们将得知我们可以从一个已关闭的通道中接收到无穷个值。）数据接收操作在赋值中被用做源值的例子：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">&lt;-ch<br></code></pre></td></tr></table></figure>

<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">v = &lt;-ch<br>v, sentBeforeClosed = &lt;-ch<br></code></pre></td></tr></table></figure></li>
<li><p>查询一个通道的容量：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">cap</span><span class="hljs-params">(ch)</span></span><br></code></pre></td></tr></table></figure>

<p> <code>cap</code>的返回值的类型为内置类型<code>int</code>。</p>
</li>
<li><p>查询一个通道的长度：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">(ch)</span></span><br></code></pre></td></tr></table></figure></li>
</ol>
<p> <code>len</code>的返回值的类型也为内置类型<code>int</code>。 一个通道的长度是指当前有多少个已被发送到此通道但还未被接收出去的元素值。</p>
<ul>
<li>如果一个通道已经关闭了，则它的发送数据协程队列和接收数据协程队列肯定都为空，但是它的缓冲队列可能不为空。</li>
<li>在任何时刻，如果缓冲队列不为空，则接收数据协程队列必为空。</li>
<li>在任何时刻，如果缓冲队列未满，则发送数据协程队列必为空。</li>
<li>如果一个通道是缓冲的，则在任何时刻，它的发送数据协程队列和接收数据协程队列之一必为空。</li>
<li>如果一个通道是非缓冲的，则在任何时刻，一般说来，它的发送数据协程队列和接收数据协程队列之一必为空， 但是有一个例外：一个协程可能在一个<code>select</code>流程控制中同时被推入到此通道的发送数据协程队列和接收数据协程队列中。</li>
</ul>
<p>一个简单的通过一个非缓冲通道实现的请求/响应的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>) <span class="hljs-comment">// 一个非缓冲通道</span><br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>, x <span class="hljs-keyword">int</span>)</span></span> &#123;<br>		time.Sleep(time.Second)<br>		<span class="hljs-comment">// &lt;-ch    // 此操作编译不通过</span><br>		ch &lt;- x*x  <span class="hljs-comment">// 阻塞在此，直到发送的值被接收</span><br>	&#125;(c, <span class="hljs-number">3</span>)<br>	done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>		n := &lt;-ch      <span class="hljs-comment">// 阻塞在此，直到有值发送到c</span><br>		fmt.Println(n) <span class="hljs-comment">// 9</span><br>		<span class="hljs-comment">// ch &lt;- 123   // 此操作编译不通过</span><br>		time.Sleep(time.Second)<br>		done &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>	&#125;(c)<br>	&lt;-done <span class="hljs-comment">// 阻塞在此，直到有值发送到done</span><br>	fmt.Println(<span class="hljs-string">&quot;bye&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//9 </span><br><span class="hljs-comment">//bye</span><br></code></pre></td></tr></table></figure>

<p>缓冲通道的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 一个容量为2的缓冲通道</span><br>	c &lt;- <span class="hljs-number">3</span><br>	c &lt;- <span class="hljs-number">5</span><br>	<span class="hljs-built_in">close</span>(c)<br>	fmt.Println(<span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">cap</span>(c)) <span class="hljs-comment">// 2 2</span><br>	x, ok := &lt;-c<br>	fmt.Println(x, ok) <span class="hljs-comment">// 3 true</span><br>	fmt.Println(<span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">cap</span>(c)) <span class="hljs-comment">// 1 2</span><br>	x, ok = &lt;-c<br>	fmt.Println(x, ok) <span class="hljs-comment">// 5 true</span><br>	fmt.Println(<span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">cap</span>(c)) <span class="hljs-comment">// 0 2</span><br>	x, ok = &lt;-c<br>	fmt.Println(x, ok) <span class="hljs-comment">// 0 false</span><br>	x, ok = &lt;-c<br>	fmt.Println(x, ok) <span class="hljs-comment">// 0 false</span><br>	fmt.Println(<span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">cap</span>(c)) <span class="hljs-comment">// 0 2</span><br>	<span class="hljs-built_in">close</span>(c) <span class="hljs-comment">// 此行将产生一个恐慌</span><br>	c &lt;- <span class="hljs-number">7</span>   <span class="hljs-comment">// 如果上一行不存在，此行也将产生一个恐慌。</span><br></code></pre></td></tr></table></figure>

<h3 id="select流程控制"><a href="#select流程控制" class="headerlink" title="select流程控制"></a>select流程控制</h3><p>多路复用可以简单地理解为，N 个 channel 中，任意一个 channel 有数据产生，select 都可以监听到，然后执行相应的分支，接收数据并处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//声明三个存放结果的channel</span><br> <br>   firstCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)<br>   secondCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)<br>   threeCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)<br> <br>   <span class="hljs-comment">//同时开启3个goroutine下载</span><br> <br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      firstCh &lt;- downloadFile(<span class="hljs-string">&quot;firstCh&quot;</span>)<br>   &#125;()<br> <br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      secondCh &lt;- downloadFile(<span class="hljs-string">&quot;secondCh&quot;</span>)<br>   &#125;()<br> <br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      threeCh &lt;- downloadFile(<span class="hljs-string">&quot;threeCh&quot;</span>)<br>   &#125;()<br> <br>   <span class="hljs-comment">//开始select多路复用，哪个channel能获取到值，就说明哪个最先下载好，就用哪个。</span><br> <br>   <span class="hljs-keyword">select</span> &#123;<br> <br>   <span class="hljs-keyword">case</span> filePath := &lt;-firstCh:<br>      fmt.Println(filePath)<br> <br>   <span class="hljs-keyword">case</span> filePath := &lt;-secondCh:<br>      fmt.Println(filePath)<br> <br>   <span class="hljs-keyword">case</span> filePath := &lt;-threeCh:<br>      fmt.Println(filePath)<br>   &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">downloadFile</span><span class="hljs-params">(chanName <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>   <span class="hljs-comment">//模拟下载文件,可以自己随机time.Sleep点时间试试</span><br> <br>   time.Sleep(time.Second)<br>   <span class="hljs-keyword">return</span> chanName+<span class="hljs-string">&quot;:filePath&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="共享变量的并发"><a href="#共享变量的并发" class="headerlink" title="共享变量的并发"></a>共享变量的并发</h2><p><a target="_blank" rel="noopener" href="https://lailin.xyz/post/go-training-week3-sync.html">深入源码</a></p>
<h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> a, b <span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>	a = <span class="hljs-number">1</span><br>	b = <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;b=&quot;</span>,b)<br>	fmt.Println(<span class="hljs-string">&quot;a=&quot;</span>,a)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">go</span> f()<br>	g()<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2022/08/13/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220813225331713.png" srcset="/img/loading.gif" lazyload alt="image-20220813225331713"></p>
<p>以上代码有四种可能的输出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">b=<span class="hljs-number">2</span>,a=<span class="hljs-number">1</span>  <span class="hljs-comment">//1-2-3-4</span><br>b=<span class="hljs-number">0</span>,a=<span class="hljs-number">0</span>  <span class="hljs-comment">//3-4-1-2</span><br>b=<span class="hljs-number">0</span>,a=<span class="hljs-number">1</span>  <span class="hljs-comment">//3-1-2-4</span><br>b=<span class="hljs-number">2</span>,a=<span class="hljs-number">0</span>  <span class="hljs-comment">//2-3-4-1</span><br></code></pre></td></tr></table></figure>

<p>无论任何时候，只要有两个goroutine并发访问同一变量，且至少其中的一个是写操作的时候就会发生数据竞争。并且，在不影响语言规范对 goroutine 的行为定义的时候，编译器和 CPU 会对读取和写入的顺序进行重新排序。</p>
<p>所有并发的问题都可以用一致的、简单的既定的模式来规避。所以可能的话，将变量限定在goroutine内部；如果是多个goroutine都需要访问的变量，使用互斥条件来访问。</p>
<h3 id="sync-Mutex互斥锁"><a href="#sync-Mutex互斥锁" class="headerlink" title="sync.Mutex互斥锁"></a>sync.Mutex互斥锁</h3><p>可以使用一个容量只有1的channel来保证最多只有一个goroutine在同一时刻访问一个共享变量。一个只能为1和0的信号量叫做二元信号量(binary semaphore)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    sema    = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>) <span class="hljs-comment">// a binary semaphore guarding balance</span><br>    balance <span class="hljs-keyword">int</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    sema &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125; <span class="hljs-comment">// acquire token</span><br>    balance = balance + amount<br>    &lt;-sema <span class="hljs-comment">// release token</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    sema &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125; <span class="hljs-comment">// acquire token</span><br>    b := balance<br>    &lt;-sema <span class="hljs-comment">// release token</span><br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>

<p>sync包里的Mutex类型可以直接支持。它的Lock方法能够获取到token(这里叫锁)，并且Unlock方法会释放这个token。</p>
<p>如果其它的goroutine已经获得了这个锁的话，这个操作会被阻塞直到其它goroutine调用了Unlock使该锁变回可用状态。mutex会保护共享变量。</p>
<p>尽量使用defer来将临界区扩展到函数的结束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>    mu      sync.Mutex <span class="hljs-comment">// guards balance</span><br>    balance <span class="hljs-keyword">int</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    mu.Lock()<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br>    deposit(-amount)<br>    <span class="hljs-keyword">if</span> balance &lt; <span class="hljs-number">0</span> &#123;<br>        deposit(amount)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// insufficient funds</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    mu.Lock()<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br>    deposit(amount)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    mu.Lock()<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br>    <span class="hljs-keyword">return</span> balance<br>&#125;<br><br><span class="hljs-comment">// This function requires that the lock be held.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deposit</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span></span> &#123; balance += amount &#125;<br></code></pre></td></tr></table></figure>

<p>没法对一个已经锁上的mutex来再次上锁–这会导致程序死锁，没法继续执行下去，Withdraw会永远阻塞下去。</p>
<p>这样的写法是错误的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> incorrect!</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    mu.Lock()<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br>    Deposit(-amount)<br>    <span class="hljs-keyword">if</span> Balance() &lt; <span class="hljs-number">0</span> &#123;<br>        Deposit(amount)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// insufficient funds</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="sync-RWMutex读写锁"><a href="#sync-RWMutex读写锁" class="headerlink" title="sync.RWMutex读写锁"></a>sync.RWMutex读写锁</h3><p>允许多个只读操作并行执行，但写操作会完全互斥</p>
<p>RWMutex需要更复杂的内部记录，所以会让它比一般的无竞争锁的mutex慢一些。</p>
<p>sync.WaitGroup</p>
<p>一个 WaitGroup 对象可以等待一组协程结束 简单使用就是在创建一个任务的时候<code>wg.Add(1)</code>, 任务完成的时候使用<code>wg.Done()</code>来将任务减一。使用<code>wg.Wait()</code>来阻塞等待所有任务完成。</p>
<p>例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br> <br><span class="hljs-keyword">type</span> httpPkg <span class="hljs-keyword">struct</span>&#123;&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(httpPkg)</span> <span class="hljs-title">Get</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span></span> &#123;&#125;<br> <br><span class="hljs-keyword">var</span> http httpPkg<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">var</span> urls = []<span class="hljs-keyword">string</span>&#123;<br>        <span class="hljs-string">&quot;&lt;http://www.golang.org/&gt;&quot;</span>,<br>        <span class="hljs-string">&quot;&lt;http://www.google.com/&gt;&quot;</span>,<br>        <span class="hljs-string">&quot;&lt;http://www.somestupidname.com/&gt;&quot;</span>,<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> urls &#123;<br>        <span class="hljs-comment">// Increment the WaitGroup counter.</span><br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// Launch a goroutine to fetch the URL.</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span></span> &#123;<br>            <span class="hljs-comment">// Decrement the counter when the goroutine completes.</span><br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            <span class="hljs-comment">// Fetch the URL.</span><br>            http.Get(url)<br>        &#125;(url)<br>    &#125;<br>    <span class="hljs-comment">// Wait for all HTTP fetches to complete.</span><br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：golang里如果方法传递的不是地址，那么就会做一个拷贝，这里调用的wg根本就不是一个对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">1000</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> doSomething(i, wg, ch)<br>    &#125;<br>    wg.Wait()<br>    fmt.Println(<span class="hljs-string">&quot;all done&quot;</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>        dd := &lt;-ch<br>        fmt.Println(<span class="hljs-string">&quot;from ch:&quot;</span>+strconv.Itoa(dd))<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(index <span class="hljs-keyword">int</span>, wg  sync.WaitGroup, ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br>    fmt.Println(<span class="hljs-string">&quot;start done:&quot;</span> + strconv.Itoa(index))<br>    <span class="hljs-comment">//time.Sleep(20 * time.Millisecond)</span><br>    ch &lt;- index<br></code></pre></td></tr></table></figure>

<p>应该改为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> doSomething(i, &amp;wg, ch)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(index <span class="hljs-keyword">int</span>, wg *sync.WaitGroup, ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="sync-Once初始化"><a href="#sync-Once初始化" class="headerlink" title="sync.Once初始化"></a>sync.Once初始化</h3><p><code>sync.Once</code>可以保证<code>go</code>程序在运行期间的某段代码只会执行一次，作用与<code>init</code>类似，但是也有所不同：</p>
<ul>
<li><code>init</code>函数是在文件包首次被加载的时候执行，且只执行一次。</li>
<li><code>sync.Once</code>是在代码运行中需要的时候执行，且只执行一次。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> (<br>		o  sync.Once<br>		wg sync.WaitGroup<br>	)<br><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>		wg.Add(<span class="hljs-number">1</span>)<br><br>		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;<br>			<span class="hljs-keyword">defer</span> wg.Done()<br>			o.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>				fmt.Println(<span class="hljs-string">&quot;once&quot;</span>, i)<br>			&#125;)<br>		&#125;(i)<br>	&#125;<br><br>	wg.Wait()<br>&#125;<br><br><span class="hljs-comment">//输出：once 9</span><br></code></pre></td></tr></table></figure>

<p>看看源码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Once is an object that will perform exactly one action.</span><br><span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> &#123;<br> <span class="hljs-comment">// done indicates whether the action has been performed.</span><br> <span class="hljs-comment">// It is first in the struct because it is used in the hot path.</span><br> <span class="hljs-comment">// The hot path is inlined at every call site.</span><br> <span class="hljs-comment">// Placing done first allows more compact instructions on some architectures (amd64/x86),</span><br> <span class="hljs-comment">// and fewer instructions (to calculate offset) on other architectures.</span><br> done <span class="hljs-keyword">uint32</span><br> m    Mutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span> <span class="hljs-title">Do</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span>)</span> &#123;<br> <span class="hljs-keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="hljs-number">0</span> &#123;<br>  o.doSlow(f)<br> &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span> <span class="hljs-title">doSlow</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span>)</span> &#123;<br> o.m.Lock()<br> <span class="hljs-keyword">defer</span> o.m.Unlock()<br> <span class="hljs-keyword">if</span> o.done == <span class="hljs-number">0</span> &#123;<br>  <span class="hljs-keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="hljs-number">1</span>)<br>  f()<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在Do()中首先原子性的读取done字段的值是否改变，没有改变则执行doSlow()方法.</p>
<p>一进入doslow()方法就开始执行加锁操作，这样在并发情况下可以保证只有一个线程会执行，再判断一次当前done字段是否发生改变(为什么这里还要在判断一次flag？这里目的其实就是保证并发的情况下，代码块也只会执行一次，毕竟加锁是在doslow()方法内，不加这个判断的在并发情况下就会出现其他goroutine也能执行f())，如果未发生改变，则开始执行代码块，代码块运行结束后会对done字段做原子操作，标识该代码块已经被执行过了.</p>
<h3 id="竞争条件检测"><a href="#竞争条件检测" class="headerlink" title="竞争条件检测"></a>竞争条件检测</h3><p>Go的runtime和工具链为我们装备了一个复杂但好用的动态分析工具，竞争检查器(the race detector)。</p>
<p>只要在go build，go run或者go test命令后面加上-race的flag，就会使编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的test，并且会记录下每一个读或者写共享变量的goroutine的身份信息。</p>
<p>由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903918233714695">race使用指南</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/GO/">#GO</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>GO语言学习笔记</div>
      <div>http://example.com/2022/08/13/GO语言学习笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>August 13, 2022</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/08/17/%E5%90%88%E7%BA%A6%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/" title="合约基础漏洞">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">合约基础漏洞</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/09/%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/" title="合约变量存储机制">
                        <span class="hidden-mobile">合约变量存储机制</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
